[{"content":"Seringkali, program yang kita buat tidak hanya berupa server HTTP, tetapi juga mencakup komponen seperti event consumer, CLI, migrasi database dengan logika, atau kombinasi dari semuanya. Struktur ini saya gunakan untuk memungkinkan semua itu. Selain itu, fokus lainnya adalah pada pemisahan logika inti dari ketergantungan eksternal, sehingga memungkinkan penggunaan ulang kode dalam berbagai mode aplikasi.\nLink Repository : https://github.com/muchlist/templaterepo\nPrinsip-prinsip yang mendasari desain ini : Arsitektur Hexagonal: Memisahkan logika inti dari ketergantungan eksternal untuk menjaga kebersihan kode dan memudahkan pengujian. Pengelolaan Dependensi: Menghindari error siklus dependensi dengan menerapkan prinsip dependency injection dan dependency inversion, sehingga modul-modul dapat saling berinteraksi tanpa saling bergantung secara langsung. Kejelasan Struktur Kode: Menggunakan folder pkg/ untuk kode yang dapat digunakan ulang di berbagai bagian aplikasi dan folder business/ untuk menyimpan logika bisnis dan domain khusus. Aturan Pengembangan Aplikasi: Menetapkan aturan untuk pengelolaan konfigurasi, penanganan kesalahan, dan penamaan untuk memastikan konsistensi dan kualitas kode. Alat Bantu: Memanfaatkan Makefile untuk mempercepat proses pengembangan dan pre-commit hooks untuk menjaga kualitas kode dan mencegah kesalahan sebelum kode di-commit. Tujuan : Konsistensi Pengembangan: Menyediakan metode yang seragam dalam membangun aplikasi untuk meningkatkan pemahaman dan kolaborasi tim. Modularitas: Memastikan kode terpisah antar modul dan tidak tightly coupled, sehingga memudahkan pemeliharaan dan pengembangan lebih lanjut. Arsitektur yang Bersih: Mengikuti prinsip arsitektur hexagonal untuk memisahkan logika inti dari ketergantungan eksternal, meningkatkan fleksibilitas dan kemudahan pengujian. Manajemen Dependensi yang Efektif: Menghindari error siklus dependensi meskipun ada banyak modul yang saling terhubung, melalui penerapan prinsip dependency inversion. Kode yang Testable: Memastikan bahwa kode di lapisan logika dapat diuji dengan baik, meningkatkan kualitas dan keandalan aplikasi. Konseptual Hexagonal Architecture Arsitektur hexagonal (biasa disebut juga port and adapter) berfokus pada pemisahan core logika dari ketergantungan eksternal. Core harus bersih, hanya terdiri dari pustaka standar dan kode pembungkus yang dibangun dalam repositori ini.\nCore : Berisi logika bisnis aplikasi. Ports : Kumpulan abstraksi yang mendefinisikan bagaimana bagian luar sistem dapat berinteraksi dengan core. Ports dapat berupa interface yang digunakan oleh core untuk berinteraksi dengan komponen eksternal seperti database, notifikasi provider, dll. Saya biasanya menggunakan idiom golang dalam memberikan nama kepada tipe interface ini seperti storer, reader, saver, assumer. Adapters : Implementasi dari ports. Adapters menerapkan antarmuka yang didefinisikan oleh ports untuk menghubungkan core dengan komponen eksternal. Project structure ├── app │ ├── api-user │ │ ├── handler │ │ │ ├── health_check.go │ │ │ └── user.go │ │ ├── main.go │ │ └── url_map.go │ ├── consumer-user │ │ └── main.go │ └── tool-logfmt │ └── main.go ├── business │ ├── complex │ │ ├── helper │ │ │ └── formula.go │ │ ├── port │ │ │ └── storer.go │ │ ├── repo │ │ │ └── repo.go │ │ └── service │ │ └── service.go │ ├── notifserv │ │ └── service.go │ └── user │ ├── repo.go │ ├── service.go │ └── storer.go ├── conf │ ├── conf.go │ └── confs.go ├── go.mod ├── go.sum ├── migrations │ ├── 000001_create_user.down.sql │ └── 000001_create_user.up.sql ├── models │ ├── notif │ │ └── notif.go │ └── user │ ├── user_dto.go │ └── user_entity.go └── pkg ├── db-pg │ └── db.go ├── errr │ └── custom_err.go ├── mid │ └── middleware.go ├── mlog │ ├── log.go │ └── logger.go └── validate └── validate.go Folder: app/ Menyimpan kode yang tidak dapat digunakan ulang. Titik awal program ketika dijalankan :\nMemulai dan menghentikan aplikasi. Spesifik untuk operasi input/output. Pada kebanyakan projek lainnya, folder ini akan dinamakan dengan cmd. Dinamakan app karena posisi folder akan berada diatas (yang mana dirasa cukup bagus) dan cukup mewakili fungsi folder.\nAlih-alih menggunakan kerangka kerja seperti Cobra untuk memilih aplikasi yang dijalankan, kita menggunakan metode paling sederhana seperti menjalankan program dengan go run ./app/api-user untuk aplikasi API-USER dan go run ./app/consumer-user untuk aplikasi KAFKA-USER-CONSUMER.\nFolder: pkg/ Berisi paket-paket yang dapat digunakan ulang di mana saja, biasanya elemen dasar yang tidak terkait dengan modul bisnis, seperti logger, web framework, dan helper umum. Tempat untuk meletakkan library yang sudah di wrap agar mudah di mock. Lapisan aplikasi dan lapisan bisnis dapat mengimpor pkg.\nMenggunakan pkg/ sebagai penampung kode yang awalnya tidak jelas tempatnya terbukti mempercepat penulisan kode. Pertanyaan seperti \u0026quot;Taruh di mana?\u0026quot; akan mendapatkan jawaban \u0026quot;Taruh di pkg.\u0026quot; secara default.\nFolder: business/ atau internal/ Berisi code yang terkait dengan logika bisnis, problem bisnis, data bisnis.\nFolder: business/{nama-domain}/* Dalam setiap domain bisnis, ada layer service (atau core dalam istilah hexagonal) yang harus tetap bersih dari pustaka eksternal. Ini mencakup lapisan untuk mengakses data persisten (repo) dan interface-interface yang berfungsi sebagai port.\nFolder: business/{nama-domain}/{subfolder} Terkadang, sebuah domain dapat menjadi sangat kompleks, sehingga perlu memisahkan service, repo, dan elemen lainnya ke dalam beberapa bagian. Dalam kasus seperti ini, kita lebih memilih untuk mengatur dan memisahkan komponen-komponen tersebut ke dalam folder yang berbeda, yang juga akan memerlukan penggunaan package yang berbeda. Misalnya, business/complex.\nFolder: models Model-model (termasuk DTO, Payload, Entitas) dapat diletakkan di dalam package bisnis masing-masing. Namun, dalam kasus yang kompleks, di mana aplikasi A membutuhkan model B dan C, kita bisa mempertimbangkan untuk menempatkan model-model tersebut di level yang lebih tinggi agar dapat diakses oleh semuanya.\nRules Sangat penting untuk membuat dan memperbarui aturan yang telah disepakati agar semua pihak mengikuti pendekatan yang konsisten. Misalnya, template repositori ini didasarkan pada kemampuannya untuk menghindari kode yang terlalu terikat (tightly-coupled), maka aturan Cara Penulisan Dependensi Kode menjadi sangat penting untuk dipatuhi.\nAturan ini akan bertambah seiring berjalannya waktu. Misalnya, yang seringkali terjadi perbedaan pendapat :\nBagaimana cara melakukan database transaction di logic layer ? Seberapa dalam kondisi if else boleh dilakukan. dsb. Cara Penulisan Dependensi Kode Menggunakan Dependency Injection : Dependency Injection (DI) adalah pola desain di mana dependensi disediakan dari luar objek tersebut. Ini membantu mengelola ketergantungan antar komponen, membuat kode lebih modular, dan memudahkan pengujian. Jadi, modul yang saling ketergantungan, harus bergantung pada abstraksi.\nContoh konstruktor untuk membuat logic service user business/user/service.go\ntype UserService struct { storer UserStorer notifier NotifSender } // NewUserService memerlukan UserStorer dan NotifSender. // UserStorer dan NotifSender adalah abstraksi yang diperlukan oleh UserService // Objek yang akan memenuhi UserStorer dan NotifSender ini akan ditentukan oleh // pengaturan dependensi di folder /app. // UserStorer dan NotifSender juga dapat dibuat tiruannya untuk memudahkan pengujian func NewUserService(store UserStorer, notifier NotifSender) *UserService { return \u0026amp;UserService{storer: store, notifier: notifier} } Menerapkan Prinsip Dependency Inversion: Di lapisan business, terutama untuk bagian logic (biasanya dinamakan service.go atau usecase.go atau core), komunikasi antar layer mengandalkan abstraksi dan penerapan prinsip dependency inversion yang kuat. Dalam golang, dependensi inversi yang sesungguhnya bisa dicapai seperti penjelasan pada gambar berikut.\nMengenai posisi interface, sebaiknya diletakkan pada modul yang membutuhkannya. Hal ini pernah dibahas dalam buku 100 Go Mistake and how to avoid them dan beberapa buku lainnya.\nMisalnya, domain business/user memerlukan fungsi untuk mengirimkan notifikasi yang bisa dipenuhi oleh business/notifserv, namun tidak secara gamblang business/user mengatakan perlu business/notifserv, melainkan lebih kepada mengatakan \u0026quot;Saya perlu unit yang bisa menjalankan SendNotification()\u0026quot; \u0026ndash; titik.\nImplementasi dependensinya dapat dilihat di app/api-user/routing.go. Metode ini mencegah error siklus dependensi impor dan memastikan kode tetap tidak terlalu terikat (tightly-coupled) antar domain.\nContoh dependensi yang dibutuhkan untuk membuat core logic user business/user/storer.go:\npackage user import ( \u0026#34;context\u0026#34; modelUser \u0026#34;templaterepo/models/user\u0026#34; ) // UserStorer adalah interface yang mendefinisikan operasi yang dapat dilakukan terhadap database user. // Interface ini Merupakan milik dari layer service dan dimaksudkan ditulis pada bagian layer service // Meskipun kita tau persis implementasinya ada di business/user/repo.go, tetap layer service (core) hanya bergantung pada interface ini. // Implementasi konkret dari antarmuka ini akan ditentukan oleh pengaturan dependensi di folder /app. type UserStorer interface { Get(ctx context.Context, uid string) (modelUser.UserDTO, error) CreateOne(ctx context.Context, user *modelUser.UserEntity) error } // NotifSender adalah interface yang mendefinisikan operasi untuk mengirim notifikasi. // Interface ini Merupakan milik dari layer service dan dimaksudkan ditulis pada bagian layer service // Objek yang digunakan untuk mengirim notifikasi akan ditentukan oleh pengaturan dependensi di folder /app. type NotifSender interface { SendNotification(message string) error } Contoh konstruktor untuk membuat notif business/notifserv/service.go\npackage notifserv type NotifService struct{} // return konkrit struct, bukan interfacenya // karena NotifService tidak dikekang hanya untuk menjadi NotifSender func NewNotifServ() *NotifService { return \u0026amp;NotifService{} } // SendNotification diperlukan untuk memenuhi interface NotifSender pada service user func (n *NotifService) SendNotification(message string) error { // TODO : send notif to other server return nil } // SendWhatsapp tidak diperlukan oleh service user namun bisa jadi diperlukan oleh service lain func (n *NotifService) SendWhatsapp(message string, phone string) error { // TODO : send whatsapp return nil } Aturan Lainnya yang Disepakati Ikuti panduan gaya Uber sebagai dasar (https://github.com/uber-go/guide/blob/master/style.md). Aturan ini akan ditimpa apabila ada aturan yang tertulis disini. File konfigurasi hanya boleh diakses di main.go. Lapisan lain yang ingin mengakses konfigurasi harus menerimanya melalui parameter fungsi. Konfigurasi harus memiliki nilai default yang berfungsi di environment lokal, yang dapat ditimpa oleh file .env dan argumen pada command line. Error harus dihandle hanya sekali dan tidak boleh di abaikan. Maksudnya adalah antara di konsumsi atau di return, tetapi tidak keduanya sekaligus. contoh konsumsi : menulis error pada log, contoh return : mereturn error apabila error tidak nil. Jangan mengekspose variable dalam package, Gunakan kombinasi variabel private dan fungsi publik sebagai gantinya. Ketika kode banyak digunakan, buatlah helper.go. Namun jika digunakan di beberapa paket, buatlah paket baru (misalnya untuk mengekstrak error yang cuma ada di user, /business/user/ipkg/error_parser.go). Jika penggunaannya sangat luas, masukkan di /pkg (misalnya, pkg/slicer/slicer.go, pkg/datastructure/ds.go, pkg/errr/custom_error.go). Patuhi idiom golang. Namakan interface dengan akhiran -er atau -tor untuk menunjukkan bahwa mereka adalah interface, misalnya Writer, Reader, Assumer, Saver, Reader, Generator. (https://go.dev/doc/effective_go#interface-names). Contoh: Dalam proyek dengan tiga lapisan: UserServiceAssumer, UserStorer, UserSaver, UserLoader. Tools Makefile Makefile berisi command untuk membantu proses menjalankan aplikasi dengan cepat karena tidak harus mengingat semua command yang panjang. Berfungsi seperti alias. Caranya adalah dengan menuliskan cmd di file Makefile seperti contoh berikut.\nBaris teratas adalah comment yang akan muncul ketika memanggil helper.\n.PHONY adalah penanda agar terminal tidak menganggap command makefile sebagai akses ke file.\nrun/tidy: adalah alias untuk cmd yang ada didalam nya.\n## run/tidy: run golang formater and tidying code .PHONY: run/tidy run/tidy: @echo \u0026#39;Tidying and verifying module dependencies...\u0026#39; go mod tidy go mod verify @echo \u0026#39;Formatting code...\u0026#39; go fmt ./... Sebagai contoh, untuk menjalankan aplikasi-aplikasi yang ada di repositori ini kita bisa menggunakan command seperti dibawah ini :\n# 1. pastikan ketersediaan dependency seperti database dll. # 2. menjalankan aplikasi dengan makefile (lihat file Makefile) $ make run/api/user # command tersebut akan mengeksekusi $ go run ./app/api-user # sehingga mode http server dari aplikasi akan dijalankan pre-commit Disarankan menggunakan pre-commit (https://pre-commit.com/).\n// init pre-commit install // precommit akan di trigger setiap commit // manual pre-commit run --all-files ","permalink":"https://blog.muchlis.dev/post/structuring-project-folder/","summary":"\u003cp\u003eSeringkali, program yang kita buat tidak hanya berupa server HTTP, tetapi juga mencakup komponen seperti event consumer, CLI, migrasi database dengan logika, atau kombinasi dari semuanya. Struktur ini saya gunakan untuk memungkinkan semua itu. Selain itu, fokus lainnya adalah pada pemisahan logika inti dari ketergantungan eksternal, sehingga memungkinkan penggunaan ulang kode dalam berbagai mode aplikasi.\u003c/p\u003e\n\u003cp\u003eLink Repository : \u003ca href=\"https://github.com/muchlist/templaterepo\"\u003ehttps://github.com/muchlist/templaterepo\u003c/a\u003e\u003c/p\u003e","title":"Struktur Folder dan Aturan Penulisan Kode dalam Project Golang: Preferensi Pribadi"},{"content":"Dalam pengembangan backend dengan Golang, pengelolaan proses di background menggunakan goroutine merupakan praktik umum yang dapat meningkatkan kinerja aplikasi. Namun, terdapat beberapa masalah umum yang sering dihadapi ketika mengimplementasikan goroutine, terutama dalam hal penanganan panic, pengelolaan context, dan proses shutdown yang baik. Artikel ini akan mengulas beberapa kesalahan umum yang terkait dengan penggunaan goroutine dan cara mengatasinya.\nMasalah Umum dalam Penggunaan Goroutine Panic di dalam sub goroutine tidak termasuk dalam area recovery main goroutine. Context yang dipassing ke goroutine bisa terkena deadline atau canceled ketika main goroutine selesai dieksekusi. Gracefully shutdown masih dapat mengabaikan proses background yang sedang diproses. 1. Menangani Panic di Dalam Sub Goroutine Banyak pengembang yang beranggapan bahwa panic pada keseluruhan kode di service HTTP akan direcovery oleh middleware recovery. Padahal, recovery panic hanya berlaku pada satu goroutine. Jika kita memanggil goroutine lain, kita memerlukan kode recovery tambahan. Berikut adalah contohnya:\nfunc main() { // recovery panic untuk main program defer func() { if err := recover(); err != nil { fmt.Printf(\u0026#34;panic recovered: %s\u0026#34;, err) } }() go func() { // recovery panic untuk sub goroutine defer func() { if err := recover(); err != nil { fmt.Printf(\u0026#34;panic recovered: %s\u0026#34;, err) } }() // Berjalan di latar belakang publish(context.Background(), response) }() ... } Untuk mempermudah, kita bisa membuat helper function sebagai berikut:\nfunc Background(fn func()) { go func() { defer func() { if err := recover(); err != nil { fmt.Printf(\u0026#34;panic recovered: %s\u0026#34;, err) } }() fn() }() } Dengan menggunakan helper function ini, kode contoh sebelumnya dapat diubah menjadi:\nfunc main() { // recovery panic untuk main program defer func() { if err := recover(); err != nil { fmt.Printf(\u0026#34;panic recovered: %s\u0026#34;, err) } }() Background(func() { publish(context.Background(), response) }) ... } 2. Mengelola Context pada Goroutine Context selalu digunakan dalam program Golang untuk meneruskan data penting seperti tracing identification, request_id, dan untuk kebutuhan canceling proses. Namun, context yang diteruskan ke goroutine bisa menyebabkan masalah, terutama jika context tersebut selesai lebih cepat dari goroutine. Misalnya, context dari HTTP request diteruskan ke fungsi yang berjalan di goroutine yang berbeda. Jika context tersebut selesai, maka proses di goroutine akan dibatalkan jika aware terhadap context cancellation.\nContoh :\nfunc SampleHandler(w http.ResponseWriter, r *http.Request) { response, err := doSomeTask(r.Context(), r) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } go func() { // misalnya publish memerlukan waktu 2 detik // dan aware terhadap status dari context err := publish(r.Context(), response) }() // SampleHandler selesai dalam 1 detik ... } Dengan contoh di atas, publish akan gagal dan mendapatkan error context canceled. Untuk mengatasi ini, kita bisa mengganti r.Context() dengan context.Background(). Namun, bagaimana jika kita memerlukan value di dalam context? Solusinya adalah membuat implementasi context kita sendiri:\ntype Detach struct { ctx context.Context } func (d Detach) Deadline() (time.Time, bool) { return time.Time{}, false } // signal done akan diabaikan func (d Detach) Done() \u0026lt;-chan struct{} { return nil } func (d Detach) Err() error { return nil } func (d Detach) Value(key any) any { return d.ctx.Value(key) } Dengan menggunakan context custom ini, signal cancellation dari parent context tidak akan berpengaruh, sedangkan value lainnya tetap sama. Berikut adalah penerapannya pada contoh sebelumnya:\nfunc SampleHandler(w http.ResponseWriter, r *http.Request) { response, err := doSomeTask(r.Context(), r) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } go func() { // misalnya publish memerlukan waktu 2 detik // publish akan tetap dilanjutkan meskipun lebih lama daripada main func err := publish(Detach{ctx: r.Context()}, response) }() // SampleHandler selesai dalam 1 detik ... } 3. Melakukan Gracefully Shutdown dengan Goroutine Gracefully shutdown adalah proses menunggu semua proses selesai sebelum aplikasi dihentikan total. Pada HTTP server, langkah-langkahnya biasanya sebagai berikut:\nMendapatkan sinyal terminate aplikasi. Menutup HTTP server sehingga tidak ada request yang masuk. Menunggu semua proses dalam satu siklus request-response selesai. Menutup semua koneksi database. Namun, bagaimana dengan proses yang masih berjalan di goroutine? Jika proses tersebut penting (misalnya invalidate cache), kita bisa menggunakan sync.WaitGroup untuk mendeteksi masih adanya proses yang belum selesai. Berikut adalah contoh kode yang menggunakan sync.WaitGroup:\nimport ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) // wgProcess waitgroup for gracefully shutdown background process var wgProcess sync.WaitGroup func Background(fn func()) { wgProcess.Add(1) go func() { defer wgProcess.Done() defer func() { if err := recover(); err != nil { log.Error(fmt.Sprintf(\u0026#34;panic when run background process\u0026#34;), fmt.Errorf(\u0026#34;%s\u0026#34;, err)) } }() fn() }() } Kode ini menjamin bahwa semua proses Background tercatat mulai dan selesainya melalui waitgroup. Pada main program yang menerapkan Gracefully Shutdown, kita tambahkan wgProcess.Wait() agar prosesnya blocking sampai waitgroup-nya 0 (saat semua proses selesai dijalankan). Pastikan bahwa fungsi yang menambahkan sync.WaitGroup bisa berhenti, atau tambahkan timeout.\nDengan memahami dan mengimplementasikan solusi-solusi di atas, Anda dapat mengelola proses background dengan lebih efektif di Golang. Selalu pastikan untuk menangani panic di setiap goroutine, mengelola context dengan tepat, dan melakukan shutdown aplikasi dengan baik agar semua proses dapat selesai dengan benar.\n","permalink":"https://blog.muchlis.dev/post/safe-goroutine/","summary":"\u003cp\u003eDalam pengembangan backend dengan Golang, pengelolaan proses di background menggunakan goroutine merupakan praktik umum yang dapat meningkatkan kinerja aplikasi. Namun, terdapat beberapa masalah umum yang sering dihadapi ketika mengimplementasikan goroutine, terutama dalam hal penanganan panic, pengelolaan context, dan proses shutdown yang baik. Artikel ini akan mengulas beberapa kesalahan umum yang terkait dengan penggunaan goroutine dan cara mengatasinya.\u003c/p\u003e","title":"Kesalahan Umum dalam Penggunaan Golang Goroutine"},{"content":"Profiling adalah proses mengukur kinerja aplikasi untuk mengidentifikasi dan menganalisis berbagai aspek yang mempengaruhi performa, seperti penggunaan CPU, memori, dan goroutine. Profiling sangat penting dalam proses pengembangan untuk memastikan aplikasi berjalan efisien dan optimal serta untuk mendeteksi anomali.\nTujuan Profiling pada artikel ini Mendeteksi kebocoran memori (memory leak). Mengetahui kode yang berjalan lambat. Mengoptimasi kode. Output profiling di golang contohnya seperti ini :\nPersiapan Modifikasi Kode\nUntuk dapat melakukan profiling yang dibutuhkan adalah mengimpor package net/http/pprof agar service kita dapat menjalankan dan mengekspose endpoint /debug/pprof . Namun, alih alih menggunakan server HTTP utama, lebih baik jika endpoint khusus debug tersebut diekspos secara terpisah agar tidak ada kebocoran data yang tidak semestinya.\nImplementasinya seperti contoh dibawah ini:\npackage main import ( \u0026#34;net/http\u0026#34; \u0026#34;net/http/pprof\u0026#34; ) func debugMux() *http.ServeMux { mux := http.NewServeMux() // Register all the standard library debug endpoints. mux.HandleFunc(\u0026#34;/debug/pprof/\u0026#34;, pprof.Index) mux.HandleFunc(\u0026#34;/debug/pprof/cmdline\u0026#34;, pprof.Cmdline) mux.HandleFunc(\u0026#34;/debug/pprof/profile\u0026#34;, pprof.Profile) mux.HandleFunc(\u0026#34;/debug/pprof/symbol\u0026#34;, pprof.Symbol) mux.HandleFunc(\u0026#34;/debug/pprof/trace\u0026#34;, pprof.Trace) return mux } func main() { config := cfg.Load() ctx := context.Background() debugPort := 4000 serverPort := 8080 // start debug server in other goroutine menggunakan port 4000 debugMux := debugMux() go func(mux *http.ServeMux) { if err := http.ListenAndServe(fmt.Sprintf(\u0026#34;0.0.0.0:%v\u0026#34;, debugPort), mux); err != nil { log.Error(\u0026#34;serve debug api\u0026#34;, err) } }(debugMux) // start main server in main goroutine menggunakan port 8080 webApi := web.New(app.logger, serverPort, config.App.Env, config.App.Name) err = webApi.Serve(app.routes()) if err != nil { log.Error(\u0026#34;serve web api\u0026#34;, err) } } pada contoh diatas, kita menjalankan dua server HTTP. yaitu port 4000 untuk debug/profiling dan 8080 untuk program utama.\nMengujicoba Endpoint Debug.\nketika server dijalankan, melakukan hit ke endpoint http://localhost:4000/debug/pprof/ akan menampilkan halaman web seperti berikut :\nPada halaman ini, kita dapat mengetahui keuntungan apa saja dan data apa saja yang bisa kita analisa dari endpoint ini.\nPada umumnya yang digunakan adalah\nallocs : untuk menganalisa memory berdasarkan sample heap: untuk menganalisa memory pada program yang sedang berjalan profile: untuk menganalisa penggunaan CPU. Requirement Tools.\nUntuk menganalisa, kita menggunakan pprof yang bisa dijalankan dengan perintah go tool pprof \u0026lt;file/url\u0026gt;\nTools tambahan lainnya adalah Graphviz (untuk membuat grafik)\n# ubuntu apt-get install graphviz gv # mac brew install graphviz Cara melakukan Memory Profiling Mendapatkan Sample Data Heap/Allocs. Perintah dibawah akan menghasilkan sebuah file bernama heap.out :\ncurl -s -v http://localhost:4000/debug/pprof/heap \u0026gt; heap.out Mulai Analisa File Tadi dengan pprof\ngo tool pprof heap.out Perintah yang biasa digunakan:\ntop : untuk menampilkan data teratas penggunaan memory teratas. top50 : untuk menampilkan hasil teratas sesuai jumlah angka (Top n). top -cum : untuk menampilkan data teratas dengan urutan memori kumulatif. png : untuk menampilkan visualisasi data profiling menjadi gambar dengan format png. web: untuk menampilkan visualisasi melalui browser list : untuk menganalisa nama fungsi secara lebih detail. Hint:\nflat menunjukkan jumlah memori atau waktu CPU yang dihabiskan oleh fungsi tersebut secara langsung, bukan oleh fungsi yang dipanggil olehnya. cum (cumulative) menunjukkan jumlah total memori atau waktu CPU yang dihabiskan oleh fungsi tersebut dan semua fungsi yang dipanggil olehnya (secara rekursif). Umumnya semua penggunaan memory bisa terlihat dengan perintah png atau web yang akan menampilkan grafik seperti berikut ini. Gambar dibawah ini adalah penggunaan yang cukup normal. Jika terjadi memory leak kita bisa dengan mudah melihat kotak besar yang sangat mencolok yang dari waktu kewaktu akan terus membesar :\nuntuk lebih detail, gunakan pprof menggunakan terminal :\nMenggunakan perintah top20 -cum akan menampilkan fungsi apa saja yang menggunakan memori secara kumulatif (dijumlahkan dengan fungsi-fungsi pada tumpukan di bawahnya). Kita bisa mengabaikan jumlah pemakaian yang wajar. Misalnya, go-chi sangat wajar mengendap memori sebesar 19MB karena baru saja dilakukan load test pada service ini.\nMisal, anggaplah jack/chunkreader mencurigakan. maka tahap selanjutnya kita bisa jalankan perintah list github.com/jackc/chunkreader/v2.* (perintah list menggunakan pattern regex)\nsehingga menampilkan\nDari sana kita bisa melihat fungsi mana saja yang dirasa kurang optimal jika memang angkanya tidak pas.\nCara melakukan CPU Profiling Agak berbeda dengan memory profiling, pengujian CPU harus di-trigger dan dilakukan load pada saat pengambilan data samplenya aktif.\nPerintah berikut akan mengaktifkan collect profilling CPU selama 5 detik. (meski saat pengujian tetap dikoleksi selama 30s)\ngo tool pprof http://localhost:4000/debug/pprof/profile\\?second\\=5 Disaat yang bersamaan, lakukan load test. Bisa menggunakan hey, jmeter atau tools load test lainnya.\nHasilnya akan seperti berikut\nPada data di atas, saya mengecek middleware buatan sendiri yang ternyata proses lamanya adalah di next.ServeHTTP, yang mana itu wajar karena perhitungan kumulatif (di bawah fungsi tersebut akan dijalankan program yang sebenarnya, yaitu menuju handler → service → repo).\nSample gambar jika melakukan command png:\nGarbage Collector Menganalisa performa juga bisa dilihat dari jumlah Garbage Collector (GC) Cycle yang dijalankan dan juga alokasi memori setelah dan sebelum GC. Banyaknya GC Cycle yang berjalan bisa menjadi pertanda penggunaan alokasi memori yang tidak optimal, meskipun tidak selalu. Berikut caranya:\nJalankan program dengan command berikut ini:\n# Build dulu program kita go build ./app/api # Command untuk menjalankan program namun hanya menampilkan log gc GODEBUG=gctrace=1 ./api \u0026gt; /dev/null Log yang di-print pada terminal adalah seperti ini:\ngc 1 @0.005s 3%: 0.007+1.6+0.028 ms clock, 0.063+0.12/1.2/0.25+0.22 ms cpu, 3-\u0026gt;4-\u0026gt;1 MB, 4 MB goal, 0 MB stacks, 0 MB globals, 8 P gc 2 @0.010s 3%: 0.024+0.96+0.002 ms clock, 0.19+0/1.2/0.34+0.022 ms cpu, 3-\u0026gt;3-\u0026gt;2 MB, 4 MB goal, 0 MB stacks, 0 MB globals, 8 P gc 3 @0.014s 3%: 0.087+1.4+0.005 ms clock, 0.70+0/1.0/1.8+0.044 ms cpu, 5-\u0026gt;5-\u0026gt;5 MB, 5 MB goal, 0 MB stacks, 0 MB globals, 8 P gc 4 @0.061s 1%: 0.090+1.0+0.019 ms clock, 0.72+0.082/1.4/0+0.15 ms cpu, 11-\u0026gt;11-\u0026gt;10 MB, 12 MB goal, 0 MB stacks, 0 MB globals, 8 P Cara Membaca log:\ngc 4 artinya selama proses dihidupkan, GC sudah berjalan 4 kali. 11-\u0026gt;11-\u0026gt;10 menunjukkan ukuran heap sebelum GC, setelah GC, dan ukuran heap yang masih hidup setelah GC dalam MB (Megabyte). 0.090+1.0+0.019 ms clock menunjukkan waktu yang dihabiskan dalam milidetik (ms) untuk tiga fase utama GC: 0.090 ms untuk mark. 1.0 ms untuk sweep. 0.019 ms untuk waktu stop-the-world (STW). 0.72+0.082/1.4/0+0.15 ms cpu menunjukkan penggunaan CPU dalam milidetik (ms) selama fase GC. 3-\u0026gt;4-\u0026gt;1 MB menunjukkan ukuran heap sebelum GC, setelah GC, dan ukuran heap yang masih hidup setelah GC dalam MB. 4 MB goal adalah target ukuran heap. 0 MB stacks, 0 MB globals menunjukkan memori yang digunakan oleh stack dan global variables. 8 P menunjukkan jumlah prosesor (goroutine scheduler threads) yang digunakan. Analisa performa GC:\nSaat program berjalan, test menggunakan hey atau tool serupa, misalnya dengan 10.000 request dan lihat berapa jumlah GC yang dihasilkan. Catat request per second untuk perbandingan Jalankan profiling seperti sebelumnya. go tool pprof http://localhost:4000/debug/pprof/alloc # cari yang paling banyak menggunakan memory top 40 -cum list \u0026lt;name_func\u0026gt; Heap analysis:\nLihat heap apakah tetap kecil atau membesar, jika membesar maka kemungkinan ada memory leak. Setelah melakukan perubahan (jika ada) ujicoba lagi dari step 1 dan bandingkan jumlah GC Cycle-nya. Perbandingan Performa:\nPastikan penggunaan memori sudah efisien dengan melihat jumlah GC cycle yang terjadi, alokasi heap sebelum dan sesudah GC cycle, serta waktu GC dan waktu stop-the-world (STW). Goalnya adalah peningkatan performa yang bisa dibuktikan dengan perbandingan terhadap kode sebelumnya. Caranya bisa dengan membandingkan request per second. Bagaimana Kita Tahu Kode yang Kita Ubah Menjadi Lebih Baik? Melakukan profiling seperti diatas dan membandingkan hasilnya.\nMenggunakan tools seperti hey untuk load test dan membandingkan outputnya, misalnya request per second. Catat hasil sebelum diubah dan sesudah diubah.\nMelihat peforma Garbage Collector ketika dilakukan load test.\nArtikel ini menguraikan langkah-langkah penting untuk melakukan profiling di Golang, mulai dari persiapan, modifikasi kode, hingga analisis hasil profiling untuk mengoptimalkan performa aplikasi.\n","permalink":"https://blog.muchlis.dev/post/profiling/","summary":"\u003cp\u003eProfiling adalah proses mengukur kinerja aplikasi untuk mengidentifikasi dan menganalisis berbagai aspek yang mempengaruhi performa, seperti penggunaan CPU, memori, dan goroutine. Profiling sangat penting dalam proses pengembangan untuk memastikan aplikasi berjalan efisien dan optimal serta untuk mendeteksi anomali.\u003c/p\u003e","title":"Teknik Profiling di Golang"}]