[{"content":"Profiling adalah proses mengukur kinerja aplikasi untuk mengidentifikasi dan menganalisis berbagai aspek yang mempengaruhi performa, seperti penggunaan CPU, memori, dan goroutine. Profiling sangat penting dalam proses pengembangan untuk memastikan aplikasi berjalan efisien dan optimal serta untuk mendeteksi anomali.\nTujuan Profiling pada artikel ini Mendeteksi memory leak. Mengetahui code mana yang berjalan lambat. Optimasi code. Output profiling di golang contohnya seperti ini :\nPersiapan Modifikasi code.\nUntuk dapat melakukan profiling yang dibutuhkan adalah import package net/http/pprof agar service kita dapat menjalankan dan mengekspose endpoint /debug/pprof . Namun, alih alih menggunakan http server utama, menurut hemat saya alangkah lebih baik jika endpoint khusus debug tersebut di expose secara terpisah agar tidak ada kebocoran data yang tidak semestinya.\nImplementasinya seperti contoh dibawah ini.\npackage main import ( \u0026#34;net/http\u0026#34; \u0026#34;net/http/pprof\u0026#34; ) func debugMux() *http.ServeMux { mux := http.NewServeMux() // Register all the standard library debug endpoints. mux.HandleFunc(\u0026#34;/debug/pprof/\u0026#34;, pprof.Index) mux.HandleFunc(\u0026#34;/debug/pprof/cmdline\u0026#34;, pprof.Cmdline) mux.HandleFunc(\u0026#34;/debug/pprof/profile\u0026#34;, pprof.Profile) mux.HandleFunc(\u0026#34;/debug/pprof/symbol\u0026#34;, pprof.Symbol) mux.HandleFunc(\u0026#34;/debug/pprof/trace\u0026#34;, pprof.Trace) return mux } func main() { config := cfg.Load() ctx := context.Background() debugPort := 4000 serverPort := 8080 // start debug server in other goroutine menggunakan port 4000 debugMux := debugMux() go func(mux *http.ServeMux) { if err := http.ListenAndServe(fmt.Sprintf(\u0026#34;0.0.0.0:%v\u0026#34;, debugPort), mux); err != nil { log.Error(\u0026#34;serve debug api\u0026#34;, err) } }(debugMux) // start main server in main goroutine menggunakan port 8080 webApi := web.New(app.logger, serverPort, config.App.Env, config.App.Name) err = webApi.Serve(app.routes()) if err != nil { log.Error(\u0026#34;serve web api\u0026#34;, err) } } pada contoh diatas, kita menjalankan 2 server http. yaitu port 4000 untuk debug/profiling dan 8080 untuk main program.\nMenguji endpoint debug.\nketika server dijalankan melakukan hit ke endpoint http://localhost:4000/debug/pprof/ akan menampilkan halaman web seperti berikut :\nkalau kita baca Profile description, disitu kita bisa tau keuntungan apa saja, dan data apa saja yang bisa kita analisa dari endpoint ini.\npada umumnya yang digunakan adalah\nallocs : untuk menganalisa memory berdasarkan sample heap: untuk menganalisa memory pada program yang sedang berjalan profile: untuk menganalisa processor. Requirement tools.\nUntuk menganalisa kita menggunakan pprof yang bisa dijalankan dengan perintah go tool pprof \u0026lt;file/url\u0026gt;\nProgram tambahan lainnya adalah graphviz (untuk membuat grafis)\n# ubuntu apt-get install graphviz gv # mac brew install graphviz Cara melakukan Memory Profiling Mendapatkan sample data heap / allocs. command dibawah akan menghasilkan sebuah file bernama heap.out\ncurl -s -v http://localhost:4000/debug/pprof/heap \u0026gt; heap.out Mulai analisa file tadi dengan pprof\ngo tool pprof heap.out command yang biasa digunakan :\ntop : untuk menampilkan data penggunaan memory teratas top50 : untuk menampilkan top sesuai jumlah angka (Top n) top -cum : untuk menampilkan top dengan urutan memory cumulative png : untuk mencetak graphic profiling web: untuk menampilkan graphic di browser list : untuk analisa fungsi lebih dalam hint:\nflat means that the memory allocated by this function and is held by that function cum(cumulative) means that the memory was allocated by this function or function that it called down the stack Umumnya semua penggunaan memory bisa terlihat dengan command png atau web yang akan menampilkan graphic seperti berikut ini. Gambar dibawah ini adalah penggunaan yang cukup normal. jika terjadi memory leak kita bisa dengan mudah melihat kotak besar yang sangat mencolok yang dari waktu kewaktu akan terus membesar :\nuntuk lebih detail pprof juga bisa di jalankan hanya menggunakan terminal :\nMenggunakan command top20 -cum akan menampilkan fungsi apa saja yang meminjam memory secara kumulatif (dijumlahkan dengan fungsi fungsi pada tumpukan dibawahnya). Kita bisa mengabaikan jumlah pemakaian yang wajar, misalnya go-chi sangat wajar mengendap memory sebesar 19MB karena barusan dilakukan load test pada service ini.\nmisal, anggaplah jack/chunkreader mencurigakan. maka tahap selanjutnya kita bisa jalankan perintah list github.com/jackc/chunkreader/v2.* (perintah list menggunakan pattern regex)\nsehingga menampilkan\ndari sana kita bisa melihat fungsi mana saja yang dirasa kurang optimal jika memang angkanya tidak pas.\nCara melakukan CPU Profiling Agak berbeda dengan memory profiling, pengujian cpu harus di trigger dan dilakukan load pada saat pengambilan data samplenya aktif.\nPerintah berikut akan mengaktifkan collect profilling cpu selama 5 detik. (meski saat pengujian tetap dikoleksi selama 30s)\ngo tool pprof http://localhost:4000/debug/pprof/profile\\?second\\=5 Disaat yang bersamaan, lakukan load test. Bisa menggunakan hey atau jmeter atau cuma test manual saja.\nHasilnya akan seperti berikut\nPada data diatas saya mengecek middleware buatan sendiri yang ternyata proses lamanya adalah di next.ServeHTTP, yang mana itu wajar karena perhitungan kumulatif (dibawah fungsi tersebut akan dijalankan program yang sebenarnya, yaitu menuju handler → service → repo).\nSample gambar jika melakukan command png:\nGarbage Collector Menganalisa peforma juga bisa kita lihat dari jumlah Garbage Collector Cycle yang dijalankan dan juga alokasi memory setelah dan sebelum GC. Pasalnya banyak GC Cycle yang jalan artinya bisa jadi pertanda penggunaan alokasi memory yang tidak optimal, meskipun tidak selalu. Caranya :\nJalankan program dengan command berikut ini :\n# Build dulu program kita go build ./app/api # Command untuk menjalankan program namun hanya menampilkan log gc GODEBUG=gctrace=1 ./api \u0026gt; /dev/null Log yang di print pada terminal adalah seperti ini:\ngc 1 @0.005s 3%: 0.007+1.6+0.028 ms clock, 0.063+0.12/1.2/0.25+0.22 ms cpu, 3-\u0026gt;4-\u0026gt;1 MB, 4 MB goal, 0 MB stacks, 0 MB globals, 8 P gc 2 @0.010s 3%: 0.024+0.96+0.002 ms clock, 0.19+0/1.2/0.34+0.022 ms cpu, 3-\u0026gt;3-\u0026gt;2 MB, 4 MB goal, 0 MB stacks, 0 MB globals, 8 P gc 3 @0.014s 3%: 0.087+1.4+0.005 ms clock, 0.70+0/1.0/1.8+0.044 ms cpu, 5-\u0026gt;5-\u0026gt;5 MB, 5 MB goal, 0 MB stacks, 0 MB globals, 8 P gc 4 @0.061s 1%: 0.090+1.0+0.019 ms clock, 0.72+0.082/1.4/0+0.15 ms cpu, 11-\u0026gt;11-\u0026gt;10 MB, 12 MB goal, 0 MB stacks, 0 MB globals, 8 P Cara baca :\ngc 4 artinya selama proses dihidupkan GC sudah berjalan 4 kali. 11-\u0026gt;11-\u0026gt;10 (11 size sebelum GC, 11 size sesudah GC, 10 size live heap) 0.090+1.0+0.019 (+1.0 gc time , +0.019 stop the world time. lebih sedikit lebih baik) Saat program berjalan, test menggunakan hey, misalnya dengan 10.000 request dan lihat berapa jumlah GC yang dihasilkan.\nCatat request per second untuk perbandingan\nJalankan profiling seperti sebelumnya.\ngo tool pprof http://localhost:4000/debug/pprof/alloc # cari yang paling banyak menggunakan memory top 40 -cum list \u0026lt;name_func\u0026gt; Lihat heap apakah tetap kecil atau membesar, jika membesar maka artinya ada memory leak.\nSetelah melakukan perubahan (jika ada) ujicoba lagi dari step 1 dan bandingkan jumlah GC Cycle nya.\nHasil tersebut membantu kita untuk memastikan memory yang digunakan sudah efesien atau belum dengan melihat jumlah GC cycle yang terjadi, dibarengi dengan alokasi heap sebelum dan sesudah GC cycle. GC time dan Stop the world time juga akan menambah lamanya program yang dijalankan.\nGoalnya adalah peningkatan peforma yang bisa dibuktikan dengan perbandingan kepada code sebelumnya. Saya pribadi dengan cara membandingkan request per second.\nBagaimana kita tau code yang kita ubah menjadi lebih baik? Melakukan profiling seperti diatas dan membandingkan hasilnya.\nMenggunakan tools seperti hey untuk load test dan membandingkan outputnya, misal request per second . catat hasil sebelum diubah dan sesudah diubah. contoh hey :\nMelihat peforma Garbage Collector ketika dilakukan load test.\n","permalink":"http://localhost:55135/post/profiling/","summary":"Profiling adalah proses mengukur kinerja aplikasi untuk mengidentifikasi dan menganalisis berbagai aspek yang mempengaruhi performa, seperti penggunaan CPU, memori, dan goroutine. Profiling sangat penting dalam proses pengembangan untuk memastikan aplikasi berjalan efisien dan optimal serta untuk mendeteksi anomali.\nTujuan Profiling pada artikel ini Mendeteksi memory leak. Mengetahui code mana yang berjalan lambat. Optimasi code. Output profiling di golang contohnya seperti ini :\nPersiapan Modifikasi code.\nUntuk dapat melakukan profiling yang dibutuhkan adalah import package net/http/pprof agar service kita dapat menjalankan dan mengekspose endpoint /debug/pprof .","title":"Golang Profiling"}]