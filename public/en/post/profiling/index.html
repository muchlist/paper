<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Profiling Techniques in Golang | Muchlis Dev</title><meta name=keywords content="Golang,Profiling,Benchmark,Optimization"><meta name=description content="How to perform Golang application performance measurement using pprof profiling."><meta name=author content="Muchlis at eFishery"><link rel=canonical href=https://blog.muchlis.dev/en/post/profiling/><meta name=google-site-verification content="G-F1ZZCKLSJF"><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.muchlis.dev/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.muchlis.dev/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.muchlis.dev/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.muchlis.dev/icon/apple-touch-icon.png><link rel=mask-icon href=https://blog.muchlis.dev/icon/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=id href=https://blog.muchlis.dev/post/profiling/><link rel=alternate hreflang=en href=https://blog.muchlis.dev/en/post/profiling/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F1ZZCKLSJF"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F1ZZCKLSJF")}</script><meta property="og:url" content="https://blog.muchlis.dev/en/post/profiling/"><meta property="og:site_name" content="Muchlis Dev"><meta property="og:title" content="Profiling Techniques in Golang"><meta property="og:description" content="How to perform Golang application performance measurement using pprof profiling."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-20T11:30:03+00:00"><meta property="article:modified_time" content="2022-10-20T11:30:03+00:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Profiling"><meta property="article:tag" content="Benchmark"><meta property="article:tag" content="Optimization"><meta name=twitter:card content="summary"><meta name=twitter:title content="Profiling Techniques in Golang"><meta name=twitter:description content="How to perform Golang application performance measurement using pprof profiling."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.muchlis.dev/en/post/"},{"@type":"ListItem","position":2,"name":"Profiling Techniques in Golang","item":"https://blog.muchlis.dev/en/post/profiling/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Profiling Techniques in Golang","name":"Profiling Techniques in Golang","description":"How to perform Golang application performance measurement using pprof profiling.","keywords":["Golang","Profiling","Benchmark","Optimization"],"articleBody":"Profiling is the process of measuring application performance to identify and analyze various aspects that affect performance, such as CPU usage, memory, and goroutines. Profiling is very important in the development process to ensure applications run efficiently and optimally and to detect anomalies.\nProfiling Goals in this article Detect memory leaks. Identify slow-running code. Optimize code. Example of profiling output in Golang:\nPreparation Code Modification\nTo be able to perform profiling, you need to import the net/http/pprof package so our service can run and expose the /debug/pprof endpoint. However, instead of using the main HTTP server, it’s better if the debug endpoint is exposed separately so there’s no unintended data leakage.\nThe implementation is like the example below:\npackage main import ( \"net/http\" \"net/http/pprof\" ) func debugMux() *http.ServeMux { mux := http.NewServeMux() // Register all the standard library debug endpoints. mux.HandleFunc(\"/debug/pprof/\", pprof.Index) mux.HandleFunc(\"/debug/pprof/cmdline\", pprof.Cmdline) mux.HandleFunc(\"/debug/pprof/profile\", pprof.Profile) mux.HandleFunc(\"/debug/pprof/symbol\", pprof.Symbol) mux.HandleFunc(\"/debug/pprof/trace\", pprof.Trace) return mux } func main() { config := cfg.Load() ctx := context.Background() debugPort := 4000 serverPort := 8080 // start debug server in other goroutine using port 4000 debugMux := debugMux() go func(mux *http.ServeMux) { if err := http.ListenAndServe(fmt.Sprintf(\"0.0.0.0:%v\", debugPort), mux); err != nil { log.Error(\"serve debug api\", err) } }(debugMux) // start main server in main goroutine using port 8080 webApi := web.New(app.logger, serverPort, config.App.Env, config.App.Name) err = webApi.Serve(app.routes()) if err != nil { log.Error(\"serve web api\", err) } } In the above example, we run two HTTP servers: port 4000 for debug/profiling and 8080 for the main program.\nTesting Debug Endpoint.\nWhen the server is running, hitting the endpoint http://localhost:4000/debug/pprof/ will display a web page like the following:\nOn this page, we can see what benefits and what data we can analyze from this endpoint.\nGenerally used are:\nallocs: to analyze memory based on samples heap: to analyze memory in running programs profile: to analyze CPU usage. Tool Requirements.\nTo analyze, we use pprof which can be run with the command go tool pprof Additional tools are Graphviz (for creating graphs)\n# ubuntu apt-get install graphviz gv # mac brew install graphviz How to Perform Memory Profiling Get Sample Heap/Allocs Data. The command below will generate a file named heap.out:\ncurl -s -v http://localhost:4000/debug/pprof/heap \u003e heap.out Start Analyzing the File with pprof\ngo tool pprof heap.out Commonly used commands:\ntop: to display top memory usage data. top50: to display top results according to number (Top n). top -cum: to display top data ordered by cumulative memory. png: to display profiling data visualization as png format image. web: to display visualization through browser list : to analyze function names in more detail. Hint:\nflat shows the amount of memory or CPU time spent by that function directly, not by functions called by it. cum (cumulative) shows the total amount of memory or CPU time spent by that function and all functions called by it (recursively). Generally all memory usage can be seen with the png or web command which will display a graph like the following. The image below shows fairly normal usage. If a memory leak occurs we can easily see large boxes that are very conspicuous and will continue to grow over time:\nFor more detail, use pprof using terminal:\nUsing the top20 -cum command will display which functions use memory cumulatively (summed with functions on the stack below). We can ignore reasonable usage amounts. For example, go-chi very reasonably accumulates 19MB of memory because load testing was just performed on this service.\nFor example, suppose jack/chunkreader is suspicious. Then the next step we can run the command list github.com/jackc/chunkreader/v2.* (list command uses regex pattern)\nso it displays:\nFrom there we can see which functions are considered less optimal if the numbers don’t match.\nHow to Perform CPU Profiling Slightly different from memory profiling, CPU testing must be triggered and loaded while the sample data collection is active.\nThe following command will activate CPU profiling collection for 5 seconds. (although during testing it’s still collected for 30s)\ngo tool pprof http://localhost:4000/debug/pprof/profile\\\\?second\\\\=5 At the same time, perform load testing. You can use hey, jmeter or other load testing tools.\nThe result will be like the following:\nIn the data above, I checked custom middleware which turns out the slow process is in next.ServeHTTP, which is reasonable because of cumulative calculation (below that function the actual program will run, namely going to handler → service → repo).\nSample image when executing png command:\nGarbage Collector Performance analysis can also be seen from the number of Garbage Collector (GC) Cycles that run and also memory allocation after and before GC. Many GC Cycles running can be a sign of non-optimal memory allocation usage, although not always. Here’s how:\nRun the program with the following command:\n# Build our program first go build ./app/api # Command to run the program but only display gc logs GODEBUG=gctrace=1 ./api \u003e /dev/null The log printed on the terminal is like this:\ngc 1 @0.005s 3%: 0.007+1.6+0.028 ms clock, 0.063+0.12/1.2/0.25+0.22 ms cpu, 3-\u003e4-\u003e1 MB, 4 MB goal, 0 MB stacks, 0 MB globals, 8 P gc 2 @0.010s 3%: 0.024+0.96+0.002 ms clock, 0.19+0/1.2/0.34+0.022 ms cpu, 3-\u003e3-\u003e2 MB, 4 MB goal, 0 MB stacks, 0 MB globals, 8 P gc 3 @0.014s 3%: 0.087+1.4+0.005 ms clock, 0.70+0/1.0/1.8+0.044 ms cpu, 5-\u003e5-\u003e5 MB, 5 MB goal, 0 MB stacks, 0 MB globals, 8 P gc 4 @0.061s 1%: 0.090+1.0+0.019 ms clock, 0.72+0.082/1.4/0+0.15 ms cpu, 11-\u003e11-\u003e10 MB, 12 MB goal, 0 MB stacks, 0 MB globals, 8 P How to Read logs:\ngc 4 means during the process lifetime, GC has run 4 times. 11-\u003e11-\u003e10 shows heap size before GC, after GC, and heap size still alive after GC in MB (Megabytes). 0.090+1.0+0.019 ms clock shows time spent in milliseconds (ms) for three main GC phases: 0.090 ms for mark. 1.0 ms for sweep. 0.019 ms for stop-the-world (STW) time. 0.72+0.082/1.4/0+0.15 ms cpu shows CPU usage in milliseconds (ms) during GC phases. 3-\u003e4-\u003e1 MB shows heap size before GC, after GC, and heap size still alive after GC in MB. 4 MB goal is the target heap size. 0 MB stacks, 0 MB globals show memory used by stacks and global variables. 8 P shows the number of processors (goroutine scheduler threads) used. GC performance analysis:\nWhen the program runs, test using hey or similar tool, for example with 10,000 requests and see how many GC are generated. Record request per second for comparison Run profiling like before. go tool pprof http://localhost:4000/debug/pprof/alloc # find which uses the most memory top 40 -cum list Heap analysis:\nSee if heap remains small or grows, if it grows then there’s likely a memory leak. After making changes (if any) test again from step 1 and compare the number of GC Cycles. Performance Comparison:\nEnsure memory usage is efficient by looking at the number of GC cycles that occur, heap allocation before and after GC cycles, as well as GC time and stop-the-world (STW) time. The goal is performance improvement that can be proven by comparison with previous code. This can be done by comparing request per second. How Do We Know Our Changed Code Becomes Better? Perform profiling like above and compare the results.\nUse tools like hey for load testing and compare the output, for example request per second. Record results before and after changes.\nLook at Garbage Collector performance when load testing is performed.\nThis article outlines important steps for profiling in Golang, from preparation, code modification, to analyzing profiling results to optimize application performance.\n","wordCount":"1247","inLanguage":"en","datePublished":"2022-10-20T11:30:03Z","dateModified":"2022-10-20T11:30:03Z","author":{"@type":"Person","name":"Muchlis at eFishery"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.muchlis.dev/en/post/profiling/"},"publisher":{"@type":"Organization","name":"Muchlis Dev","logo":{"@type":"ImageObject","url":"https://blog.muchlis.dev/icon/favicon.ico"}}}</script><link rel=stylesheet href=https://blog.muchlis.dev/css/custom-styles.min.846e2c0c38b3403ffecfec3d9c9b227dcfa79e75b178a91e1a26ae745cf5da5a.css><script src=https://blog.muchlis.dev/js/clickable-image.min.64e4ed1fd2302afde6a6750edcf663d18d6bf3b36d95ac130501827d8732c7a3.js defer></script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.muchlis.dev/en/ accesskey=h title="Home (Alt + H)"><img src=https://blog.muchlis.dev/icon/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.muchlis.dev/ title=Indonesian aria-label=Indonesian>Id</a></li></ul></div></div><ul id=menu><li><a href=https://blog.muchlis.dev/en/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.muchlis.dev/en/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.muchlis.dev/en/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://muchlis.dev title="Portfolio (2021)"><span>Portfolio (2021)</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.muchlis.dev/en/>Home</a>&nbsp;»&nbsp;<a href=https://blog.muchlis.dev/en/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Profiling Techniques in Golang</h1><div class=post-description>How to perform Golang application performance measurement using pprof profiling.</div><div class=post-meta><span title='2022-10-20 11:30:03 +0000 +0000'>October 20, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1247 words&nbsp;·&nbsp;Muchlis at eFishery&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://blog.muchlis.dev/post/profiling/>Id</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/muchlist/paper/tree/main/content/post/profiling.en.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#profiling-goals-in-this-article>Profiling Goals in this article</a></li><li><a href=#preparation>Preparation</a></li><li><a href=#how-to-perform-memory-profiling>How to Perform Memory Profiling</a></li><li><a href=#how-to-perform-cpu-profiling>How to Perform CPU Profiling</a></li><li><a href=#garbage-collector>Garbage Collector</a></li><li><a href=#how-do-we-know-our-changed-code-becomes-better>How Do We Know Our Changed Code Becomes Better?</a></li></ul></nav></div></details></div><div class=post-content><p>Profiling is the process of measuring application performance to identify and analyze various aspects that affect performance, such as CPU usage, memory, and goroutines. Profiling is very important in the development process to ensure applications run efficiently and optimally and to detect anomalies.</p><h2 id=profiling-goals-in-this-article>Profiling Goals in this article<a hidden class=anchor aria-hidden=true href=#profiling-goals-in-this-article>#</a></h2><ul><li>Detect memory leaks.</li><li>Identify slow-running code.</li><li>Optimize code.</li></ul><p>Example of profiling output in Golang:</p><figure><img src=/img/pprof/pprof-sample.png alt="profiling png" class="clickable-image lazyload" data-src=/img/pprof/pprof-sample.png loading=lazy></figure><h2 id=preparation>Preparation<a hidden class=anchor aria-hidden=true href=#preparation>#</a></h2><ol><li><p>Code Modification</p><p>To be able to perform profiling, you need to import the <code>net/http/pprof</code> package so our service can run and expose the <code>/debug/pprof</code> endpoint. However, instead of using the main HTTP server, it&rsquo;s better if the debug endpoint is exposed separately so there&rsquo;s no unintended data leakage.</p><p>The implementation is like the example below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;net/http&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;net/http/pprof&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>debugMux</span><span class=p>()</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>ServeMux</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>mux</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>NewServeMux</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Register all the standard library debug endpoints.</span>
</span></span><span class=line><span class=cl>	<span class=nx>mux</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/debug/pprof/&#34;</span><span class=p>,</span> <span class=nx>pprof</span><span class=p>.</span><span class=nx>Index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>mux</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/debug/pprof/cmdline&#34;</span><span class=p>,</span> <span class=nx>pprof</span><span class=p>.</span><span class=nx>Cmdline</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>mux</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/debug/pprof/profile&#34;</span><span class=p>,</span> <span class=nx>pprof</span><span class=p>.</span><span class=nx>Profile</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>mux</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/debug/pprof/symbol&#34;</span><span class=p>,</span> <span class=nx>pprof</span><span class=p>.</span><span class=nx>Symbol</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>mux</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/debug/pprof/trace&#34;</span><span class=p>,</span> <span class=nx>pprof</span><span class=p>.</span><span class=nx>Trace</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>mux</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>config</span> <span class=o>:=</span> <span class=nx>cfg</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>debugPort</span> <span class=o>:=</span> <span class=mi>4000</span>
</span></span><span class=line><span class=cl>	<span class=nx>serverPort</span> <span class=o>:=</span> <span class=mi>8080</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// start debug server in other goroutine using port 4000</span>
</span></span><span class=line><span class=cl>	<span class=nx>debugMux</span> <span class=o>:=</span> <span class=nf>debugMux</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>mux</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>ServeMux</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;0.0.0.0:%v&#34;</span><span class=p>,</span> <span class=nx>debugPort</span><span class=p>),</span> <span class=nx>mux</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Error</span><span class=p>(</span><span class=s>&#34;serve debug api&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}(</span><span class=nx>debugMux</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// start main server in main goroutine using port 8080</span>
</span></span><span class=line><span class=cl>	<span class=nx>webApi</span> <span class=o>:=</span> <span class=nx>web</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nx>app</span><span class=p>.</span><span class=nx>logger</span><span class=p>,</span> <span class=nx>serverPort</span><span class=p>,</span> <span class=nx>config</span><span class=p>.</span><span class=nx>App</span><span class=p>.</span><span class=nx>Env</span><span class=p>,</span> <span class=nx>config</span><span class=p>.</span><span class=nx>App</span><span class=p>.</span><span class=nx>Name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>err</span> <span class=p>=</span> <span class=nx>webApi</span><span class=p>.</span><span class=nf>Serve</span><span class=p>(</span><span class=nx>app</span><span class=p>.</span><span class=nf>routes</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Error</span><span class=p>(</span><span class=s>&#34;serve web api&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In the above example, we run two HTTP servers: port 4000 for debug/profiling and 8080 for the main program.</p></li><li><p>Testing Debug Endpoint.</p><p>When the server is running, hitting the endpoint <code>http://localhost:4000/debug/pprof/</code> will display a web page like the following:</p><figure><img src=/img/pprof/debug-pprof-endpoint.png alt="debug pprof endpoint" class="clickable-image lazyload" data-src=/img/pprof/debug-pprof-endpoint.png loading=lazy></figure><p>On this page, we can see what benefits and what data we can analyze from this endpoint.</p><p>Generally used are:</p><ul><li>allocs: to analyze memory based on samples</li><li>heap: to analyze memory in running programs</li><li>profile: to analyze CPU usage.</li></ul></li><li><p>Tool Requirements.</p><ul><li><p>To analyze, we use <code>pprof</code> which can be run with the command <code>go tool pprof &lt;file/url></code></p></li><li><p>Additional tools are Graphviz (for creating graphs)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># ubuntu</span>
</span></span><span class=line><span class=cl>apt-get install graphviz gv
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># mac</span>
</span></span><span class=line><span class=cl>brew install graphviz
</span></span></code></pre></div></li></ul></li></ol><h2 id=how-to-perform-memory-profiling>How to Perform Memory Profiling<a hidden class=anchor aria-hidden=true href=#how-to-perform-memory-profiling>#</a></h2><ol><li><p>Get Sample Heap/Allocs Data. The command below will generate a file named <code>heap.out</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>curl -s -v http://localhost:4000/debug/pprof/heap &gt; heap.out
</span></span></code></pre></div></li><li><p>Start Analyzing the File with pprof</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go tool pprof heap.out
</span></span></code></pre></div><p>Commonly used commands:</p><ul><li>top: to display top memory usage data.</li><li>top50: to display top results according to number (Top n).</li><li>top -cum: to display top data ordered by cumulative memory.</li><li>png: to display profiling data visualization as png format image.</li><li>web: to display visualization through browser</li><li>list <name func regex>: to analyze function names in more detail.</li></ul><p>Hint:</p><ul><li><code>flat</code> shows the amount of memory or CPU time spent by that function directly, not by functions called by it.</li><li><code>cum (cumulative)</code> shows the total amount of memory or CPU time spent by that function and all functions called by it (recursively).</li></ul><p>Generally all memory usage can be seen with the <code>png</code> or <code>web</code> command which will display a graph like the following. The image below shows fairly normal usage. If a memory leak occurs we can easily see large boxes that are very conspicuous and will continue to grow over time:</p><figure><img src=/img/pprof/pprof-sample.png alt="profiling png" class="clickable-image lazyload" data-src=/img/pprof/pprof-sample.png loading=lazy></figure><p>For more detail, use pprof using terminal:</p><figure><img src=/img/pprof/pprof-heap-out.png alt="heap output" class="clickable-image lazyload" data-src=/img/pprof/pprof-heap-out.png loading=lazy></figure><p>Using the <code>top20 -cum</code> command will display which functions use memory cumulatively (summed with functions on the stack below). We can ignore reasonable usage amounts. For example, <code>go-chi</code> very reasonably accumulates 19MB of memory because load testing was just performed on this service.</p><p>For example, suppose <code>jack/chunkreader</code> is suspicious. Then the next step we can run the command <code>list github.com/jackc/chunkreader/v2.*</code> (list command uses regex pattern)</p><p>so it displays:</p><figure><img src=/img/pprof/top-cum.png alt="top cumulative memory" class="clickable-image lazyload" data-src=/img/pprof/top-cum.png loading=lazy></figure><p>From there we can see which functions are considered less optimal if the numbers don&rsquo;t match.</p></li></ol><h2 id=how-to-perform-cpu-profiling>How to Perform CPU Profiling<a hidden class=anchor aria-hidden=true href=#how-to-perform-cpu-profiling>#</a></h2><ol><li><p>Slightly different from memory profiling, CPU testing must be triggered and loaded while the sample data collection is active.</p></li><li><p>The following command will activate CPU profiling collection for 5 seconds. (although during testing it&rsquo;s still collected for 30s)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go tool pprof http://localhost:4000/debug/pprof/profile<span class=se>\\</span>?second<span class=se>\\</span><span class=o>=</span><span class=m>5</span>
</span></span></code></pre></div></li><li><p>At the same time, perform load testing. You can use <code>hey</code>, <code>jmeter</code> or other load testing tools.</p></li><li><p>The result will be like the following:</p><figure><img src=/img/pprof/top10-cum.png alt="top 10 cumulative memory" class="clickable-image lazyload" data-src=/img/pprof/top10-cum.png loading=lazy></figure><p>In the data above, I checked custom middleware which turns out the slow process is in <code>next.ServeHTTP</code>, which is reasonable because of cumulative calculation (below that function the actual program will run, namely going to handler → service → repo).</p></li><li><p>Sample image when executing <code>png</code> command:</p><figure><img src=/img/pprof/output-png.png alt="output png" class="clickable-image lazyload" data-src=/img/pprof/output-png.png loading=lazy></figure><h2 id=garbage-collector>Garbage Collector<a hidden class=anchor aria-hidden=true href=#garbage-collector>#</a></h2><p>Performance analysis can also be seen from the number of Garbage Collector (GC) Cycles that run and also memory allocation after and before GC. Many GC Cycles running can be a sign of non-optimal memory allocation usage, although not always. Here&rsquo;s how:</p><ol><li><p>Run the program with the following command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Build our program first</span>
</span></span><span class=line><span class=cl>go build ./app/api
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Command to run the program but only display gc logs</span>
</span></span><span class=line><span class=cl><span class=nv>GODEBUG</span><span class=o>=</span><span class=nv>gctrace</span><span class=o>=</span><span class=m>1</span> ./api &gt; /dev/null
</span></span></code></pre></div><p>The log printed on the terminal is like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gc <span class=m>1</span> @0.005s 3%: 0.007+1.6+0.028 ms clock, 0.063+0.12/1.2/0.25+0.22 ms cpu, 3-&gt;4-&gt;1 MB, <span class=m>4</span> MB goal, <span class=m>0</span> MB stacks, <span class=m>0</span> MB globals, <span class=m>8</span> P
</span></span><span class=line><span class=cl>gc <span class=m>2</span> @0.010s 3%: 0.024+0.96+0.002 ms clock, 0.19+0/1.2/0.34+0.022 ms cpu, 3-&gt;3-&gt;2 MB, <span class=m>4</span> MB goal, <span class=m>0</span> MB stacks, <span class=m>0</span> MB globals, <span class=m>8</span> P
</span></span><span class=line><span class=cl>gc <span class=m>3</span> @0.014s 3%: 0.087+1.4+0.005 ms clock, 0.70+0/1.0/1.8+0.044 ms cpu, 5-&gt;5-&gt;5 MB, <span class=m>5</span> MB goal, <span class=m>0</span> MB stacks, <span class=m>0</span> MB globals, <span class=m>8</span> P
</span></span><span class=line><span class=cl>gc <span class=m>4</span> @0.061s 1%: 0.090+1.0+0.019 ms clock, 0.72+0.082/1.4/0+0.15 ms cpu, 11-&gt;11-&gt;10 MB, <span class=m>12</span> MB goal, <span class=m>0</span> MB stacks, <span class=m>0</span> MB globals, <span class=m>8</span> P
</span></span></code></pre></div></li><li><p>How to Read logs:</p><ul><li><code>gc 4</code> means during the process lifetime, GC has run 4 times.</li><li><code>11->11->10</code> shows heap size before GC, after GC, and heap size still alive after GC in MB (Megabytes).</li><li><code>0.090+1.0+0.019 ms clock</code> shows time spent in milliseconds (ms) for three main GC phases:<ul><li><code>0.090 ms</code> for mark.</li><li><code>1.0 ms</code> for sweep.</li><li><code>0.019 ms</code> for stop-the-world (STW) time.</li></ul></li><li>0.72+0.082/1.4/0+0.15 ms cpu shows CPU usage in milliseconds (ms) during GC phases.</li><li>3->4->1 MB shows heap size before GC, after GC, and heap size still alive after GC in MB.</li><li>4 MB goal is the target heap size.</li><li>0 MB stacks, 0 MB globals show memory used by stacks and global variables.</li><li>8 P shows the number of processors (goroutine scheduler threads) used.</li></ul></li><li><p>GC performance analysis:</p><ul><li>When the program runs, test using <code>hey</code> or similar tool, for example with 10,000 requests and see how many GC are generated.</li><li>Record request per second for comparison</li><li>Run profiling like before.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go tool pprof http://localhost:4000/debug/pprof/alloc
</span></span><span class=line><span class=cl><span class=c1># find which uses the most memory</span>
</span></span><span class=line><span class=cl>top <span class=m>40</span> -cum
</span></span><span class=line><span class=cl>list &lt;name_func&gt;
</span></span></code></pre></div></li><li><p>Heap analysis:</p><ul><li>See if heap remains small or grows, if it grows then there&rsquo;s likely a memory leak.</li><li>After making changes (if any) test again from step 1 and compare the number of GC Cycles.</li></ul></li><li><p>Performance Comparison:</p><ul><li>Ensure memory usage is efficient by looking at the number of GC cycles that occur, heap allocation before and after GC cycles, as well as GC time and stop-the-world (STW) time.</li><li>The goal is performance improvement that can be proven by comparison with previous code. This can be done by comparing request per second.</li></ul></li></ol><h2 id=how-do-we-know-our-changed-code-becomes-better>How Do We Know Our Changed Code Becomes Better?<a hidden class=anchor aria-hidden=true href=#how-do-we-know-our-changed-code-becomes-better>#</a></h2><ul><li><p>Perform profiling like above and compare the results.</p></li><li><p>Use tools like <code>hey</code> for load testing and compare the output, for example <code>request per second</code>. Record results before and after changes.</p><figure><img src=/img/pprof/hey.png alt="hey example for load test" class="clickable-image lazyload" data-src=/img/pprof/hey.png loading=lazy></figure></li><li><p>Look at Garbage Collector performance when load testing is performed.</p></li></ul><p>This article outlines important steps for profiling in Golang, from preparation, code modification, to analyzing profiling results to optimize application performance.</p></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.muchlis.dev/en/tags/golang/>Golang</a></li><li><a href=https://blog.muchlis.dev/en/tags/profiling/>Profiling</a></li><li><a href=https://blog.muchlis.dev/en/tags/benchmark/>Benchmark</a></li><li><a href=https://blog.muchlis.dev/en/tags/optimization/>Optimization</a></li></ul><nav class=paginav><a class=prev href=https://blog.muchlis.dev/en/post/safe-goroutine/><span class=title>« Prev</span><br><span>Pay Attention to These Things When Using Golang Goroutines</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Profiling Techniques in Golang on x" href="https://x.com/intent/tweet/?text=Profiling%20Techniques%20in%20Golang&amp;url=https%3a%2f%2fblog.muchlis.dev%2fen%2fpost%2fprofiling%2f&amp;hashtags=Golang%2cProfiling%2cBenchmark%2cOptimization"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Profiling Techniques in Golang on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.muchlis.dev%2fen%2fpost%2fprofiling%2f&amp;title=Profiling%20Techniques%20in%20Golang&amp;summary=Profiling%20Techniques%20in%20Golang&amp;source=https%3a%2f%2fblog.muchlis.dev%2fen%2fpost%2fprofiling%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Profiling Techniques in Golang on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.muchlis.dev%2fen%2fpost%2fprofiling%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Profiling Techniques in Golang on whatsapp" href="https://api.whatsapp.com/send?text=Profiling%20Techniques%20in%20Golang%20-%20https%3a%2f%2fblog.muchlis.dev%2fen%2fpost%2fprofiling%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Profiling Techniques in Golang on telegram" href="https://telegram.me/share/url?text=Profiling%20Techniques%20in%20Golang&amp;url=https%3a%2f%2fblog.muchlis.dev%2fen%2fpost%2fprofiling%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=muchlist/paper data-repo-id=R_kgDOMD4syA data-category=General data-category-id=DIC_kwDOMD4syM4ChOKX data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=en data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.muchlis.dev/en/>Muchlis Dev</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>