<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Database Transaction Implementation Techniques in Logic Layer for Golang Backend | Muchlis Dev</title><meta name=keywords content="Golang,Best Practices,Database"><meta name=description content="Advanced techniques for implementing database transactions in modular architecture"><meta name=author content="Muchlis"><link rel=canonical href=https://blog.muchlis.dev/en/post/db-transaction/><meta name=google-site-verification content="G-F1ZZCKLSJF"><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.muchlis.dev/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.muchlis.dev/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.muchlis.dev/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.muchlis.dev/icon/apple-touch-icon.png><link rel=mask-icon href=https://blog.muchlis.dev/icon/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=id href=https://blog.muchlis.dev/post/db-transaction/><link rel=alternate hreflang=en href=https://blog.muchlis.dev/en/post/db-transaction/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F1ZZCKLSJF"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F1ZZCKLSJF")}</script><meta property="og:url" content="https://blog.muchlis.dev/en/post/db-transaction/"><meta property="og:site_name" content="Muchlis Dev"><meta property="og:title" content="Database Transaction Implementation Techniques in Logic Layer for Golang Backend"><meta property="og:description" content="Advanced techniques for implementing database transactions in modular architecture"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-10-12T15:19:36+08:00"><meta property="article:modified_time" content="2024-10-12T15:19:36+08:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Best Practices"><meta property="article:tag" content="Database"><meta property="og:image" content="https://blog.muchlis.dev/img/db-transaction/db-trsansaction-ddd.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.muchlis.dev/img/db-transaction/db-trsansaction-ddd.webp"><meta name=twitter:title content="Database Transaction Implementation Techniques in Logic Layer for Golang Backend"><meta name=twitter:description content="Advanced techniques for implementing database transactions in modular architecture"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.muchlis.dev/en/post/"},{"@type":"ListItem","position":2,"name":"Database Transaction Implementation Techniques in Logic Layer for Golang Backend","item":"https://blog.muchlis.dev/en/post/db-transaction/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Database Transaction Implementation Techniques in Logic Layer for Golang Backend","name":"Database Transaction Implementation Techniques in Logic Layer for Golang Backend","description":"Advanced techniques for implementing database transactions in modular architecture","keywords":["Golang","Best Practices","Database"],"articleBody":"Database transactions are a crucial aspect in application development, especially in projects that demand high data consistency. This article will discuss how to perform database transactions in the service layer (logic), while maintaining clean architecture principles and separation of concerns.\nArchitecture Towards Database Transactions In popular architectures like Clean Architecture, Hexagonal Architecture, or Domain-Driven Design (DDD) approaches, separation of responsibilities is key. We generally divide code into several layers, for example Handler -\u003e Service -\u003e Repository. The service layer ideally contains pure business logic without depending on external libraries, while the repository is responsible for database interactions.\nHowever, when implementing database operations that comply with ACID (Atomicity, Consistency, Isolation, Durability) principles, a question arises: where should database transaction logic be placed? In the logic layer or in the repository layer? This often becomes a dilemma for programmers, especially due to challenges arising from architectural principles that push for breaking datastore access through various small and modularized repositories.\nnote: Atomicity means ensuring that a series of operations in one transaction must either completely succeed or completely fail.\nAs an illustration, let’s consider the case of money transfer between accounts: “Transfer money from account A to account B, update all related data, and if it fails, cancel the entire process.” There are two common approaches:\nApproach A: Transaction Logic in Repository This approach is simple because transactions are started and managed directly in the repository layer. However, this approach has weaknesses: business logic (money transfer) is mixed with data access logic. Imagine if there are additional needs, such as sending balance events to third parties as part of transaction atomicity. Should the repository have dependencies on external services too? This clearly violates separation of concerns principles. Additionally, the service layer becomes very thin, thus eliminating the benefits of unit testing at that layer.\nApproach B: Transaction Logic in Service This approach places transaction logic in the service layer, in accordance with separation of concerns principles. However, its implementation is more challenging. How can the service layer remain independent from database libraries, like GORM, while still being able to manage transactions?\nSo, where should transaction logic be placed? In the logic layer or in the repository layer? The answer is in the logic layer. This applies both when mutation processes involve interaction with multiple data sources, and when performing data collection (aggregation). The reason is that business logic determines the valid state of a set of data at a certain time. In other words, if an aggregate is not stored in a complete and valid state, then the business operations performed will be considered inconsistent with applicable business rules. This is also in line with what I’ve read in DDD books. Domain Driven Design\nChallenges and Solutions Keeping the service layer pure from third-party dependencies while managing complex database transactions is indeed difficult. However, several techniques can be applied to overcome this problem, such as using transaction abstractions in the service without having to deal directly with transaction implementation from database libraries.\nTo maintain service layer purity and still manage database transactions effectively, we will use a layered approach with several key components:\n1. DBTX interface Defines an interface that abstracts database operations, both regular operations and operations within transactions. This allows the service layer to interact with the database without depending on specific implementations. This interface will include methods like Exec, Query, QueryRow, Begin, Commit, Rollback, and others that are needed. The good news is, if you use gorm, this doesn’t need to be done because gorm has already done it (combining both methods into 1). Here I create an example using pgx.\npackage dbtx import ( \"github.com/jackc/pgx/v5\" \"github.com/jackc/pgx/v5/pgconn\" \"github.com/jackc/pgx/v5/pgxpool\" ) type DBTX interface { // method used by pgx for regular operations Prepare(ctx context.Context, name, sql string) (*pgconn.StatementDescription, error) Exec(ctx context.Context, sql string, arguments ...interface{}) (commandTag pgconn.CommandTag, err error) Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error) QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row // method used by pgx for transaction operations Begin(ctx context.Context) (pgx.Tx, error) Commit(ctx context.Context) error Rollback(ctx context.Context) error // DBTX combines both... } 2. PGStore Provides concrete implementation of the DBTX interface for pgx library. This structure will handle selection between regular database connections or transaction connections. PGStore will check whether the context contains an active transaction (pgx.Tx). If there is, database operations will be performed using that transaction. If not, operations will be performed using the connection pool pgxpool.\nNewPGStore functions to create PGStore instances. This function accepts pgxpool pool connections and (optionally) pgx.Tx transaction objects. This will facilitate creating PGStore instances in a consistent and controlled manner.\ntype PGStore struct { NonTX *pgxpool.Pool Tx pgx.Tx } // NewPGStore return interface can execute TX and pgx.Pool func NewPGStore(pool *pgxpool.Pool, tx pgx.Tx) DBTX { var pgstore PGStore if tx != nil { pgstore.Tx = tx return \u0026pgstore } pgstore.NonTX = pool return \u0026pgstore } // Begin implements DBTX func (p *PGStore) Begin(ctx context.Context) (pgx.Tx, error) { if p.Tx != nil { return nil, errors.New(\"cannot begin inside running transaction\") } return p.NonTX.Begin(ctx) } // Commit implements DBTX func (p *PGStore) Commit(ctx context.Context) error { if p.Tx != nil { return p.Tx.Commit(ctx) } return errors.New(\"cannot commit: nil tx value\") } // Rollback implements DBTX func (p *PGStore) Rollback(ctx context.Context) error { if p.Tx != nil { return p.Tx.Rollback(ctx) } return errors.New(\"cannot roleback: nil tx value\") } // Exec implements DBTX func (p *PGStore) Exec(ctx context.Context, sql string, arguments ...interface{}) (commandTag pgconn.CommandTag, err error) { if p.Tx != nil { return p.Tx.Exec(ctx, sql, arguments...) } return p.NonTX.Exec(ctx, sql, arguments...) } // Prepare implements DBTX func (p *PGStore) Prepare(ctx context.Context, name string, sql string) (*pgconn.StatementDescription, error) { if p.Tx != nil { return p.Tx.Prepare(ctx, name, sql) } return nil, errors.New(\"cannot prefare: pool does not have prefare method\") } // Query implements DBTX func (p *PGStore) Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error) { if p.Tx != nil { return p.Tx.Query(ctx, sql, args...) } return p.NonTX.Query(ctx, sql, args...) } // QueryRow implements DBTX func (p *PGStore) QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row { if p.Tx != nil { return p.Tx.QueryRow(ctx, sql, args...) } return p.NonTX.QueryRow(ctx, sql, args...) } 3. ExtractTx and injectTx Functions Next we create helpers that automate the use of NewPGStore. ExtractTx is used to extract database transaction connections stored in context injectTx is used for the opposite, which is injecting database transactions into context.\npackage dbtx import ( \"github.com/jackc/pgx/v5\" \"github.com/jackc/pgx/v5/pgxpool\" ) type KeyTransaction string const TXKey KeyTransaction = \"unique-key-transaction\" // ExtractTx extract transaction from context and transform database into dbtx.DBTX func ExtractTx(ctx context.Context, defaultPool *pgxpool.Pool) DBTX { tx, ok := ctx.Value(TXKey).(pgx.Tx) if !ok || tx == nil { return NewPGStore(defaultPool, nil) } return NewPGStore(nil, tx) } // injectTx injects transaction to context func injectTx(ctx context.Context, tx pgx.Tx) context.Context { return context.WithValue(ctx, TXKey, tx) } 4. TxManager and WithAtomic Function WithAtomic automates the use of ExtractTx and injectTx. It’s a wrapper function that will perform ROLLBACK if it fails, and will perform COMMIT database transaction if it succeeds.\nIn short, when WithAtomic is called, the context will be filled with database transaction, then the context containing database transaction will be used to run subsequent database operations, the repository will automatically use this transaction because it performs ExtractTx every time a database command is executed.\nAt the logic layer we only deal with WithAtomic.\npackage dbtx import ( \"log/slog\" \"github.com/jackc/pgx/v5/pgxpool\" ) type TxManager interface { WithAtomic(ctx context.Context, tFunc func(ctx context.Context) error) error } type txManager struct { db *pgxpool.Pool log *slog.Logger } func NewTxManager(sqlDB *pgxpool.Pool, log *slog.Logger) TxManager { return \u0026txManager{ db: sqlDB, log: log, } } // ========================================================================= // TRANSACTION // WithAtomic runs function within transaction // The transaction commits when function were finished without error func (r *txManager) WithAtomic(ctx context.Context, tFunc func(ctx context.Context) error) error { // begin transaction tx, err := r.db.Begin(ctx) if err != nil { return fmt.Errorf(\"begin transaction: %w\", err) } // run callback err = tFunc(injectTx(ctx, tx)) if err != nil { // if error, rollback if errRollback := tx.Rollback(ctx); errRollback != nil { r.log.Error(\"rollback transaction\", slog.String(\"error\", errRollback.Error())) } return err } // if no error, commit if errCommit := tx.Commit(ctx); errCommit != nil { return fmt.Errorf(\"failed to commit transaction: %w\", errCommit) } return nil } 5. WithAtomic and ExtractTx Implementation Service Layer: Service layer uses TxManager.WithAtomic to wrap business logic in transactions. This ensures that all database operations in that business logic are performed atomically.\nRepository Layer: Repository layer uses ExtractTx to get the appropriate DBTX object (transaction-based or regular connection) from context. All database operations in the repository are performed through this DBTX object.\nSo the code will be something like the following.\ntype service struct { Repo AccountStorer TxManager TxManager // helper for transactions becomes additional dependency or can be combined with repo } func (s *service) TransferMoney(ctx context.Context, input model.TransferDTO) error { // shared variable to hold results inside WithAtomic if any // result := ... // Wrapping the process with database transaction txErr := s.TxManager.WithAtomic(ctx, func(ctx context.Context) error { // Getting account A accountA, err := s.Repo.GetAccountByID(ctx, input.AccountA) if err != nil { return err // Failed to get account A } // Getting account B accountB, err := s.Repo.GetAccountByID(ctx, input.AccountB) if err != nil { return err // Failed to get account B } // Checking if account A balance is sufficient if accountA.Balance \u003c input.Amount { return errors.New(\"insufficient balance\") // Failed due to insufficient balance } // Reducing account A balance accountA.Balance -= input.Amount if err := s.Repo.UpdateAccount(ctx, accountA); err != nil { return err // Failed to update account A balance } // Adding amount to account B balance accountB.Balance += input.Amount if err := s.Repo.UpdateAccount(ctx, accountB); err != nil { return err // Failed to update account B balance } return nil }) if txErr != nil { return txErr } return nil } // Getting account by ID func (r *repo) GetAccountByID(ctx context.Context, id uint) (model.AccountEntity, error) { dbtx := ExtractTx(ctx, r.db) // extracting context and making regular db into DBTX interface var account model.AccountModel err := dbtx.QueryRow(ctx, \"SELECT * FROM accounts WHERE id = $1\", id).Scan( /* ...scan fields of account... */ ) return account, err } // Updating account func (r *repo) UpdateAccount(ctx context.Context, account model.AccountEntity) error { dbtx := ExtractTx(ctx, r.db) // extracting context and making regular db into DBTX interface _, err := dbtx.Exec(ctx, ` UPDATE accounts SET balance = $1 WHERE id = $2`, account.Balance, account.ID) return err } By implementing the above method, we successfully separate the logic layer from dependencies on third-party libraries. In the repository example I included, it can be seen that even to change ORMs, the service layer doesn’t need any changes. YEYY.\nLet’s elaborate again, what are the advantages:\nLogic layer remains pure, not contaminated by gorm packages or other drivers. Database transactions can be controlled effectively, allowing to manage transaction scope to be kept as small as possible if needed. This approach is different from implementing transactions in middleware, which can cause the entire logic process to be within one database transaction. Code readability is maintained. Unit testing remains focused on business logic only. Sample Github Repository I include sample code in two versions, one for GORM and another for other implementations (pgx). Here, GORM is simpler because basically GORM has combined regular database operations with database transaction operations.\nHere’s the repository: REPOSITORY\nWhen implementing database transactions, it’s also important to consider the possibility of deadlocks. In the sample code I provided above, I have simplified the code by setting aside those aspects. I will discuss deadlocks further in future opportunities.\n","wordCount":"1920","inLanguage":"en","image":"https://blog.muchlis.dev/img/db-transaction/db-trsansaction-ddd.webp","datePublished":"2024-10-12T15:19:36+08:00","dateModified":"2024-10-12T15:19:36+08:00","author":{"@type":"Person","name":"Muchlis"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.muchlis.dev/en/post/db-transaction/"},"publisher":{"@type":"Organization","name":"Muchlis Dev","logo":{"@type":"ImageObject","url":"https://blog.muchlis.dev/icon/favicon.ico"}}}</script><link rel=stylesheet href=https://blog.muchlis.dev/css/custom-styles.min.846e2c0c38b3403ffecfec3d9c9b227dcfa79e75b178a91e1a26ae745cf5da5a.css><script src=https://blog.muchlis.dev/js/clickable-image.min.64e4ed1fd2302afde6a6750edcf663d18d6bf3b36d95ac130501827d8732c7a3.js defer></script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.muchlis.dev/en/ accesskey=h title="Home (Alt + H)"><img src=https://blog.muchlis.dev/icon/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.muchlis.dev/ title=Indonesian aria-label=Indonesian>Id</a></li></ul></div></div><ul id=menu><li><a href=https://blog.muchlis.dev/en/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.muchlis.dev/en/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.muchlis.dev/en/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://muchlis.dev title="Portfolio (2021)"><span>Portfolio (2021)</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.muchlis.dev/en/>Home</a>&nbsp;»&nbsp;<a href=https://blog.muchlis.dev/en/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Database Transaction Implementation Techniques in Logic Layer for Golang Backend</h1><div class=post-description>Advanced techniques for implementing database transactions in modular architecture</div><div class=post-meta><span title='2024-10-12 15:19:36 +0800 WITA'>October 12, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;1920 words&nbsp;·&nbsp;Muchlis&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://blog.muchlis.dev/post/db-transaction/>Id</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/muchlist/paper/tree/main/content/post/db-transaction.en.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#architecture-towards-database-transactions>Architecture Towards Database Transactions</a><ul><li><a href=#approach-a-transaction-logic-in-repository>Approach A: Transaction Logic in Repository</a></li><li><a href=#approach-b-transaction-logic-in-service>Approach B: Transaction Logic in Service</a></li></ul></li><li><a href=#so-where-should-transaction-logic-be-placed-in-the-logic-layer-or-in-the-repository-layer>So, where should transaction logic be placed? In the logic layer or in the repository layer?</a></li><li><a href=#challenges-and-solutions>Challenges and Solutions</a><ul><li><a href=#1-dbtx-interface>1. DBTX interface</a></li><li><a href=#2-pgstore>2. PGStore</a></li><li><a href=#3-extracttx-and-injecttx-functions>3. ExtractTx and injectTx Functions</a></li><li><a href=#4-txmanager-and-withatomic-function>4. TxManager and WithAtomic Function</a></li><li><a href=#5-withatomic-and-extracttx-implementation>5. WithAtomic and ExtractTx Implementation</a></li></ul></li><li><a href=#sample-github-repository>Sample Github Repository</a></li></ul></nav></div></details></div><div class=post-content><p>Database transactions are a crucial aspect in application development, especially in projects that demand high data consistency. This article will discuss how to perform database transactions in the service layer (logic), while maintaining clean architecture principles and separation of concerns.</p><h2 id=architecture-towards-database-transactions>Architecture Towards Database Transactions<a hidden class=anchor aria-hidden=true href=#architecture-towards-database-transactions>#</a></h2><p>In popular architectures like Clean Architecture, Hexagonal Architecture, or Domain-Driven Design (DDD) approaches, separation of responsibilities is key. We generally divide code into several layers, for example Handler -> Service -> Repository. The service layer ideally contains pure business logic without depending on external libraries, while the repository is responsible for database interactions.</p><p>However, when implementing database operations that comply with ACID (Atomicity, Consistency, Isolation, Durability) principles, a question arises: <strong><code>where should database transaction logic be placed?</code></strong> In the logic layer or in the repository layer? This often becomes a dilemma for programmers, especially due to challenges arising from architectural principles that push for breaking datastore access through various small and modularized repositories.</p><blockquote><p>note: Atomicity means ensuring that a series of operations in one transaction must either completely succeed or completely fail.</p></blockquote><p>As an illustration, let&rsquo;s consider the case of money transfer between accounts: &ldquo;Transfer money from account A to account B, update all related data, and if it fails, cancel the entire process.&rdquo; There are two common approaches:</p><h3 id=approach-a-transaction-logic-in-repository>Approach A: Transaction Logic in Repository<a hidden class=anchor aria-hidden=true href=#approach-a-transaction-logic-in-repository>#</a></h3><figure><img src=/img/db-transaction/transaction-logic-in-repo.webp alt="database transaction logic in repo" class="clickable-image lazyload" data-src=/img/db-transaction/transaction-logic-in-repo.webp loading=lazy></figure><p>This approach is simple because transactions are started and managed directly in the repository layer. However, this approach has weaknesses: business logic (money transfer) is mixed with data access logic. Imagine if there are additional needs, such as sending balance events to third parties as part of transaction atomicity. Should the repository have dependencies on external services too? This clearly violates separation of concerns principles. Additionally, the service layer becomes very thin, thus eliminating the benefits of unit testing at that layer.</p><h3 id=approach-b-transaction-logic-in-service>Approach B: Transaction Logic in Service<a hidden class=anchor aria-hidden=true href=#approach-b-transaction-logic-in-service>#</a></h3><figure><img src=/img/db-transaction/transaction-logic-in-service.webp alt="database transaction logic in service" class="clickable-image lazyload" data-src=/img/db-transaction/transaction-logic-in-service.webp loading=lazy></figure><p>This approach places transaction logic in the service layer, in accordance with separation of concerns principles. However, its implementation is more challenging. How can the service layer remain independent from database libraries, like GORM, while still being able to manage transactions?</p><h2 id=so-where-should-transaction-logic-be-placed-in-the-logic-layer-or-in-the-repository-layer>So, where should transaction logic be placed? In the logic layer or in the repository layer?<a hidden class=anchor aria-hidden=true href=#so-where-should-transaction-logic-be-placed-in-the-logic-layer-or-in-the-repository-layer>#</a></h2><p>The answer is in the logic layer. This applies both when mutation processes involve interaction with multiple data sources, and when performing data collection (aggregation). The reason is that business logic determines the valid state of a set of data at a certain time. In other words, if an aggregate is not stored in a complete and valid state, then the business operations performed will be considered inconsistent with applicable business rules.
This is also in line with what I&rsquo;ve read in DDD books. <a href=https://www.oreilly.com/library/view/domain-driven-design-tackling/0321125215/>Domain Driven Design</a></p><figure><img src=/img/db-transaction/db-trsansaction-ddd.webp alt="database transaction position on ddd" class="clickable-image lazyload" data-src=/img/db-transaction/db-trsansaction-ddd.webp loading=lazy></figure><h2 id=challenges-and-solutions>Challenges and Solutions<a hidden class=anchor aria-hidden=true href=#challenges-and-solutions>#</a></h2><p>Keeping the service layer pure from third-party dependencies while managing complex database transactions is indeed difficult. However, several techniques can be applied to overcome this problem, such as using transaction abstractions in the service without having to deal directly with transaction implementation from database libraries.</p><p>To maintain service layer purity and still manage database transactions effectively, we will use a layered approach with several key components:</p><h3 id=1-dbtx-interface>1. DBTX interface<a hidden class=anchor aria-hidden=true href=#1-dbtx-interface>#</a></h3><p>Defines an interface that abstracts database operations, both regular operations and operations within transactions. This allows the service layer to interact with the database without depending on specific implementations. This interface will include methods like Exec, Query, QueryRow, Begin, Commit, Rollback, and others that are needed. The good news is, if you use gorm, this doesn&rsquo;t need to be done because gorm has already done it (combining both methods into 1). Here I create an example using pgx.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>dbtx</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/jackc/pgx/v5&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/jackc/pgx/v5/pgconn&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/jackc/pgx/v5/pgxpool&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>DBTX</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// method used by pgx for regular operations</span>
</span></span><span class=line><span class=cl>	<span class=nf>Prepare</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>name</span><span class=p>,</span> <span class=nx>sql</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>pgconn</span><span class=p>.</span><span class=nx>StatementDescription</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>Exec</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>sql</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>arguments</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>commandTag</span> <span class=nx>pgconn</span><span class=p>.</span><span class=nx>CommandTag</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>Query</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>sql</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>args</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>pgx</span><span class=p>.</span><span class=nx>Rows</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>QueryRow</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>sql</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>args</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=nx>pgx</span><span class=p>.</span><span class=nx>Row</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// method used by pgx for transaction operations</span>
</span></span><span class=line><span class=cl>	<span class=nf>Begin</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>pgx</span><span class=p>.</span><span class=nx>Tx</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>Commit</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>	<span class=nf>Rollback</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// DBTX combines both...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=2-pgstore>2. PGStore<a hidden class=anchor aria-hidden=true href=#2-pgstore>#</a></h3><p>Provides concrete implementation of the DBTX interface for pgx library. This structure will handle selection between regular database connections or transaction connections. PGStore will check whether the context contains an active transaction (pgx.Tx). If there is, database operations will be performed using that transaction. If not, operations will be performed using the connection pool pgxpool.</p><p>NewPGStore functions to create PGStore instances. This function accepts pgxpool pool connections and (optionally) pgx.Tx transaction objects. This will facilitate creating PGStore instances in a consistent and controlled manner.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>PGStore</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>NonTX</span> <span class=o>*</span><span class=nx>pgxpool</span><span class=p>.</span><span class=nx>Pool</span>
</span></span><span class=line><span class=cl>	<span class=nx>Tx</span>    <span class=nx>pgx</span><span class=p>.</span><span class=nx>Tx</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// NewPGStore return interface can execute TX and pgx.Pool</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewPGStore</span><span class=p>(</span><span class=nx>pool</span> <span class=o>*</span><span class=nx>pgxpool</span><span class=p>.</span><span class=nx>Pool</span><span class=p>,</span> <span class=nx>tx</span> <span class=nx>pgx</span><span class=p>.</span><span class=nx>Tx</span><span class=p>)</span> <span class=nx>DBTX</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>pgstore</span> <span class=nx>PGStore</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>tx</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>pgstore</span><span class=p>.</span><span class=nx>Tx</span> <span class=p>=</span> <span class=nx>tx</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>&amp;</span><span class=nx>pgstore</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>pgstore</span><span class=p>.</span><span class=nx>NonTX</span> <span class=p>=</span> <span class=nx>pool</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>pgstore</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Begin implements DBTX</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>PGStore</span><span class=p>)</span> <span class=nf>Begin</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>pgx</span><span class=p>.</span><span class=nx>Tx</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;cannot begin inside running transaction&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>NonTX</span><span class=p>.</span><span class=nf>Begin</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Commit implements DBTX</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>PGStore</span><span class=p>)</span> <span class=nf>Commit</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span><span class=p>.</span><span class=nf>Commit</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;cannot commit: nil tx value&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Rollback implements DBTX</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>PGStore</span><span class=p>)</span> <span class=nf>Rollback</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span><span class=p>.</span><span class=nf>Rollback</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;cannot roleback: nil tx value&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Exec implements DBTX</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>PGStore</span><span class=p>)</span> <span class=nf>Exec</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>sql</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>arguments</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>commandTag</span> <span class=nx>pgconn</span><span class=p>.</span><span class=nx>CommandTag</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span><span class=p>.</span><span class=nf>Exec</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>sql</span><span class=p>,</span> <span class=nx>arguments</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>NonTX</span><span class=p>.</span><span class=nf>Exec</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>sql</span><span class=p>,</span> <span class=nx>arguments</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Prepare implements DBTX</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>PGStore</span><span class=p>)</span> <span class=nf>Prepare</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>name</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>sql</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>pgconn</span><span class=p>.</span><span class=nx>StatementDescription</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span><span class=p>.</span><span class=nf>Prepare</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>name</span><span class=p>,</span> <span class=nx>sql</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;cannot prefare: pool does not have prefare method&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Query implements DBTX</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>PGStore</span><span class=p>)</span> <span class=nf>Query</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>sql</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>args</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>pgx</span><span class=p>.</span><span class=nx>Rows</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span><span class=p>.</span><span class=nf>Query</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>sql</span><span class=p>,</span> <span class=nx>args</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>NonTX</span><span class=p>.</span><span class=nf>Query</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>sql</span><span class=p>,</span> <span class=nx>args</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// QueryRow implements DBTX</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>PGStore</span><span class=p>)</span> <span class=nf>QueryRow</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>sql</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>args</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=nx>pgx</span><span class=p>.</span><span class=nx>Row</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span><span class=p>.</span><span class=nf>QueryRow</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>sql</span><span class=p>,</span> <span class=nx>args</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>NonTX</span><span class=p>.</span><span class=nf>QueryRow</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>sql</span><span class=p>,</span> <span class=nx>args</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=3-extracttx-and-injecttx-functions>3. ExtractTx and injectTx Functions<a hidden class=anchor aria-hidden=true href=#3-extracttx-and-injecttx-functions>#</a></h3><p>Next we create helpers that automate the use of <code>NewPGStore</code>.
<code>ExtractTx</code> is used to extract <code>database transaction connections</code> stored in context
<code>injectTx</code> is used for the opposite, which is injecting <code>database transactions</code> into context.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>dbtx</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/jackc/pgx/v5&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/jackc/pgx/v5/pgxpool&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>KeyTransaction</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=nx>TXKey</span> <span class=nx>KeyTransaction</span> <span class=p>=</span> <span class=s>&#34;unique-key-transaction&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ExtractTx extract transaction from context and transform database into dbtx.DBTX</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ExtractTx</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>defaultPool</span> <span class=o>*</span><span class=nx>pgxpool</span><span class=p>.</span><span class=nx>Pool</span><span class=p>)</span> <span class=nx>DBTX</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>tx</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Value</span><span class=p>(</span><span class=nx>TXKey</span><span class=p>).(</span><span class=nx>pgx</span><span class=p>.</span><span class=nx>Tx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=o>||</span> <span class=nx>tx</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nf>NewPGStore</span><span class=p>(</span><span class=nx>defaultPool</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>NewPGStore</span><span class=p>(</span><span class=kc>nil</span><span class=p>,</span> <span class=nx>tx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// injectTx injects transaction to context</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>injectTx</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>tx</span> <span class=nx>pgx</span><span class=p>.</span><span class=nx>Tx</span><span class=p>)</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>TXKey</span><span class=p>,</span> <span class=nx>tx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=4-txmanager-and-withatomic-function>4. TxManager and WithAtomic Function<a hidden class=anchor aria-hidden=true href=#4-txmanager-and-withatomic-function>#</a></h3><p>WithAtomic automates the use of ExtractTx and injectTx. It&rsquo;s a wrapper function that will perform ROLLBACK if it fails, and will perform COMMIT database transaction if it succeeds.</p><p>In short, when WithAtomic is called, the context will be filled with database transaction, then the context containing database transaction will be used to run subsequent database operations, the repository will automatically use this transaction because it performs ExtractTx every time a database command is executed.</p><p>At the logic layer we only deal with WithAtomic.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>dbtx</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;log/slog&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/jackc/pgx/v5/pgxpool&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>TxManager</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>WithAtomic</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>tFunc</span> <span class=kd>func</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>txManager</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>db</span>  <span class=o>*</span><span class=nx>pgxpool</span><span class=p>.</span><span class=nx>Pool</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span> <span class=o>*</span><span class=nx>slog</span><span class=p>.</span><span class=nx>Logger</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewTxManager</span><span class=p>(</span><span class=nx>sqlDB</span> <span class=o>*</span><span class=nx>pgxpool</span><span class=p>.</span><span class=nx>Pool</span><span class=p>,</span> <span class=nx>log</span> <span class=o>*</span><span class=nx>slog</span><span class=p>.</span><span class=nx>Logger</span><span class=p>)</span> <span class=nx>TxManager</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>txManager</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>db</span><span class=p>:</span>  <span class=nx>sqlDB</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>:</span> <span class=nx>log</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// =========================================================================</span>
</span></span><span class=line><span class=cl><span class=c1>// TRANSACTION</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// WithAtomic runs function within transaction</span>
</span></span><span class=line><span class=cl><span class=c1>// The transaction commits when function were finished without error</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>txManager</span><span class=p>)</span> <span class=nf>WithAtomic</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>tFunc</span> <span class=kd>func</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// begin transaction</span>
</span></span><span class=line><span class=cl>	<span class=nx>tx</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>db</span><span class=p>.</span><span class=nf>Begin</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;begin transaction: %w&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// run callback</span>
</span></span><span class=line><span class=cl>	<span class=nx>err</span> <span class=p>=</span> <span class=nf>tFunc</span><span class=p>(</span><span class=nf>injectTx</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>tx</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// if error, rollback</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>errRollback</span> <span class=o>:=</span> <span class=nx>tx</span><span class=p>.</span><span class=nf>Rollback</span><span class=p>(</span><span class=nx>ctx</span><span class=p>);</span> <span class=nx>errRollback</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>r</span><span class=p>.</span><span class=nx>log</span><span class=p>.</span><span class=nf>Error</span><span class=p>(</span><span class=s>&#34;rollback transaction&#34;</span><span class=p>,</span> <span class=nx>slog</span><span class=p>.</span><span class=nf>String</span><span class=p>(</span><span class=s>&#34;error&#34;</span><span class=p>,</span> <span class=nx>errRollback</span><span class=p>.</span><span class=nf>Error</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// if no error, commit</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>errCommit</span> <span class=o>:=</span> <span class=nx>tx</span><span class=p>.</span><span class=nf>Commit</span><span class=p>(</span><span class=nx>ctx</span><span class=p>);</span> <span class=nx>errCommit</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;failed to commit transaction: %w&#34;</span><span class=p>,</span> <span class=nx>errCommit</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=5-withatomic-and-extracttx-implementation>5. WithAtomic and ExtractTx Implementation<a hidden class=anchor aria-hidden=true href=#5-withatomic-and-extracttx-implementation>#</a></h3><h4 id=service-layer>Service Layer:<a hidden class=anchor aria-hidden=true href=#service-layer>#</a></h4><p>Service layer uses TxManager.WithAtomic to wrap business logic in transactions. This ensures that all database operations in that business logic are performed atomically.</p><h4 id=repository-layer>Repository Layer:<a hidden class=anchor aria-hidden=true href=#repository-layer>#</a></h4><p>Repository layer uses ExtractTx to get the appropriate DBTX object (transaction-based or regular connection) from context. All database operations in the repository are performed through this DBTX object.</p><p>So the code will be something like the following.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>service</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Repo</span>      <span class=nx>AccountStorer</span>
</span></span><span class=line><span class=cl>	<span class=nx>TxManager</span> <span class=nx>TxManager</span> <span class=c1>// helper for transactions becomes additional dependency or can be combined with repo</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>service</span><span class=p>)</span> <span class=nf>TransferMoney</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>input</span> <span class=nx>model</span><span class=p>.</span><span class=nx>TransferDTO</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// shared variable to hold results inside WithAtomic if any</span>
</span></span><span class=line><span class=cl>	<span class=c1>// result := ...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Wrapping the process with database transaction</span>
</span></span><span class=line><span class=cl>	<span class=nx>txErr</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>TxManager</span><span class=p>.</span><span class=nf>WithAtomic</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Getting account A</span>
</span></span><span class=line><span class=cl>		<span class=nx>accountA</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>Repo</span><span class=p>.</span><span class=nf>GetAccountByID</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>input</span><span class=p>.</span><span class=nx>AccountA</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>err</span> <span class=c1>// Failed to get account A</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Getting account B</span>
</span></span><span class=line><span class=cl>		<span class=nx>accountB</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>Repo</span><span class=p>.</span><span class=nf>GetAccountByID</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>input</span><span class=p>.</span><span class=nx>AccountB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>err</span> <span class=c1>// Failed to get account B</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Checking if account A balance is sufficient</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>accountA</span><span class=p>.</span><span class=nx>Balance</span> <span class=p>&lt;</span> <span class=nx>input</span><span class=p>.</span><span class=nx>Amount</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;insufficient balance&#34;</span><span class=p>)</span> <span class=c1>// Failed due to insufficient balance</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Reducing account A balance</span>
</span></span><span class=line><span class=cl>		<span class=nx>accountA</span><span class=p>.</span><span class=nx>Balance</span> <span class=o>-=</span> <span class=nx>input</span><span class=p>.</span><span class=nx>Amount</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>Repo</span><span class=p>.</span><span class=nf>UpdateAccount</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>accountA</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>err</span> <span class=c1>// Failed to update account A balance</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Adding amount to account B balance</span>
</span></span><span class=line><span class=cl>		<span class=nx>accountB</span><span class=p>.</span><span class=nx>Balance</span> <span class=o>+=</span> <span class=nx>input</span><span class=p>.</span><span class=nx>Amount</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>Repo</span><span class=p>.</span><span class=nf>UpdateAccount</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>accountB</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>err</span> <span class=c1>// Failed to update account B balance</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>txErr</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>txErr</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Getting account by ID</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>repo</span><span class=p>)</span> <span class=nf>GetAccountByID</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>id</span> <span class=kt>uint</span><span class=p>)</span> <span class=p>(</span><span class=nx>model</span><span class=p>.</span><span class=nx>AccountEntity</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>dbtx</span> <span class=o>:=</span> <span class=nf>ExtractTx</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>db</span><span class=p>)</span> <span class=c1>// extracting context and making regular db into DBTX interface</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>account</span> <span class=nx>model</span><span class=p>.</span><span class=nx>AccountModel</span>
</span></span><span class=line><span class=cl>    <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dbtx</span><span class=p>.</span><span class=nf>QueryRow</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;SELECT * FROM accounts WHERE id = $1&#34;</span><span class=p>,</span> <span class=nx>id</span><span class=p>).</span><span class=nf>Scan</span><span class=p>(</span> 
</span></span><span class=line><span class=cl>        <span class=cm>/* ...scan fields of account... */</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>account</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Updating account</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>repo</span><span class=p>)</span> <span class=nf>UpdateAccount</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>account</span> <span class=nx>model</span><span class=p>.</span><span class=nx>AccountEntity</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>dbtx</span> <span class=o>:=</span> <span class=nf>ExtractTx</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>db</span><span class=p>)</span> <span class=c1>// extracting context and making regular db into DBTX interface</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dbtx</span><span class=p>.</span><span class=nf>Exec</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>`
</span></span></span><span class=line><span class=cl><span class=s>        UPDATE accounts 
</span></span></span><span class=line><span class=cl><span class=s>        SET balance = $1
</span></span></span><span class=line><span class=cl><span class=s>        WHERE id = $2`</span><span class=p>,</span> <span class=nx>account</span><span class=p>.</span><span class=nx>Balance</span><span class=p>,</span> <span class=nx>account</span><span class=p>.</span><span class=nx>ID</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>By implementing the above method, we successfully separate the logic layer from dependencies on third-party libraries. In the repository example I included, it can be seen that even to change ORMs, the service layer doesn&rsquo;t need any changes. YEYY.</p><p>Let&rsquo;s elaborate again, what are the advantages:</p><ol><li>Logic layer remains pure, not contaminated by gorm packages or other drivers.</li><li>Database transactions can be controlled effectively, allowing to manage transaction scope to be kept as small as possible if needed. This approach is different from implementing transactions in middleware, which can cause the entire logic process to be within one database transaction.</li><li>Code readability is maintained.</li><li>Unit testing remains focused on business logic only.</li></ol><h2 id=sample-github-repository>Sample Github Repository<a hidden class=anchor aria-hidden=true href=#sample-github-repository>#</a></h2><p>I include sample code in two versions, one for GORM and another for other implementations (pgx). Here, GORM is simpler because basically GORM has combined regular database operations with database transaction operations.</p><p>Here&rsquo;s the repository: <a href=https://github.com/muchlist/example-dbtx-in-logic/blob/main/main.go>REPOSITORY</a></p><p>When implementing database transactions, it&rsquo;s also important to consider the possibility of deadlocks. In the sample code I provided above, I have simplified the code by setting aside those aspects. I will discuss deadlocks further in future opportunities.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.muchlis.dev/en/tags/golang/>Golang</a></li><li><a href=https://blog.muchlis.dev/en/tags/best-practices/>Best Practices</a></li><li><a href=https://blog.muchlis.dev/en/tags/database/>Database</a></li></ul><nav class=paginav><a class=prev href=https://blog.muchlis.dev/en/post/struct-separation/><span class=title>« Prev</span><br><span>Understanding the Importance of Separating DTO, Entity and Model in Application Development</span>
</a><a class=next href=https://blog.muchlis.dev/en/post/pagination/><span class=title>Next »</span><br><span>Pagination Optimization: Why Limit-Offset Can Be a Time Bomb and Cursor Pagination as the Solution</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Database Transaction Implementation Techniques in Logic Layer for Golang Backend on x" href="https://x.com/intent/tweet/?text=Database%20Transaction%20Implementation%20Techniques%20in%20Logic%20Layer%20for%20Golang%20Backend&amp;url=https%3a%2f%2fblog.muchlis.dev%2fen%2fpost%2fdb-transaction%2f&amp;hashtags=Golang%2cBestPractices%2cDatabase"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Database Transaction Implementation Techniques in Logic Layer for Golang Backend on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.muchlis.dev%2fen%2fpost%2fdb-transaction%2f&amp;title=Database%20Transaction%20Implementation%20Techniques%20in%20Logic%20Layer%20for%20Golang%20Backend&amp;summary=Database%20Transaction%20Implementation%20Techniques%20in%20Logic%20Layer%20for%20Golang%20Backend&amp;source=https%3a%2f%2fblog.muchlis.dev%2fen%2fpost%2fdb-transaction%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Database Transaction Implementation Techniques in Logic Layer for Golang Backend on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.muchlis.dev%2fen%2fpost%2fdb-transaction%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Database Transaction Implementation Techniques in Logic Layer for Golang Backend on whatsapp" href="https://api.whatsapp.com/send?text=Database%20Transaction%20Implementation%20Techniques%20in%20Logic%20Layer%20for%20Golang%20Backend%20-%20https%3a%2f%2fblog.muchlis.dev%2fen%2fpost%2fdb-transaction%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Database Transaction Implementation Techniques in Logic Layer for Golang Backend on telegram" href="https://telegram.me/share/url?text=Database%20Transaction%20Implementation%20Techniques%20in%20Logic%20Layer%20for%20Golang%20Backend&amp;url=https%3a%2f%2fblog.muchlis.dev%2fen%2fpost%2fdb-transaction%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=muchlist/paper data-repo-id=R_kgDOMD4syA data-category=General data-category-id=DIC_kwDOMD4syM4ChOKX data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=en data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.muchlis.dev/en/>Muchlis Dev</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>