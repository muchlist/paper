<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Understanding the Importance of Separating DTO, Entity and Model in Application Development | Muchlis Dev</title><meta name=keywords content="golang,Best Practices,Golang DDD"><meta name=description content="How separation of responsibilities between structs (or classes) can improve security, sustainability, and efficiency in application development."><meta name=author content="Muchlis"><link rel=canonical href=https://blog.muchlis.dev/en/post/struct-separation/><meta name=google-site-verification content="G-F1ZZCKLSJF"><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.muchlis.dev/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.muchlis.dev/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.muchlis.dev/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.muchlis.dev/icon/apple-touch-icon.png><link rel=mask-icon href=https://blog.muchlis.dev/icon/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=id href=https://blog.muchlis.dev/post/struct-separation/><link rel=alternate hreflang=en href=https://blog.muchlis.dev/en/post/struct-separation/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F1ZZCKLSJF"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F1ZZCKLSJF")}</script><meta property="og:url" content="https://blog.muchlis.dev/en/post/struct-separation/"><meta property="og:site_name" content="Muchlis Dev"><meta property="og:title" content="Understanding the Importance of Separating DTO, Entity and Model in Application Development"><meta property="og:description" content="How separation of responsibilities between structs (or classes) can improve security, sustainability, and efficiency in application development."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-01-26T00:49:17+08:00"><meta property="article:modified_time" content="2025-01-26T00:49:17+08:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Best Practices"><meta property="article:tag" content="Golang DDD"><meta property="og:image" content="https://blog.muchlis.dev/img/struct-separation/struct-separation.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.muchlis.dev/img/struct-separation/struct-separation.webp"><meta name=twitter:title content="Understanding the Importance of Separating DTO, Entity and Model in Application Development"><meta name=twitter:description content="How separation of responsibilities between structs (or classes) can improve security, sustainability, and efficiency in application development."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.muchlis.dev/en/post/"},{"@type":"ListItem","position":2,"name":"Understanding the Importance of Separating DTO, Entity and Model in Application Development","item":"https://blog.muchlis.dev/en/post/struct-separation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Understanding the Importance of Separating DTO, Entity and Model in Application Development","name":"Understanding the Importance of Separating DTO, Entity and Model in Application Development","description":"How separation of responsibilities between structs (or classes) can improve security, sustainability, and efficiency in application development.","keywords":["golang","Best Practices","Golang DDD"],"articleBody":"In Golang application development, we often find a single struct object used for various purposes, such as representing data in the database as well as payload in API requests and responses. Although this seems practical, this approach can actually create problems related to security and maintenance. This article will discuss the importance of separating DTO, Entity and Model by applying some Domain-Driven Design (DDD) principles.\nUnderstanding Entity, Model and DTO in Domain-Driven Design Principles Domain-Driven Design (DDD) is a software development methodology that focuses on separation of responsibilities through modeling oriented towards business domains. In DDD, we recognize several important concepts:\nData Transfer Object (DTO): Used to transfer data between functions without involving complex business logic. For example, structs for requests, responses, and function parameters. Entity: Used to store data that will be used in application logic. A struct is called an entity if it has an identity (such as an ID) that distinguishes it from other data. Entities can have their own logic. For example, a Weather entity that has an IsOutdoorEventFeasible() method to evaluate whether the weather is suitable for outdoor events. type WeatherEntity struct { ID string // example: Combination of Location Code and Timestamp City string Temperature float64 Humidity int Description string } // IsOutdoorEventFeasible evaluates whether the weather is suitable for outdoor events. func (w *WeatherEntity) IsOutdoorEventFeasible() bool { // outdoor events are considered not feasible if: // - Temperature below 15 degrees Celsius or above 35 degrees Celsius // - Weather description indicates rain or storm if w.Temperature \u003c 15 || w.Temperature \u003e 35 { return false } if w.Description == \"rain\" || w.Description == \"storm\" { return false } return true } Repository: Repository objects hide data storage implementation details. While Model structs function as data representation in the database used by Repository. Application Service: Handles business logic that requires interaction with external components or other services, in clean architecture this is often called usecase or service. Handles operations that don’t naturally fit within the context of Entity or Value Object. Actually there are many others, such as Value Object, Aggregate, Domain-Service etc. However, we want our code to be “good-enough for maintainability”, but also “not become too complex”, so here we are a bit loose in applying DDD.\nWhy is Separation Important? Using the same struct across different application layers like database, business logic, and presentation can create high coupling. For example, changes in the database (such as adding new columns) can affect the API, even if those columns are not relevant for API users.\nScenario Suppose we have an application that helps users plan events based on weather forecasts. Our application uses a third-party weather API to get current weather information.\ntype Weather struct { City string `json:\"city\" db:\"city\"` Temperature float64 `json:\"temperature\" db:\"temperature\"` Humidity int `json:\"humidity\" db:\"humidity\"` WindSpeed float64 `json:\"wind_speed\" db:\"wind_speed\"` Description string `json:\"description\" db:\"description\"` } One day, the third-party weather API announces changes to their response, adding more details like airQualityIndex, visibility, and uvIndex. They even make major changes to version 2 such as splitting temperature into temperature_celsius and temperature_kelvin.\nImpact Without Struct Separation (bad) If we use the same Weather struct to capture responses from the API, store data in the database, and also as our API response, changes in the third-party API can cause several problems:\nChanges in Many Places: Changes in one struct means also changing the database, business logic, and possibly also data consumed by the frontend. Overfetching and Irrelevant Data: we might not need all the additional data like temperature_kelvin or uvIndex for our application’s purposes, but because we use the same structure, we are forced to handle this extra data. Increased Complexity: With new data, we might need some modifications to the data types to adjust Tags, Marshalers, Scanners and Valuers. Impact With Struct Separation (good) Conversely, by separating DTO, Entity, and Model, we can more efficiently handle these changes.\nDTO (Data Transfer Object):\nWe create a dedicated struct to capture responses from the weather API that includes all new data (or only relevant data). Helps us to know data availability from the API.\nFor the above scenario, we only need to adjust the API Client layer.\ntype WeatherAPIResponse struct { City string `json:\"city\"` TemperatureCelsius float64 `json:\"temperature_celsius\"` TemperatureKelvin float64 `json:\"temperature_kelvin\"` Humidity int `json:\"humidity\"` WindSpeed float64 `json:\"wind_speed\"` Description string `json:\"description\"` AirQualityIndex int `json:\"airQualityIndex\"` Visibility int `json:\"visibility\"` UvIndex int `json:\"uvIndex\"` } func (w *WeatherAPIResponse) ToEntity(){ // transform } Entity:\nThe Weather entity in our application only stores data relevant to the application’s function, such as Temperature, Humidity, and Description. No need to store uvIndex or visibility if that data is not used in the event planning process, so we know which data is important for logic and which is not.\ntype WeatherEntity struct { ID string // Combination of Location Code and Timestamp City string Temperature float64 Humidity int Description string } // IsOutdoorEventFeasible evaluates whether the weather is suitable for outdoor events. func (w *WeatherEntity) IsOutdoorEventFeasible() bool { // outdoor events are considered not feasible if: // - Temperature below 15 degrees Celsius or above 35 degrees Celsius // - Weather description indicates rain or storm if w.Temperature \u003c 15 || w.Temperature \u003e 35 { return false } if w.Description == \"rain\" || w.Description == \"storm\" { return false } return true } Business Logic (Usecase Layer):\nBusiness logic should not know about database models or responses from third-party APIs. Business logic only processes data that is already in Entity form or that we can control its stability. This facilitates maintenance and reduces the risk of errors.\nDatabase Model:\nFor database storage purposes, use a separate struct, especially if using ORM\ntype WeatherModel struct { ID string `db:\"id\"` City string `db:\"city\"` Temperature float64 `db:\"temperature\"` Humidity int `db:\"humidity\"` Description string `db:\"description\"` } func (w *WeatherModel) ToEntity(){ // transform } func FromEntity(WeatherEntity) WeatherModel { // transform } and so on for WeatherRequestDTO and WeatherResponseDTO.\nTrade-offs Although separating data structures like DTO (Data Transfer Object), Entity, and database Model has long-term benefits such as security, ease in testing, and clear separation of concerns, there are some drawbacks that need to be considered as well. One of the main drawbacks is the need to perform transformations between these structs, which means there is a slight sacrifice in speed.\nHowever, this approach is often considered a reasonable price for the benefits gained. Popular books like Clean Code by Robert C. Martin, The Pragmatic Programmer by Andrew Hunt and David Thomas, and Refactoring: Improving the Design of Existing Code by Martin Fowler, often emphasize the importance of prioritizing correct and maintainable code before focusing on speed.\nBesides, the latency generated from this data transformation is very very very minimal compared to the latency of database operations, which tend to be a more significant bottleneck in many applications.\nWhen Should You NOT Separate Structs? The system is too simple. Requires high speed such as in game development. The slightest performance improvement is considered more important than readability and ease of maintenance. How to Properly Separate Structs I recommend the following approach to separate golang structs in API architecture. This approach ensures that each layer in the application has clear and separate responsibilities, making maintenance and future development easier.\nStructs for Presentation Layer: WeatherRequest and WeatherResponse: These structs are used to handle data coming in and out of the API (presentation). They are responsible for validating and formatting data according to client needs. For more complex cases, such as partial update features, you might need WeatherUpdateRequest. This version uses pointer fields to allow partial updates. Structs for Domain Layer: WeatherEntity: This entity represents data in the business domain and contains logic directly related to business rules. Entities should be stable and not affected by changes in other layers, such as databases or external APIs. For more complex cases, such as partial update features, you might need WeatherUpdateDTO. A DTO version that also uses pointer fields for flexibility in data transmission. Structs for Persistence Layer: WeatherModel: This struct is used for database interaction. This model reflects the storage schema and can change along with changes in the database layer. Implementation Diagram Assuming using Clean Architecture or Hexagonal Architecture, then:\nHandler Layer manages request and response data, converts requests to internal data types that we can fully control (entity) before passing to Usecase. Usecase Layer works with stable entities, this layer should avoid direct dependencies on database models or external API formats. Repository Layer manages database access and converts data to and from entities used by usecase. This approach ensures that each layer is isolated from irrelevant changes in other layers, thereby improving application resilience and flexibility. By separating responsibilities in each layer, applications become more modular, facilitating maintenance and scalability.\nAlso read: How to apply good rules to maintain separation of concerns\nConclusion Implementing separation of DTO, Entity and Model structs in API design using Golang is a small investment that can save a lot of time and resources for development and maintenance in the future, making our system not only efficient but also easy to manage and develop. This approach can clearly divide the responsibilities of each component, reduce dependencies between modules, and ultimately strengthen the overall application architecture itself.\nOf course, there is no one perfect approach for every situation. How has your experience been in implementing or perhaps not implementing this principle? Are there specific cases where you found more effective alternatives? Share your experience in the comments section!\n","wordCount":"1568","inLanguage":"en","image":"https://blog.muchlis.dev/img/struct-separation/struct-separation.webp","datePublished":"2025-01-26T00:49:17+08:00","dateModified":"2025-01-26T00:49:17+08:00","author":{"@type":"Person","name":"Muchlis"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.muchlis.dev/en/post/struct-separation/"},"publisher":{"@type":"Organization","name":"Muchlis Dev","logo":{"@type":"ImageObject","url":"https://blog.muchlis.dev/icon/favicon.ico"}}}</script><link rel=stylesheet href=https://blog.muchlis.dev/css/custom-styles.min.846e2c0c38b3403ffecfec3d9c9b227dcfa79e75b178a91e1a26ae745cf5da5a.css><script src=https://blog.muchlis.dev/js/clickable-image.min.64e4ed1fd2302afde6a6750edcf663d18d6bf3b36d95ac130501827d8732c7a3.js defer></script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.muchlis.dev/en/ accesskey=h title="Home (Alt + H)"><img src=https://blog.muchlis.dev/icon/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.muchlis.dev/ title=Indonesian aria-label=Indonesian>Id</a></li></ul></div></div><ul id=menu><li><a href=https://blog.muchlis.dev/en/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.muchlis.dev/en/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.muchlis.dev/en/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://muchlis.dev title="Portfolio (2021)"><span>Portfolio (2021)</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.muchlis.dev/en/>Home</a>&nbsp;»&nbsp;<a href=https://blog.muchlis.dev/en/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Understanding the Importance of Separating DTO, Entity and Model in Application Development</h1><div class=post-description>How separation of responsibilities between structs (or classes) can improve security, sustainability, and efficiency in application development.</div><div class=post-meta><span title='2025-01-26 00:49:17 +0800 WITA'>January 26, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1568 words&nbsp;·&nbsp;Muchlis&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://blog.muchlis.dev/post/struct-separation/>Id</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/muchlist/paper/tree/main/content/post/struct-separation.en.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#understanding-entity-model-and-dto-in-domain-driven-design-principles>Understanding Entity, Model and DTO in Domain-Driven Design Principles</a></li><li><a href=#why-is-separation-important>Why is Separation Important?</a><ul><li><a href=#scenario>Scenario</a></li><li><a href=#impact-without-struct-separation-bad>Impact Without Struct Separation (bad)</a></li><li><a href=#impact-with-struct-separation-good>Impact With Struct Separation (good)</a></li></ul></li><li><a href=#trade-offs>Trade-offs</a></li><li><a href=#when-should-you-not-separate-structs>When Should You NOT Separate Structs?</a></li><li><a href=#how-to-properly-separate-structs>How to Properly Separate Structs</a><ul><li><a href=#structs-for-presentation-layer>Structs for Presentation Layer:</a></li><li><a href=#structs-for-domain-layer>Structs for Domain Layer:</a></li><li><a href=#structs-for-persistence-layer>Structs for Persistence Layer:</a></li></ul></li><li><a href=#implementation-diagram>Implementation Diagram</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><p>In Golang application development, we often find a single struct object used for various purposes, such as representing data in the database as well as payload in API requests and responses. Although this seems practical, this approach can actually create problems related to security and maintenance. This article will discuss the importance of separating DTO, Entity and Model by applying some Domain-Driven Design (DDD) principles.</p><h2 id=understanding-entity-model-and-dto-in-domain-driven-design-principles>Understanding Entity, Model and DTO in Domain-Driven Design Principles<a hidden class=anchor aria-hidden=true href=#understanding-entity-model-and-dto-in-domain-driven-design-principles>#</a></h2><p>Domain-Driven Design (DDD) is a software development methodology that focuses on separation of responsibilities through modeling oriented towards business domains. In DDD, we recognize several important concepts:</p><ol><li><strong>Data Transfer Object (DTO)</strong>: Used to transfer data between functions without involving complex business logic. For example, structs for requests, responses, and function parameters.</li><li><strong>Entity</strong>: Used to store data that will be used in application logic. A struct is called an entity if it has an identity (such as an ID) that distinguishes it from other data. Entities can have their own logic. For example, a Weather entity that has an <code>IsOutdoorEventFeasible()</code> method to evaluate whether the weather is suitable for outdoor events.<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WeatherEntity</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ID</span>          <span class=kt>string</span>   <span class=c1>// example: Combination of Location Code and Timestamp</span>
</span></span><span class=line><span class=cl>	<span class=nx>City</span>        <span class=kt>string</span>  
</span></span><span class=line><span class=cl>	<span class=nx>Temperature</span> <span class=kt>float64</span> 
</span></span><span class=line><span class=cl>	<span class=nx>Humidity</span>    <span class=kt>int</span>     
</span></span><span class=line><span class=cl>	<span class=nx>Description</span> <span class=kt>string</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// IsOutdoorEventFeasible evaluates whether the weather is suitable for outdoor events.</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>w</span> <span class=o>*</span><span class=nx>WeatherEntity</span><span class=p>)</span> <span class=nf>IsOutdoorEventFeasible</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// outdoor events are considered not feasible if:</span>
</span></span><span class=line><span class=cl>	<span class=c1>// - Temperature below 15 degrees Celsius or above 35 degrees Celsius</span>
</span></span><span class=line><span class=cl>	<span class=c1>// - Weather description indicates rain or storm</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>w</span><span class=p>.</span><span class=nx>Temperature</span> <span class=p>&lt;</span> <span class=mi>15</span> <span class=o>||</span> <span class=nx>w</span><span class=p>.</span><span class=nx>Temperature</span> <span class=p>&gt;</span> <span class=mi>35</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>w</span><span class=p>.</span><span class=nx>Description</span> <span class=o>==</span> <span class=s>&#34;rain&#34;</span> <span class=o>||</span> <span class=nx>w</span><span class=p>.</span><span class=nx>Description</span> <span class=o>==</span> <span class=s>&#34;storm&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li><strong>Repository</strong>: Repository objects hide data storage implementation details. While Model structs function as data representation in the database used by Repository.</li><li><strong>Application Service</strong>: Handles business logic that requires interaction with external components or other services, in clean architecture this is often called <code>usecase</code> or <code>service</code>.
Handles operations that don&rsquo;t naturally fit within the context of Entity or Value Object.</li></ol><p>Actually there are many others, such as <code>Value Object</code>, <code>Aggregate</code>, <code>Domain-Service</code> etc.
However, we want our code to be &ldquo;good-enough for maintainability&rdquo;, but also &ldquo;not become too complex&rdquo;, so here we are a bit loose in applying DDD.</p><h2 id=why-is-separation-important>Why is Separation Important?<a hidden class=anchor aria-hidden=true href=#why-is-separation-important>#</a></h2><p>Using the same struct across different application layers like database, business logic, and presentation can create high coupling. For example, changes in the database (such as adding new columns) can affect the API, even if those columns are not relevant for API users.</p><h3 id=scenario>Scenario<a hidden class=anchor aria-hidden=true href=#scenario>#</a></h3><p>Suppose we have an application that helps users plan events based on weather forecasts. Our application uses a third-party weather API to get current weather information.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Weather</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>City</span>        <span class=kt>string</span>    <span class=s>`json:&#34;city&#34; db:&#34;city&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Temperature</span> <span class=kt>float64</span>   <span class=s>`json:&#34;temperature&#34; db:&#34;temperature&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Humidity</span>    <span class=kt>int</span>       <span class=s>`json:&#34;humidity&#34; db:&#34;humidity&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>WindSpeed</span>   <span class=kt>float64</span>   <span class=s>`json:&#34;wind_speed&#34; db:&#34;wind_speed&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Description</span> <span class=kt>string</span>    <span class=s>`json:&#34;description&#34; db:&#34;description&#34;`</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>One day, the third-party weather API announces changes to their response, adding more details like airQualityIndex, visibility, and uvIndex. They even make major changes to version 2 such as splitting temperature into temperature_celsius and temperature_kelvin.</p><h3 id=impact-without-struct-separation-bad>Impact Without Struct Separation (bad)<a hidden class=anchor aria-hidden=true href=#impact-without-struct-separation-bad>#</a></h3><p>If we use the same Weather struct to capture responses from the API, store data in the database, and also as our API response, changes in the third-party API can cause several problems:</p><ul><li><strong>Changes in Many Places</strong>: Changes in one struct means also changing the database, business logic, and possibly also data consumed by the frontend.</li><li><strong>Overfetching and Irrelevant Data</strong>: we might not need all the additional data like temperature_kelvin or uvIndex for our application&rsquo;s purposes, but because we use the same structure, we are forced to handle this extra data.</li><li><strong>Increased Complexity</strong>: With new data, we might need some modifications to the data types to adjust Tags, Marshalers, Scanners and Valuers.</li></ul><h3 id=impact-with-struct-separation-good>Impact With Struct Separation (good)<a hidden class=anchor aria-hidden=true href=#impact-with-struct-separation-good>#</a></h3><p>Conversely, by separating DTO, Entity, and Model, we can more efficiently handle these changes.</p><p><strong>DTO (Data Transfer Object):</strong><br>We create a dedicated struct to capture responses from the weather API that includes all new data (or only relevant data).
Helps us to know data availability from the API.<br>For the above scenario, we only need to adjust the API Client layer.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WeatherAPIResponse</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>City</span>                <span class=kt>string</span>  <span class=s>`json:&#34;city&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>TemperatureCelsius</span>  <span class=kt>float64</span> <span class=s>`json:&#34;temperature_celsius&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>TemperatureKelvin</span>   <span class=kt>float64</span> <span class=s>`json:&#34;temperature_kelvin&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Humidity</span>            <span class=kt>int</span>     <span class=s>`json:&#34;humidity&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>WindSpeed</span>           <span class=kt>float64</span> <span class=s>`json:&#34;wind_speed&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Description</span>         <span class=kt>string</span>  <span class=s>`json:&#34;description&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>AirQualityIndex</span>     <span class=kt>int</span>     <span class=s>`json:&#34;airQualityIndex&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Visibility</span>          <span class=kt>int</span>     <span class=s>`json:&#34;visibility&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>UvIndex</span>             <span class=kt>int</span>     <span class=s>`json:&#34;uvIndex&#34;`</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>w</span> <span class=o>*</span><span class=nx>WeatherAPIResponse</span><span class=p>)</span> <span class=nf>ToEntity</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=c1>// transform</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>Entity:</strong><br>The Weather entity in our application only stores data relevant to the application&rsquo;s function, such as Temperature, Humidity, and Description. No need to store uvIndex or visibility if that data is not used in the event planning process, so we know which data is important for logic and which is not.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WeatherEntity</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ID</span>          <span class=kt>string</span>   <span class=c1>// Combination of Location Code and Timestamp</span>
</span></span><span class=line><span class=cl>    <span class=nx>City</span>        <span class=kt>string</span>  
</span></span><span class=line><span class=cl>    <span class=nx>Temperature</span> <span class=kt>float64</span> 
</span></span><span class=line><span class=cl>    <span class=nx>Humidity</span>    <span class=kt>int</span>     
</span></span><span class=line><span class=cl>    <span class=nx>Description</span> <span class=kt>string</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// IsOutdoorEventFeasible evaluates whether the weather is suitable for outdoor events.</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>w</span> <span class=o>*</span><span class=nx>WeatherEntity</span><span class=p>)</span> <span class=nf>IsOutdoorEventFeasible</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// outdoor events are considered not feasible if:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// - Temperature below 15 degrees Celsius or above 35 degrees Celsius</span>
</span></span><span class=line><span class=cl>    <span class=c1>// - Weather description indicates rain or storm</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>w</span><span class=p>.</span><span class=nx>Temperature</span> <span class=p>&lt;</span> <span class=mi>15</span> <span class=o>||</span> <span class=nx>w</span><span class=p>.</span><span class=nx>Temperature</span> <span class=p>&gt;</span> <span class=mi>35</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>w</span><span class=p>.</span><span class=nx>Description</span> <span class=o>==</span> <span class=s>&#34;rain&#34;</span> <span class=o>||</span> <span class=nx>w</span><span class=p>.</span><span class=nx>Description</span> <span class=o>==</span> <span class=s>&#34;storm&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>Business Logic (Usecase Layer):</strong><br>Business logic should not know about database models or responses from third-party APIs. Business logic only processes data that is already in Entity form or that we can control its stability. This facilitates maintenance and reduces the risk of errors.</p><p><strong>Database Model:</strong><br>For database storage purposes, use a separate struct, especially if using ORM</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WeatherModel</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ID</span>          <span class=kt>string</span>  <span class=s>`db:&#34;id&#34;`</span>  
</span></span><span class=line><span class=cl>    <span class=nx>City</span>        <span class=kt>string</span>  <span class=s>`db:&#34;city&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Temperature</span> <span class=kt>float64</span> <span class=s>`db:&#34;temperature&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Humidity</span>    <span class=kt>int</span>     <span class=s>`db:&#34;humidity&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Description</span> <span class=kt>string</span>  <span class=s>`db:&#34;description&#34;`</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>w</span> <span class=o>*</span><span class=nx>WeatherModel</span><span class=p>)</span> <span class=nf>ToEntity</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=c1>// transform</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>FromEntity</span><span class=p>(</span><span class=nx>WeatherEntity</span><span class=p>)</span> <span class=nx>WeatherModel</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// transform</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>and so on for <code>WeatherRequestDTO</code> and <code>WeatherResponseDTO</code>.</p><h2 id=trade-offs>Trade-offs<a hidden class=anchor aria-hidden=true href=#trade-offs>#</a></h2><p>Although separating data structures like DTO (Data Transfer Object), Entity, and database Model has long-term benefits such as security, ease in testing, and clear separation of concerns, there are some drawbacks that need to be considered as well. One of the main drawbacks is the need to perform transformations between these structs, which means there is a slight sacrifice in speed.</p><p>However, this approach is often considered a reasonable price for the benefits gained. Popular books like Clean Code by Robert C. Martin, The Pragmatic Programmer by Andrew Hunt and David Thomas, and Refactoring: Improving the Design of Existing Code by Martin Fowler, often emphasize the importance of prioritizing correct and maintainable code before focusing on speed.</p><p>Besides, the latency generated from this data transformation is very very very minimal compared to the latency of database operations, which tend to be a more significant bottleneck in many applications.</p><h2 id=when-should-you-not-separate-structs>When Should You NOT Separate Structs?<a hidden class=anchor aria-hidden=true href=#when-should-you-not-separate-structs>#</a></h2><ul><li>The system is too simple.</li><li>Requires high speed such as in game development.</li><li>The slightest performance improvement is considered more important than readability and ease of maintenance.</li></ul><h2 id=how-to-properly-separate-structs>How to Properly Separate Structs<a hidden class=anchor aria-hidden=true href=#how-to-properly-separate-structs>#</a></h2><p>I recommend the following approach to separate golang structs in API architecture.
This approach ensures that each layer in the application has clear and separate responsibilities, making maintenance and future development easier.</p><h3 id=structs-for-presentation-layer>Structs for Presentation Layer:<a hidden class=anchor aria-hidden=true href=#structs-for-presentation-layer>#</a></h3><ul><li>WeatherRequest and WeatherResponse: These structs are used to handle data coming in and out of the API (presentation). They are responsible for validating and formatting data according to client needs.</li><li>For more complex cases, such as partial update features, you might need WeatherUpdateRequest. This version uses pointer fields to allow partial updates.</li></ul><h3 id=structs-for-domain-layer>Structs for Domain Layer:<a hidden class=anchor aria-hidden=true href=#structs-for-domain-layer>#</a></h3><ul><li>WeatherEntity: This entity represents data in the business domain and contains logic directly related to business rules. Entities should be stable and not affected by changes in other layers, such as databases or external APIs.</li><li>For more complex cases, such as partial update features, you might need WeatherUpdateDTO. A DTO version that also uses pointer fields for flexibility in data transmission.</li></ul><h3 id=structs-for-persistence-layer>Structs for Persistence Layer:<a hidden class=anchor aria-hidden=true href=#structs-for-persistence-layer>#</a></h3><ul><li>WeatherModel: This struct is used for database interaction. This model reflects the storage schema and can change along with changes in the database layer.</li></ul><h2 id=implementation-diagram>Implementation Diagram<a hidden class=anchor aria-hidden=true href=#implementation-diagram>#</a></h2><figure><img src=/img/struct-separation/struct-separation.webp alt="struct separation layer" class="clickable-image lazyload" data-src=/img/struct-separation/struct-separation.webp loading=lazy></figure><p>Assuming using Clean Architecture or Hexagonal Architecture, then:</p><ul><li>Handler Layer manages request and response data, converts requests to internal data types that we can fully control (entity) before passing to Usecase.</li><li>Usecase Layer works with stable entities, this layer should avoid direct dependencies on database models or external API formats.</li><li>Repository Layer manages database access and converts data to and from entities used by usecase.</li></ul><p>This approach ensures that each layer is isolated from irrelevant changes in other layers, thereby improving application resilience and flexibility.
By separating responsibilities in each layer, applications become more modular, facilitating maintenance and scalability.</p><p>Also read: <a href=/en/post/structuring-project-folder>How to apply good rules to maintain separation of concerns</a></p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Implementing separation of DTO, Entity and Model structs in API design using Golang is a small investment that can save a lot of time and
resources for development and maintenance in the future,
making our system not only efficient but also easy to manage and develop.
This approach can clearly divide the responsibilities of each component, reduce dependencies between modules, and ultimately strengthen the overall application architecture itself.</p><p>Of course, there is no one perfect approach for every situation.
How has your experience been in implementing or perhaps not implementing this principle?
Are there specific cases where you found more effective alternatives?
Share your experience in the comments section!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.muchlis.dev/en/tags/golang/>Golang</a></li><li><a href=https://blog.muchlis.dev/en/tags/best-practices/>Best Practices</a></li><li><a href=https://blog.muchlis.dev/en/tags/golang-ddd/>Golang DDD</a></li></ul><nav class=paginav><a class=next href=https://blog.muchlis.dev/en/post/db-transaction/><span class=title>Next »</span><br><span>Database Transaction Implementation Techniques in Logic Layer for Golang Backend</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding the Importance of Separating DTO, Entity and Model in Application Development on x" href="https://x.com/intent/tweet/?text=Understanding%20the%20Importance%20of%20Separating%20DTO%2c%20Entity%20and%20Model%20in%20Application%20Development&amp;url=https%3a%2f%2fblog.muchlis.dev%2fen%2fpost%2fstruct-separation%2f&amp;hashtags=golang%2cBestPractices%2cGolangDDD"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding the Importance of Separating DTO, Entity and Model in Application Development on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.muchlis.dev%2fen%2fpost%2fstruct-separation%2f&amp;title=Understanding%20the%20Importance%20of%20Separating%20DTO%2c%20Entity%20and%20Model%20in%20Application%20Development&amp;summary=Understanding%20the%20Importance%20of%20Separating%20DTO%2c%20Entity%20and%20Model%20in%20Application%20Development&amp;source=https%3a%2f%2fblog.muchlis.dev%2fen%2fpost%2fstruct-separation%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding the Importance of Separating DTO, Entity and Model in Application Development on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.muchlis.dev%2fen%2fpost%2fstruct-separation%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding the Importance of Separating DTO, Entity and Model in Application Development on whatsapp" href="https://api.whatsapp.com/send?text=Understanding%20the%20Importance%20of%20Separating%20DTO%2c%20Entity%20and%20Model%20in%20Application%20Development%20-%20https%3a%2f%2fblog.muchlis.dev%2fen%2fpost%2fstruct-separation%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding the Importance of Separating DTO, Entity and Model in Application Development on telegram" href="https://telegram.me/share/url?text=Understanding%20the%20Importance%20of%20Separating%20DTO%2c%20Entity%20and%20Model%20in%20Application%20Development&amp;url=https%3a%2f%2fblog.muchlis.dev%2fen%2fpost%2fstruct-separation%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=muchlist/paper data-repo-id=R_kgDOMD4syA data-category=General data-category-id=DIC_kwDOMD4syM4ChOKX data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=en data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.muchlis.dev/en/>Muchlis Dev</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>