<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Memahami Pentingnya Memisahkan DTO, Entity dan Model dalam Pengembangan Aplikasi | Muchlis Dev</title><meta name=keywords content="golang,Best Practices,Golang DDD"><meta name=description content="Bagaimana pemisahan tanggung jawab antar struct (atau class) dapat meningkatkan keamanan, keberlanjutan, dan efisiensi dalam pengembangan aplikasi."><meta name=author content="Muchlis"><link rel=canonical href=https://blog.muchlis.dev/post/struct-separation/><meta name=google-site-verification content="G-F1ZZCKLSJF"><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.muchlis.dev/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.muchlis.dev/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.muchlis.dev/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.muchlis.dev/icon/apple-touch-icon.png><link rel=mask-icon href=https://blog.muchlis.dev/icon/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.muchlis.dev/post/struct-separation/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F1ZZCKLSJF"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F1ZZCKLSJF")}</script><meta property="og:url" content="https://blog.muchlis.dev/post/struct-separation/"><meta property="og:site_name" content="Muchlis Dev"><meta property="og:title" content="Memahami Pentingnya Memisahkan DTO, Entity dan Model dalam Pengembangan Aplikasi"><meta property="og:description" content="Bagaimana pemisahan tanggung jawab antar struct (atau class) dapat meningkatkan keamanan, keberlanjutan, dan efisiensi dalam pengembangan aplikasi."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-01-26T00:49:17+08:00"><meta property="article:modified_time" content="2025-01-26T00:49:17+08:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Best Practices"><meta property="article:tag" content="Golang DDD"><meta property="og:image" content="https://blog.muchlis.dev/img/struct-separation/struct-separation.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.muchlis.dev/img/struct-separation/struct-separation.webp"><meta name=twitter:title content="Memahami Pentingnya Memisahkan DTO, Entity dan Model dalam Pengembangan Aplikasi"><meta name=twitter:description content="Bagaimana pemisahan tanggung jawab antar struct (atau class) dapat meningkatkan keamanan, keberlanjutan, dan efisiensi dalam pengembangan aplikasi."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.muchlis.dev/post/"},{"@type":"ListItem","position":2,"name":"Memahami Pentingnya Memisahkan DTO, Entity dan Model dalam Pengembangan Aplikasi","item":"https://blog.muchlis.dev/post/struct-separation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Memahami Pentingnya Memisahkan DTO, Entity dan Model dalam Pengembangan Aplikasi","name":"Memahami Pentingnya Memisahkan DTO, Entity dan Model dalam Pengembangan Aplikasi","description":"Bagaimana pemisahan tanggung jawab antar struct (atau class) dapat meningkatkan keamanan, keberlanjutan, dan efisiensi dalam pengembangan aplikasi.","keywords":["golang","Best Practices","Golang DDD"],"articleBody":"Dalam pengembangan Aplikasi Golang, sering kali kita temukan satu struct object yang dipakai untuk berbagai keperluan, seperti representasi data di database sekaligus payload dalam request dan response API. Meskipun terlihat praktis, pendekatan ini sebenarnya dapat memunculkan masalah terkait keamanan dan pemeliharaan. Artikel ini akan membahas pentingnya memisahkan DTO, Entity dan Model dengan menerapkan sedikit prinsip Domain-Driven Design (DDD).\nMemahami Entity, Model dan DTO dalam Prinsip Domain-Driven Design Domain-Driven Design (DDD) adalah metodologi pengembangan perangkat lunak yang berfokus pada pemisahan tanggung jawab melalui pemodelan yang berorientasi pada domain bisnis. Dalam DDD, kita mengenal beberapa konsep penting:\nData Transfer Object (DTO) : Digunakan untuk mengirimkan data antar fungsi tanpa melibatkan logika bisnis yang kompleks. Misalnya, struct untuk request, response, dan parameter fungsi. Entity : Digunakan untuk menyimpan data yang akan digunakan dalam logika aplikasi. Sebuah struct disebut entity jika memiliki identitas (seperti ID) yang membedakannya dari data lain. Entity dapat memiliki logika sendiri. Misalnya, entitas Weather yang memiliki metode IsOutdoorEventFeasible() untuk mengevaluasi apakah cuaca cocok untuk acara luar ruang. type WeatherEntity struct { ID string // misal : Kombinasi Kode Lokasi dan Timestamp City string Temperature float64 Humidity int Description string } // IsOutdoorEventFeasible mengevaluasi apakah cuaca cocok untuk acara luar ruang. func (w *WeatherEntity) IsOutdoorEventFeasible() bool { // acara luar ruang dianggap tidak layak jika: // - Suhu di bawah 15 derajat Celsius atau di atas 35 derajat Celsius // - Deskripsi cuaca mengindikasikan hujan atau badai if w.Temperature \u003c 15 || w.Temperature \u003e 35 { return false } if w.Description == \"rain\" || w.Description == \"storm\" { return false } return true } Repository : Object Repository menyembunyikan detail implementasi penyimpanan data. Sedangkan Struct Model berfungsi sebagai representasi data pada database yang digunakan oleh Repository. Application Service : Menangani logika bisnis yang memerlukan interaksi dengan komponen eksternal atau layanan lainnya, dalam clean architecture ini sering disebut usecase atau service. Menghandle operasi-operasi yang tidak secara alami cocok dalam konteks Entity atau Value Object. Sebenarnya masih banyak yang lain, Misalnya Value Object, Aggregate, Domain-Service dll. Namun kita ingin agar code kita menjadi “cukup-baik untuk maintainability”, tetapi juga “tidak menjadi terlalu rumit”, jadi disini kita agak sedikit longgar dalam penerapan DDD tersebut.\nMengapa Pemisahan itu Penting? Menggunakan struct yang sama di berbagai lapisan aplikasi seperti database, logika bisnis, dan presentasi dapat menciptakan keterikatan yang tinggi. Misalnya, perubahan di database (seperti menambahkan kolom baru) dapat memengaruhi API, bahkan jika kolom tersebut tidak relevan untuk pengguna API\nSkenario Misalkan kita memiliki aplikasi yang membantu pengguna merencanakan acara berdasarkan prakiraan cuaca. Aplikasi kita menggunakan API cuaca pihak ketiga untuk mendapatkan informasi cuaca terkini.\ntype Weather struct { City string `json:\"city\" db:\"city\"` Temperature float64 `json:\"temperature\" db:\"temperature\"` Humidity int `json:\"humidity\" db:\"humidity\"` WindSpeed float64 `json:\"wind_speed\" db:\"wind_speed\"` Description string `json:\"description\" db:\"description\"` } Suatu hari, API cuaca pihak ketiga mengumumkan perubahan pada respons mereka, menambahkan lebih banyak detail seperti airQualityIndex, visibility, dan uvIndex. Bahkan melakukan perubahan major ke versi 2 seperti split temperatur menjadi temperature_celcius dan temperature_kelvin.\nDampak Tanpa Pemisahan Struct (bad) Jika kita menggunakan Weather struct yang sama untuk menangkap respons dari API, menyimpan data di database, dan juga sebagai respons API kita, perubahan pada API pihak ketiga dapat menyebabkan beberapa masalah berikut:\nPerubahan di Banyak Tempat: Perubahan di suatu struct artinya juga mengubah database, logika bisnis, dan mungkin juga data yang dikonsumsi oleh frontend. Overfetching and Irrelevant Data: kita mungkin tidak memerlukan semua data tambahan seperti temperature_kelvin atau uvIndex untuk tujuan aplikasi kita, tetapi karena menggunakan struktur yang sama, kita terpaksa menangani data ekstra ini. Peningkatan Kompleksitas: Dengan adanya data baru, kita mungkin memerlukan sedikit modifikasi pada tipe datanya untuk menyesuaikan Tag, Marshaler, Scanners and Valuers. Dampak Dengan Pemisahan Struct (good) Sebaliknya, dengan memisahkan DTO, Entity, dan Model, kita dapat lebih efisien dalam menangani perubahan ini.\nDTO (Data Transfer Object):\nKita membuat struct khusus untuk menangkap respons dari API cuaca yang mencakup semua data baru (atau hanya data relevan). Membantu kita untuk mengetahui ketersediaan data dari API.\nTerhadap skenario diatas, kita cukup menyesuaikan dibagian layer API Client saja.\ntype WeatherAPIResponse struct { City string `json:\"city\"` TemperatureCelcius float64 `json:\"temperature_celcius\"` TemperatureKelvin float64 `json:\"temperature_kelvin\"` Humidity int `json:\"humidity\"` WindSpeed float64 `json:\"wind_speed\"` Description string `json:\"description\"` AirQualityIndex int `json:\"airQualityIndex\"` Visibility int `json:\"visibility\"` UvIndex int `json:\"uvIndex\"` } func (w *WeatherAPIResponse) ToEntity(){ // transform } Entity:\nEntity Weather dalam aplikasi kita hanya menyimpan data yang relevan untuk fungsi aplikasi, seperti Temperature, Humidity, dan Description. Tidak perlu menyimpan uvIndex atau visibility jika data tersebut tidak digunakan dalam proses perencanaan acara, dengan begitu kita mengetahui data mana yang penting untuk logic dan yang tidak.\ntype WeatherEntity struct { ID string // Kombinasi Kode Lokasi dan Timestamp City string Temperature float64 Humidity int Description string } // IsOutdoorEventFeasible mengevaluasi apakah cuaca cocok untuk acara luar ruang. func (w *WeatherEntity) IsOutdoorEventFeasible() bool { // acara luar ruang dianggap tidak layak jika: // - Suhu di bawah 15 derajat Celsius atau di atas 35 derajat Celsius // - Deskripsi cuaca mengindikasikan hujan atau badai if w.Temperature \u003c 15 || w.Temperature \u003e 35 { return false } if w.Description == \"rain\" || w.Description == \"storm\" { return false } return true } Logika Bisnis (Usecase Layer):\nLogika bisnis seharusnya tidak mengenal model database atau response dari API pihak ketiga. Logika bisnis hanya mengolah data yang sudah berupa Entity atau yang kita bisa kontrol kestabilannya. Ini memudahkan pemeliharaan dan mengurangi risiko error.\nModel Database:\nUntuk keperluan menyimpan ke database gunakan struct tersendiri, khususnya jika menggunkan ORM\ntype WeatherModel struct { ID string `db:\"id\"` City string `db:\"city\"` Temperature float64 `db:\"temperature\"` Humidity int `db:\"humidity\"` Description string `db:\"description\"` } func (w *WeatherModel) ToEntity(){ // transform } func FromEntity(WeatherEntity) WeatherModel { // transform } dan seterusnya untuk WeatherRequestDTO dan WeatherResponseDTO.\nTrade-offs Meskipun pemisahan struktur data seperti DTO (Data Transfer Object), Entity, dan Model database memiliki manfaat jangka panjang seperti keamanan, kemudahan dalam testing, dan separation of concern yang jelas, ada beberapa kekurangan yang perlu dipertimbangkan juga. Salah satu kekurangan utamanya adalah kebutuhan untuk melakukan transformasi antara struct-struct ini, yang berarti ada sedikit pengorbanan kecepatan.\nNamun, pendekatan ini sering dianggap sebagai bayaran-yang-wajar untuk manfaat yang diperoleh. Buku-buku populer seperti Clean Code oleh Robert C. Martin, The Pragmatic Programmer oleh Andrew Hunt dan David Thomas, serta Refactoring: Improving the Design of Existing Code oleh Martin Fowler, sering kali menekankan pentingnya memprioritaskan kode yang benar dan mudah dipelihara sebelum fokus pada kecepatan.\nLagipula, latensi yang dihasilkan dari transformasi data ini sangat sangat sangat minim jika dibandingkan dengan latensi operasi database, yang cenderung menjadi bottleneck yang lebih signifikan dalam banyak aplikasi.\nKapan Sebaiknya Tidak Memisahkan Struct? Sistemnya terlalu sederhana. Memerlukan kecepatan tinggi seperti dalam pengembangan game. Peningkatan peforma sekecil-kecilnya dinilai lebih penting daripada keterbacaan dan kemudahan pemeliharaan. Cara Memisahkan Struct yang tepat Saya menyarankan pendekatan berikut untuk memisahkan struct golang dalam arsitektur API. Pendekatan ini memastikan bahwa setiap lapisan dalam aplikasi memiliki tanggung jawab yang jelas dan terpisah, sehingga memudahkan pemeliharaan dan pengembangan di masa mendatang.\nStruct untuk Lapisan Presentation: WeatherRequest dan WeatherResponse: Struct ini digunakan untuk menangani data yang masuk dan keluar dari API (presentation). Mereka bertanggung jawab untuk memvalidasi dan memformat data sesuai dengan kebutuhan klien. Untuk kasus yang lebih kompleks, seperti fitur partial update, Kamu mungkin memerlukan WeatherUpdateRequest. Versi ini menggunakan field pointer untuk memungkinkan pembaruan sebagian (partial update). Struct untuk Lapisan Domain: WeatherEntity: Entity ini mewakili data dalam domain bisnis dan berisi logika yang terkait langsung dengan aturan bisnis. Entity harus stabil dan tidak terpengaruh oleh perubahan di lapisan lain, seperti database atau API eksternal. Untuk kasus yang lebih kompleks, seperti fitur partial update, Kamu mungkin memerlukan WeatherUpdateDTO. Versi DTO yang juga menggunakan field pointer untuk fleksibilitas dalam pengiriman data. Struct untuk Lapisan Persistence: WeatherModel: Struct ini digunakan untuk interaksi dengan database. Model ini mencerminkan skema penyimpanan dan dapat berubah seiring dengan perubahan di layer database. Diagram Implementasi Dengan asumsi menggunakan Clean Architecture atau Hexagonal Architecture, maka :\nHandler Layer mengelola data request dan response, mengubah request ke tipe data internal yang dapat kita kontrol sepenuhnya (entity) sebelum diteruskan ke Usecase. Usecase Layer bekerja dengan entity yang stabil, layer ini seharusnya menghindari ketergantungan langsung pada model database atau format API eksternal. Repository Layer mengelola akses ke database dan mengubah data ke dan dari entity yang digunakan oleh usecase. Pendekatan ini memastikan bahwa setiap lapisan terisolasi dari perubahan yang tidak relevan di lapisan lain, sehingga meningkatkan ketahanan dan fleksibilitas aplikasi. Dengan memisahkan tanggung jawab di setiap layer, aplikasi menjadi lebih modular, memudahkan pemeliharaan dan skalabilitas.\nBaca juga : Bagaimana cara menerapkan aturan yang baik untuk menjaga separation of concern\nKesimpulan Mengimplementasikan pemisahan struct DTO, Entity dan Model dalam desain API menggunakan Golang merupakan investasi kecil yang bisa menghemat banyak waktu dan sumber daya untuk pengembangan dan pemeliharaan di masa depan, membuat sistem kita tidak hanya efisien tapi juga mudah untuk dikelola dan dikembangkan. Pendekatan ini dapat membagi tanggung jawab tiap komponen secara jelas, mengurangi ketergantungan antar-modul, dan pada akhirnya menguatkan keseluruhan arsitektur aplikasi itu sendiri.\nTentu, tidak ada satu pendekatan yang sempurna untuk setiap situasi. Bagaimana pengalamanmu dalam mengimplementasikan atau mungkin tidak mengimplementasikan prinsip ini? Apakah ada kasus khusus di mana kamu menemukan alternatif yang lebih efektif? Bagikan pengalamanmu di kolom komentar!\n","wordCount":"1503","inLanguage":"en","image":"https://blog.muchlis.dev/img/struct-separation/struct-separation.webp","datePublished":"2025-01-26T00:49:17+08:00","dateModified":"2025-01-26T00:49:17+08:00","author":{"@type":"Person","name":"Muchlis"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.muchlis.dev/post/struct-separation/"},"publisher":{"@type":"Organization","name":"Muchlis Dev","logo":{"@type":"ImageObject","url":"https://blog.muchlis.dev/icon/favicon.ico"}}}</script><link rel=stylesheet href=https://blog.muchlis.dev/css/custom-styles.min.846e2c0c38b3403ffecfec3d9c9b227dcfa79e75b178a91e1a26ae745cf5da5a.css><script src=https://blog.muchlis.dev/js/clickable-image.min.64e4ed1fd2302afde6a6750edcf663d18d6bf3b36d95ac130501827d8732c7a3.js defer></script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.muchlis.dev/ accesskey=h title="Home (Alt + H)"><img src=https://blog.muchlis.dev/icon/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.muchlis.dev/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.muchlis.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.muchlis.dev/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://muchlis.dev title="Portfolio (2021)"><span>Portfolio (2021)</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.muchlis.dev/>Home</a>&nbsp;»&nbsp;<a href=https://blog.muchlis.dev/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Memahami Pentingnya Memisahkan DTO, Entity dan Model dalam Pengembangan Aplikasi</h1><div class=post-description>Bagaimana pemisahan tanggung jawab antar struct (atau class) dapat meningkatkan keamanan, keberlanjutan, dan efisiensi dalam pengembangan aplikasi.</div><div class=post-meta><span title='2025-01-26 00:49:17 +0800 WITA'>January 26, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1503 words&nbsp;·&nbsp;Muchlis&nbsp;|&nbsp;<a href=https://github.com/muchlist/paper/tree/main/content/post/struct-separation.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#memahami-entity-model-dan-dto-dalam-prinsip-domain-driven-design>Memahami Entity, Model dan DTO dalam Prinsip Domain-Driven Design</a></li><li><a href=#mengapa-pemisahan-itu-penting>Mengapa Pemisahan itu Penting?</a><ul><li><a href=#skenario>Skenario</a></li><li><a href=#dampak-tanpa-pemisahan-struct-bad>Dampak Tanpa Pemisahan Struct (bad)</a></li><li><a href=#dampak-dengan-pemisahan-struct-good>Dampak Dengan Pemisahan Struct (good)</a></li></ul></li><li><a href=#trade-offs>Trade-offs</a></li><li><a href=#kapan-sebaiknya-tidak-memisahkan-struct>Kapan Sebaiknya Tidak Memisahkan Struct?</a></li><li><a href=#cara-memisahkan-struct-yang-tepat>Cara Memisahkan Struct yang tepat</a><ul><li><a href=#struct-untuk-lapisan-presentation>Struct untuk Lapisan Presentation:</a></li><li><a href=#struct-untuk-lapisan-domain>Struct untuk Lapisan Domain:</a></li><li><a href=#struct-untuk-lapisan-persistence>Struct untuk Lapisan Persistence:</a></li></ul></li><li><a href=#diagram-implementasi>Diagram Implementasi</a></li><li><a href=#kesimpulan>Kesimpulan</a></li></ul></nav></div></details></div><div class=post-content><p>Dalam pengembangan Aplikasi Golang, sering kali kita temukan satu struct object yang dipakai untuk berbagai keperluan,
seperti representasi data di database sekaligus payload dalam request dan response API.
Meskipun terlihat praktis, pendekatan ini sebenarnya dapat memunculkan masalah terkait keamanan dan pemeliharaan.
Artikel ini akan membahas pentingnya memisahkan DTO, Entity dan Model dengan menerapkan sedikit prinsip Domain-Driven Design (DDD).</p><h2 id=memahami-entity-model-dan-dto-dalam-prinsip-domain-driven-design>Memahami Entity, Model dan DTO dalam Prinsip Domain-Driven Design<a hidden class=anchor aria-hidden=true href=#memahami-entity-model-dan-dto-dalam-prinsip-domain-driven-design>#</a></h2><p>Domain-Driven Design (DDD) adalah metodologi pengembangan perangkat lunak yang berfokus pada pemisahan tanggung jawab melalui pemodelan yang berorientasi pada domain bisnis. Dalam DDD, kita mengenal beberapa konsep penting:</p><ol><li><strong>Data Transfer Object (DTO)</strong> : Digunakan untuk mengirimkan data antar fungsi tanpa melibatkan logika bisnis yang kompleks. Misalnya, struct untuk request, response, dan parameter fungsi.</li><li><strong>Entity</strong> : Digunakan untuk menyimpan data yang akan digunakan dalam logika aplikasi. Sebuah struct disebut entity jika memiliki identitas (seperti ID) yang membedakannya dari data lain. Entity dapat memiliki logika sendiri. Misalnya, entitas Weather yang memiliki metode <code>IsOutdoorEventFeasible()</code> untuk mengevaluasi apakah cuaca cocok untuk acara luar ruang.<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WeatherEntity</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ID</span>          <span class=kt>string</span>   <span class=c1>// misal : Kombinasi Kode Lokasi dan Timestamp</span>
</span></span><span class=line><span class=cl>	<span class=nx>City</span>        <span class=kt>string</span>  
</span></span><span class=line><span class=cl>	<span class=nx>Temperature</span> <span class=kt>float64</span> 
</span></span><span class=line><span class=cl>	<span class=nx>Humidity</span>    <span class=kt>int</span>     
</span></span><span class=line><span class=cl>	<span class=nx>Description</span> <span class=kt>string</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// IsOutdoorEventFeasible mengevaluasi apakah cuaca cocok untuk acara luar ruang.</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>w</span> <span class=o>*</span><span class=nx>WeatherEntity</span><span class=p>)</span> <span class=nf>IsOutdoorEventFeasible</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// acara luar ruang dianggap tidak layak jika:</span>
</span></span><span class=line><span class=cl>	<span class=c1>// - Suhu di bawah 15 derajat Celsius atau di atas 35 derajat Celsius</span>
</span></span><span class=line><span class=cl>	<span class=c1>// - Deskripsi cuaca mengindikasikan hujan atau badai</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>w</span><span class=p>.</span><span class=nx>Temperature</span> <span class=p>&lt;</span> <span class=mi>15</span> <span class=o>||</span> <span class=nx>w</span><span class=p>.</span><span class=nx>Temperature</span> <span class=p>&gt;</span> <span class=mi>35</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>w</span><span class=p>.</span><span class=nx>Description</span> <span class=o>==</span> <span class=s>&#34;rain&#34;</span> <span class=o>||</span> <span class=nx>w</span><span class=p>.</span><span class=nx>Description</span> <span class=o>==</span> <span class=s>&#34;storm&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li><strong>Repository</strong> : Object Repository menyembunyikan detail implementasi penyimpanan data. Sedangkan Struct Model berfungsi sebagai representasi data pada database yang digunakan oleh Repository.</li><li><strong>Application Service</strong> : Menangani logika bisnis yang memerlukan interaksi dengan komponen eksternal atau layanan lainnya, dalam clean architecture ini sering disebut <code>usecase</code> atau <code>service</code>.
Menghandle operasi-operasi yang tidak secara alami cocok dalam konteks Entity atau Value Object.</li></ol><p>Sebenarnya masih banyak yang lain, Misalnya <code>Value Object</code>, <code>Aggregate</code>, <code>Domain-Service</code> dll.
Namun kita ingin agar code kita menjadi &ldquo;cukup-baik untuk maintainability&rdquo;, tetapi juga &ldquo;tidak menjadi terlalu rumit&rdquo;, jadi disini kita agak sedikit longgar dalam penerapan DDD tersebut.</p><h2 id=mengapa-pemisahan-itu-penting>Mengapa Pemisahan itu Penting?<a hidden class=anchor aria-hidden=true href=#mengapa-pemisahan-itu-penting>#</a></h2><p>Menggunakan struct yang sama di berbagai lapisan aplikasi seperti database, logika bisnis, dan presentasi dapat menciptakan keterikatan yang tinggi. Misalnya, perubahan di database (seperti menambahkan kolom baru) dapat memengaruhi API, bahkan jika kolom tersebut tidak relevan untuk pengguna API</p><h3 id=skenario>Skenario<a hidden class=anchor aria-hidden=true href=#skenario>#</a></h3><p>Misalkan kita memiliki aplikasi yang membantu pengguna merencanakan acara berdasarkan prakiraan cuaca. Aplikasi kita menggunakan API cuaca pihak ketiga untuk mendapatkan informasi cuaca terkini.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Weather</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>City</span>        <span class=kt>string</span>    <span class=s>`json:&#34;city&#34; db:&#34;city&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Temperature</span> <span class=kt>float64</span>   <span class=s>`json:&#34;temperature&#34; db:&#34;temperature&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Humidity</span>    <span class=kt>int</span>       <span class=s>`json:&#34;humidity&#34; db:&#34;humidity&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>WindSpeed</span>   <span class=kt>float64</span>   <span class=s>`json:&#34;wind_speed&#34; db:&#34;wind_speed&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Description</span> <span class=kt>string</span>    <span class=s>`json:&#34;description&#34; db:&#34;description&#34;`</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Suatu hari, API cuaca pihak ketiga mengumumkan perubahan pada respons mereka, menambahkan lebih banyak detail seperti airQualityIndex, visibility, dan uvIndex. Bahkan melakukan perubahan major ke versi 2 seperti split temperatur menjadi temperature_celcius dan temperature_kelvin.</p><h3 id=dampak-tanpa-pemisahan-struct-bad>Dampak Tanpa Pemisahan Struct (bad)<a hidden class=anchor aria-hidden=true href=#dampak-tanpa-pemisahan-struct-bad>#</a></h3><p>Jika kita menggunakan Weather struct yang sama untuk menangkap respons dari API, menyimpan data di database, dan juga sebagai respons API kita, perubahan pada API pihak ketiga dapat menyebabkan beberapa masalah berikut:</p><ul><li><strong>Perubahan di Banyak Tempat</strong>: Perubahan di suatu struct artinya juga mengubah database, logika bisnis, dan mungkin juga data yang dikonsumsi oleh frontend.</li><li><strong>Overfetching and Irrelevant Data</strong>: kita mungkin tidak memerlukan semua data tambahan seperti temperature_kelvin atau uvIndex untuk tujuan aplikasi kita, tetapi karena menggunakan struktur yang sama, kita terpaksa menangani data ekstra ini.</li><li><strong>Peningkatan Kompleksitas</strong>: Dengan adanya data baru, kita mungkin memerlukan sedikit modifikasi pada tipe datanya untuk menyesuaikan Tag, Marshaler, Scanners and Valuers.</li></ul><h3 id=dampak-dengan-pemisahan-struct-good>Dampak Dengan Pemisahan Struct (good)<a hidden class=anchor aria-hidden=true href=#dampak-dengan-pemisahan-struct-good>#</a></h3><p>Sebaliknya, dengan memisahkan DTO, Entity, dan Model, kita dapat lebih efisien dalam menangani perubahan ini.</p><p><strong>DTO (Data Transfer Object):</strong><br>Kita membuat struct khusus untuk menangkap respons dari API cuaca yang mencakup semua data baru (atau hanya data relevan).
Membantu kita untuk mengetahui ketersediaan data dari API.<br>Terhadap skenario diatas, kita cukup menyesuaikan dibagian layer API Client saja.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WeatherAPIResponse</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>City</span>                <span class=kt>string</span>  <span class=s>`json:&#34;city&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>TemperatureCelcius</span>  <span class=kt>float64</span> <span class=s>`json:&#34;temperature_celcius&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>TemperatureKelvin</span>   <span class=kt>float64</span> <span class=s>`json:&#34;temperature_kelvin&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Humidity</span>            <span class=kt>int</span>     <span class=s>`json:&#34;humidity&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>WindSpeed</span>           <span class=kt>float64</span> <span class=s>`json:&#34;wind_speed&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Description</span>         <span class=kt>string</span>  <span class=s>`json:&#34;description&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>AirQualityIndex</span>     <span class=kt>int</span>     <span class=s>`json:&#34;airQualityIndex&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Visibility</span>          <span class=kt>int</span>     <span class=s>`json:&#34;visibility&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>UvIndex</span>             <span class=kt>int</span>     <span class=s>`json:&#34;uvIndex&#34;`</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>w</span> <span class=o>*</span><span class=nx>WeatherAPIResponse</span><span class=p>)</span> <span class=nf>ToEntity</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=c1>// transform</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>Entity:</strong><br>Entity Weather dalam aplikasi kita hanya menyimpan data yang relevan untuk fungsi aplikasi, seperti Temperature, Humidity, dan Description. Tidak perlu menyimpan uvIndex atau visibility jika data tersebut tidak digunakan dalam proses perencanaan acara, dengan begitu kita mengetahui data mana yang penting untuk logic dan yang tidak.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WeatherEntity</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ID</span>          <span class=kt>string</span>   <span class=c1>// Kombinasi Kode Lokasi dan Timestamp</span>
</span></span><span class=line><span class=cl>    <span class=nx>City</span>        <span class=kt>string</span>  
</span></span><span class=line><span class=cl>    <span class=nx>Temperature</span> <span class=kt>float64</span> 
</span></span><span class=line><span class=cl>    <span class=nx>Humidity</span>    <span class=kt>int</span>     
</span></span><span class=line><span class=cl>    <span class=nx>Description</span> <span class=kt>string</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// IsOutdoorEventFeasible mengevaluasi apakah cuaca cocok untuk acara luar ruang.</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>w</span> <span class=o>*</span><span class=nx>WeatherEntity</span><span class=p>)</span> <span class=nf>IsOutdoorEventFeasible</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// acara luar ruang dianggap tidak layak jika:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// - Suhu di bawah 15 derajat Celsius atau di atas 35 derajat Celsius</span>
</span></span><span class=line><span class=cl>    <span class=c1>// - Deskripsi cuaca mengindikasikan hujan atau badai</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>w</span><span class=p>.</span><span class=nx>Temperature</span> <span class=p>&lt;</span> <span class=mi>15</span> <span class=o>||</span> <span class=nx>w</span><span class=p>.</span><span class=nx>Temperature</span> <span class=p>&gt;</span> <span class=mi>35</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>w</span><span class=p>.</span><span class=nx>Description</span> <span class=o>==</span> <span class=s>&#34;rain&#34;</span> <span class=o>||</span> <span class=nx>w</span><span class=p>.</span><span class=nx>Description</span> <span class=o>==</span> <span class=s>&#34;storm&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>Logika Bisnis (Usecase Layer):</strong><br>Logika bisnis seharusnya tidak mengenal model database atau response dari API pihak ketiga. Logika bisnis hanya mengolah data yang sudah berupa Entity atau yang kita bisa kontrol kestabilannya. Ini memudahkan pemeliharaan dan mengurangi risiko error.</p><p><strong>Model Database:</strong><br>Untuk keperluan menyimpan ke database gunakan struct tersendiri, khususnya jika menggunkan ORM</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WeatherModel</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ID</span>          <span class=kt>string</span>  <span class=s>`db:&#34;id&#34;`</span>  
</span></span><span class=line><span class=cl>    <span class=nx>City</span>        <span class=kt>string</span>  <span class=s>`db:&#34;city&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Temperature</span> <span class=kt>float64</span> <span class=s>`db:&#34;temperature&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Humidity</span>    <span class=kt>int</span>     <span class=s>`db:&#34;humidity&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Description</span> <span class=kt>string</span>  <span class=s>`db:&#34;description&#34;`</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>w</span> <span class=o>*</span><span class=nx>WeatherModel</span><span class=p>)</span> <span class=nf>ToEntity</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=c1>// transform</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>FromEntity</span><span class=p>(</span><span class=nx>WeatherEntity</span><span class=p>)</span> <span class=nx>WeatherModel</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// transform</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>dan seterusnya untuk <code>WeatherRequestDTO</code> dan <code>WeatherResponseDTO</code>.</p><h2 id=trade-offs>Trade-offs<a hidden class=anchor aria-hidden=true href=#trade-offs>#</a></h2><p>Meskipun pemisahan struktur data seperti DTO (Data Transfer Object), Entity, dan Model database memiliki manfaat jangka panjang seperti keamanan, kemudahan dalam testing, dan separation of concern yang jelas, ada beberapa kekurangan yang perlu dipertimbangkan juga. Salah satu kekurangan utamanya adalah kebutuhan untuk melakukan transformasi antara struct-struct ini, yang berarti ada sedikit pengorbanan kecepatan.</p><p>Namun, pendekatan ini sering dianggap sebagai bayaran-yang-wajar untuk manfaat yang diperoleh. Buku-buku populer seperti Clean Code oleh Robert C. Martin, The Pragmatic Programmer oleh Andrew Hunt dan David Thomas, serta Refactoring: Improving the Design of Existing Code oleh Martin Fowler, sering kali menekankan pentingnya memprioritaskan kode yang benar dan mudah dipelihara sebelum fokus pada kecepatan.</p><p>Lagipula, latensi yang dihasilkan dari transformasi data ini sangat sangat sangat minim jika dibandingkan dengan latensi operasi database, yang cenderung menjadi bottleneck yang lebih signifikan dalam banyak aplikasi.</p><h2 id=kapan-sebaiknya-tidak-memisahkan-struct>Kapan Sebaiknya Tidak Memisahkan Struct?<a hidden class=anchor aria-hidden=true href=#kapan-sebaiknya-tidak-memisahkan-struct>#</a></h2><ul><li>Sistemnya terlalu sederhana.</li><li>Memerlukan kecepatan tinggi seperti dalam pengembangan game.</li><li>Peningkatan peforma sekecil-kecilnya dinilai lebih penting daripada keterbacaan dan kemudahan pemeliharaan.</li></ul><h2 id=cara-memisahkan-struct-yang-tepat>Cara Memisahkan Struct yang tepat<a hidden class=anchor aria-hidden=true href=#cara-memisahkan-struct-yang-tepat>#</a></h2><p>Saya menyarankan pendekatan berikut untuk memisahkan struct golang dalam arsitektur API.
Pendekatan ini memastikan bahwa setiap lapisan dalam aplikasi memiliki tanggung jawab yang jelas dan terpisah, sehingga memudahkan pemeliharaan dan pengembangan di masa mendatang.</p><h3 id=struct-untuk-lapisan-presentation>Struct untuk Lapisan Presentation:<a hidden class=anchor aria-hidden=true href=#struct-untuk-lapisan-presentation>#</a></h3><ul><li>WeatherRequest dan WeatherResponse: Struct ini digunakan untuk menangani data yang masuk dan keluar dari API (presentation). Mereka bertanggung jawab untuk memvalidasi dan memformat data sesuai dengan kebutuhan klien.</li><li>Untuk kasus yang lebih kompleks, seperti fitur partial update, Kamu mungkin memerlukan WeatherUpdateRequest. Versi ini menggunakan field pointer untuk memungkinkan pembaruan sebagian (partial update).</li></ul><h3 id=struct-untuk-lapisan-domain>Struct untuk Lapisan Domain:<a hidden class=anchor aria-hidden=true href=#struct-untuk-lapisan-domain>#</a></h3><ul><li>WeatherEntity: Entity ini mewakili data dalam domain bisnis dan berisi logika yang terkait langsung dengan aturan bisnis. Entity harus stabil dan tidak terpengaruh oleh perubahan di lapisan lain, seperti database atau API eksternal.</li><li>Untuk kasus yang lebih kompleks, seperti fitur partial update, Kamu mungkin memerlukan WeatherUpdateDTO. Versi DTO yang juga menggunakan field pointer untuk fleksibilitas dalam pengiriman data.</li></ul><h3 id=struct-untuk-lapisan-persistence>Struct untuk Lapisan Persistence:<a hidden class=anchor aria-hidden=true href=#struct-untuk-lapisan-persistence>#</a></h3><ul><li>WeatherModel: Struct ini digunakan untuk interaksi dengan database. Model ini mencerminkan skema penyimpanan dan dapat berubah seiring dengan perubahan di layer database.</li></ul><h2 id=diagram-implementasi>Diagram Implementasi<a hidden class=anchor aria-hidden=true href=#diagram-implementasi>#</a></h2><figure><img src=/img/struct-separation/struct-separation.webp alt="struct separation layer" class="clickable-image lazyload" data-src=/img/struct-separation/struct-separation.webp loading=lazy></figure><p>Dengan asumsi menggunakan Clean Architecture atau Hexagonal Architecture, maka :</p><ul><li>Handler Layer mengelola data request dan response, mengubah request ke tipe data internal yang dapat kita kontrol sepenuhnya (entity) sebelum diteruskan ke Usecase.</li><li>Usecase Layer bekerja dengan entity yang stabil, layer ini seharusnya menghindari ketergantungan langsung pada model database atau format API eksternal.</li><li>Repository Layer mengelola akses ke database dan mengubah data ke dan dari entity yang digunakan oleh usecase.</li></ul><p>Pendekatan ini memastikan bahwa setiap lapisan terisolasi dari perubahan yang tidak relevan di lapisan lain, sehingga meningkatkan ketahanan dan fleksibilitas aplikasi.
Dengan memisahkan tanggung jawab di setiap layer, aplikasi menjadi lebih modular, memudahkan pemeliharaan dan skalabilitas.</p><p>Baca juga : <a href=/post/structuring-project-folder>Bagaimana cara menerapkan aturan yang baik untuk menjaga separation of concern</a></p><h2 id=kesimpulan>Kesimpulan<a hidden class=anchor aria-hidden=true href=#kesimpulan>#</a></h2><p>Mengimplementasikan pemisahan struct DTO, Entity dan Model dalam desain API menggunakan Golang merupakan investasi kecil yang bisa menghemat banyak waktu dan
sumber daya untuk pengembangan dan pemeliharaan di masa depan,
membuat sistem kita tidak hanya efisien tapi juga mudah untuk dikelola dan dikembangkan.
Pendekatan ini dapat membagi tanggung jawab tiap komponen secara jelas, mengurangi ketergantungan antar-modul, dan pada akhirnya menguatkan keseluruhan arsitektur aplikasi itu sendiri.</p><p>Tentu, tidak ada satu pendekatan yang sempurna untuk setiap situasi.
Bagaimana pengalamanmu dalam mengimplementasikan atau mungkin tidak mengimplementasikan prinsip ini?
Apakah ada kasus khusus di mana kamu menemukan alternatif yang lebih efektif?
Bagikan pengalamanmu di kolom komentar!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.muchlis.dev/tags/golang/>Golang</a></li><li><a href=https://blog.muchlis.dev/tags/best-practices/>Best Practices</a></li><li><a href=https://blog.muchlis.dev/tags/golang-ddd/>Golang DDD</a></li></ul><nav class=paginav><a class=prev href=https://blog.muchlis.dev/post/money-tracker-app/><span class=title>« Prev</span><br><span>Dari Frustrasi Jadi Solusi: Perjalanan Merilis Kazz, Aplikasi Keuangan Impian Saya</span>
</a><a class=next href=https://blog.muchlis.dev/post/db-transaction/><span class=title>Next »</span><br><span>Teknik Implementasi Database Transaction pada Logic Layer di Backend Golang</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Memahami Pentingnya Memisahkan DTO, Entity dan Model dalam Pengembangan Aplikasi on x" href="https://x.com/intent/tweet/?text=Memahami%20Pentingnya%20Memisahkan%20DTO%2c%20Entity%20dan%20Model%20dalam%20Pengembangan%20Aplikasi&amp;url=https%3a%2f%2fblog.muchlis.dev%2fpost%2fstruct-separation%2f&amp;hashtags=golang%2cBestPractices%2cGolangDDD"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Memahami Pentingnya Memisahkan DTO, Entity dan Model dalam Pengembangan Aplikasi on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.muchlis.dev%2fpost%2fstruct-separation%2f&amp;title=Memahami%20Pentingnya%20Memisahkan%20DTO%2c%20Entity%20dan%20Model%20dalam%20Pengembangan%20Aplikasi&amp;summary=Memahami%20Pentingnya%20Memisahkan%20DTO%2c%20Entity%20dan%20Model%20dalam%20Pengembangan%20Aplikasi&amp;source=https%3a%2f%2fblog.muchlis.dev%2fpost%2fstruct-separation%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Memahami Pentingnya Memisahkan DTO, Entity dan Model dalam Pengembangan Aplikasi on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.muchlis.dev%2fpost%2fstruct-separation%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Memahami Pentingnya Memisahkan DTO, Entity dan Model dalam Pengembangan Aplikasi on whatsapp" href="https://api.whatsapp.com/send?text=Memahami%20Pentingnya%20Memisahkan%20DTO%2c%20Entity%20dan%20Model%20dalam%20Pengembangan%20Aplikasi%20-%20https%3a%2f%2fblog.muchlis.dev%2fpost%2fstruct-separation%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Memahami Pentingnya Memisahkan DTO, Entity dan Model dalam Pengembangan Aplikasi on telegram" href="https://telegram.me/share/url?text=Memahami%20Pentingnya%20Memisahkan%20DTO%2c%20Entity%20dan%20Model%20dalam%20Pengembangan%20Aplikasi&amp;url=https%3a%2f%2fblog.muchlis.dev%2fpost%2fstruct-separation%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=muchlist/paper data-repo-id=R_kgDOMD4syA data-category=General data-category-id=DIC_kwDOMD4syM4ChOKX data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=id data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.muchlis.dev/>Muchlis Dev</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>