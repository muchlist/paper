<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Optimisasi Pagination: Mengapa Limit-Offset Bisa Menjadi Bom Waktu dan Cursor Pagination Menjadi Solusinya | Muchlis Dev</title>
<meta name=keywords content="Golang,Database,Optimization,Best Practice"><meta name=description content="Membandingkan metode paling optimal dalam penerapan pagination pada backend golang. Implementasi Cursor Based Pagination."><meta name=author content="Muchlis"><link rel=canonical href=https://blog.muchlis.dev/post/pagination/><meta name=google-site-verification content="G-F1ZZCKLSJF"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.muchlis.dev/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.muchlis.dev/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.muchlis.dev/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.muchlis.dev/icon/apple-touch-icon.png><link rel=mask-icon href=https://blog.muchlis.dev/icon/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.muchlis.dev/post/pagination/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F1ZZCKLSJF"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F1ZZCKLSJF")}</script><meta property="og:title" content="Optimisasi Pagination: Mengapa Limit-Offset Bisa Menjadi Bom Waktu dan Cursor Pagination Menjadi Solusinya"><meta property="og:description" content="Membandingkan metode paling optimal dalam penerapan pagination pada backend golang. Implementasi Cursor Based Pagination."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.muchlis.dev/post/pagination/"><meta property="og:image" content="https://blog.muchlis.dev/img/pagination/pagination-performance.webp"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-08-11T13:57:10+08:00"><meta property="article:modified_time" content="2024-08-11T13:57:10+08:00"><meta property="og:site_name" content="Muchlis Dev"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.muchlis.dev/img/pagination/pagination-performance.webp"><meta name=twitter:title content="Optimisasi Pagination: Mengapa Limit-Offset Bisa Menjadi Bom Waktu dan Cursor Pagination Menjadi Solusinya"><meta name=twitter:description content="Membandingkan metode paling optimal dalam penerapan pagination pada backend golang. Implementasi Cursor Based Pagination."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.muchlis.dev/post/"},{"@type":"ListItem","position":2,"name":"Optimisasi Pagination: Mengapa Limit-Offset Bisa Menjadi Bom Waktu dan Cursor Pagination Menjadi Solusinya","item":"https://blog.muchlis.dev/post/pagination/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Optimisasi Pagination: Mengapa Limit-Offset Bisa Menjadi Bom Waktu dan Cursor Pagination Menjadi Solusinya","name":"Optimisasi Pagination: Mengapa Limit-Offset Bisa Menjadi Bom Waktu dan Cursor Pagination Menjadi Solusinya","description":"Membandingkan metode paling optimal dalam penerapan pagination pada backend golang. Implementasi Cursor Based Pagination.","keywords":["Golang","Database","Optimization","Best Practice"],"articleBody":"Pagination adalah teknik dalam membagi hasil query database menjadi bagian-bagian yang lebih kecil. Menggunakan Query LIMIT OFFSET adalah metode yang paling umum digunakan. Namun, metode ini ternyata memiliki beberapa kelemahan, terutama dalam hal performa pada dataset yang sangat besar. Artikel ini akan membahas masalah-masalah yang akan muncul saat menggunakan LIMIT OFFSET dan mengeksplorasi alternatif yang lebih efisien, seperti cursor-based pagination dan seek method.\nPentingnya Pagination dan Tantangannya Pagination memiliki beberapa manfaat, seperti:\nMenjaga Performance: Mengembalikan data yang besar sekaligus itu lambat dan memakan banyak sumber daya. Dengan membagi data menjadi potongan-potongan yang lebih kecil, API bisa mengembalikan data lebih cepat dan dengan sumber daya yang lebih sedikit. Memproses data yang besar juga memerlukan banyak memori, yang bisa menjadi masalah untuk perangkat dengan sumber daya terbatas seperti ponsel. Dengan menggunakan pagination, API dapat membatasi jumlah data yang perlu disimpan dalam memori pada suatu waktu.\nUser Experience: Untuk aplikasi klien yang menampilkan data kepada user, pagination dapat meningkatkan pengalaman user dengan menyediakan antarmuka yang lebih cepat dan responsif. User dapat melihat hasil awal dengan cepat dan dapat meminta data tambahan sesuai kebutuhan.\nNamun, penting untuk diingat bahwa pagination tidak selalu menjadi solusi yang sempurna. Pada dataset yang sangat besar, teknik pagination dapat menghadapi tantangan yang akan menjadi sangat fatal dikemudian hari.\nLIMIT OFFSET Pagination Disini kita akan bahas kekurangan dari cara pagination menggunakan LIMIT OFFSET dan bagaimana cara meminimalisir kekurangan tersebut.\nMengapa LIMIT OFFSET Lambat untuk Dataset yang Besar? Saat berhadapan dengan dataset yang sangat besar, pagination menggunakan LIMIT OFFSET seringkali mengalami penurunan performa. Ini karena setiap kali kita meminta halaman baru, database harus memindai seluruh tabel dari awal untuk menemukan data yang sesuai, meskipun kita hanya membutuhkan sebagian kecil data.\nBerikut adalah contoh query SQL yang menunjukkan bagaimana LIMIT dan OFFSET diterapkan:\nSELECT * FROM records ORDER BY id LIMIT 10 OFFSET 1000; Penjelasan:\nLIMIT menentukan jumlah maksimal baris yang dikembalikan.\nOFFSET menentukan berapa banyak baris yang harus skip sebelum mulai mengembalikan hasil.\nPada contoh di atas, query tersebut sebenarnya akan memindai 1000 baris pertama, membuang data yang tidak diperlukan, dan mengembalikan 10 baris berikutnya. Jika tabel memiliki jutaan baris, melewati sejumlah besar baris dengan offset yang besar akan membuat query berjalan lebih lambat karena database harus mengurutkan dan memindai semua baris tersebut sebelum mengembalikan hasil.\nArtinya jika klien melakukan permintaaan page 2, page 3 dan seterusnya maka akan menyebabkan database harus memproses berkali-kali lipat data dibandingkan dengan jumlah yang sebenarnya dikembalikan kepada klien.\nSebagai ilustrasi, asumsi jika 1 halaman menampilkan 100 data:\nUntuk page 1: OFFSET 0, LIMIT 100 -\u003e memindai dan mengembalikan 100 baris. Untuk page 2: OFFSET 100, LIMIT 100 -\u003e memindai dan membuang 100 baris, kemudian memindai dan mengembalikan 100 baris berikutnya. Untuk page 3: OFFSET 200, LIMIT 100 -\u003e memindai dan membuang 200 baris, kemudian memindai dan mengembalikan 100 baris berikutnya. Untuk page 100: OFFSET 10000, LIMIT 100 -\u003e memindai dan membuang 10000 baris, kemudian memindai dan mengembalikan 100 baris berikutnya. Semakin besar nilai offset, semakin banyak baris yang perlu dipindai dan dibuang, yang membuat query semakin lambat dan tidak efisien. Ini menjadi sangat buruk untuk tabel dengan jutaan baris karena memproses dan membuang banyak data setiap kali ada permintaan halaman baru.\nContoh worst case untuk ini : Client ingin mendapatkan semua data dengan cara melakukan scan dari page 1 sampai dengan page terakhir. melihat behaviornya, hal ini biasanya diperlukan oleh service.\nBayangkan kita ingin membaca sebuah buku yang sangat tebal halaman demi halaman. Jika kita menggunakan metode LIMIT dan OFFSET, kita harus membuka buku dari awal setiap kali ingin membaca halaman berikutnya. Ini tentu sangat tidak efisien, karena kita akan mengulang-ulang membuka halaman yang sama. Dalam konteks database, hal ini sama dengan membuat database bekerja lebih keras dari yang seharusnya. Oleh karena itu, jika tujuannya adalah mendapatkan semua data, lebih baik kita langsung mengambil seluruh buku (data) sekaligus tanpa pagination, lalu membacanya (memprosesnya) di aplikasi.\nDampak Query COUNT(*) terhadap Performa Tidak hanya itu, dalam implementasi pagination menggunakan LIMIT dan OFFSET, query COUNT(*) sering digunakan untuk menghitung jumlah total baris dalam dataset. Informasi ini diperlukan untuk menyusun metadata pagination, seperti jumlah total halaman dan jumlah total item, yang kemudian dikembalikan dalam respon API.\nSebagai contoh, respon API mungkin memiliki struktur sebagai berikut:\n{ \"message\": \"successfully fetch data\", \"data\": [ {} ], \"meta\": { \"current_page\": 1, \"page_size\": 100, \"total_count\": 3000, \"total_page\": 30 }, \"trace_id\": \"5b427ba9ab30002d347ea17cf8000cca\" } Untuk menghasilkan metadata ini, backend perlu melakukan dua query:\nUntuk mengambil data dengan LIMIT dan OFFSET SELECT * FROM users LIMIT 100 OFFSET 0; Untuk menghitung jumlah total baris dengan COUNT(*) SELECT COUNT(*) FROM users; Kejutannya, Penggunaan COUNT(*) pada dataset yang besar dapat mengakibatkan penurunan performa yang signifikan. Hal ini dikarenakan:\nFull table scan: Database perlu memindai seluruh tabel untuk menghitung jumlah baris, terutama jika tidak ada indeks yang sesuai. Kurangnya optimasi indeks: COUNT(*) seringkali tidak dapat dioptimalkan dengan indeks, sehingga waktu eksekusi query menjadi lebih lama. Masalah concurency dan locking: Query COUNT(*) dapat menyebabkan lock dengan query lain dan menghambat kinerja sistem. Beban I/O yang tinggi: Proses penghitungan jumlah baris memerlukan banyak operasi baca-tulis pada disk database. Masalah ini mungkin tidak terlihat jelas pada awal pengembangan, tetapi akan semakin terasa ketika volume data terus bertambah. Dalam kasus saya, perubahan ini tidak gampang untuk dilakukan karena API sudah terlanjur dikonsumsi service lainnya, maka dari itu saya sangat merekomendasikan agar dapat menentukannya teknik pagination yang paling sesuai sejak awal pengembangan. Teknik alternatif dan optimasi dapat menjadi solusi yang baik untuk mengatasinya.\nOptimasi Database Query LIMIT OFFSET Ternyata query untuk pagination dengan LIMIT OFFSET masih dapat dioptimalkan. Bagaimana caranya ? Teknik ini justru saya temukan di library yang digunakan pada bahasa lain, PHP Laravel. yang dapat dicontoh pada library ini : https://github.com/hammerstonedev/fast-paginate Apa yang dilakukan untuk membuat peformanya menjadi lebih baik ?\nselect * from users -- The full data that you want to show your users. where users.id in ( -- The \"deferred join\" or subquery, in our case. select id from users -- The pagination, accessing as little data as possible - ID only. limit 15 offset 150000 ) Idenya adalah agar melakukan penerapan LIMIT dan OFFSET pada data yang scopenya lebih kecil, baru kemudian hasilnya dicari untuk membuat data yang lengkap.\nNamun query SELECT COUNT(*) belum tentu dapat dioptimalkan. Jadi, teknik optimasi pada query LIMIT OFFSET ini tidak sepenuhnya menyelesaikan masalah yang saya alami, terutama untuk query SELECT COUNT(*) pada dataset besar. Hal ini terlihat pada hasil monitoring yang saya lakukan.\nHasil monitoring menunjukkan perbedaan kinerja yang signifikan antara query untuk mengambil data vs query COUNT(*), Khususnya ketika banyak request yang masuk secara bersamaan.\nHal ini juga didukung oleh problem-problem serupa yang dibahas di internet seperti :\nhttps://stackoverflow.com/questions/55018986/postgresql-select-count-query-takes-long-time https://www.reddit.com/r/PostgreSQL/comments/140b4xy/select_count_is_slow_in_large_tables/ https://tunghatbh.medium.com/postgresql-slow-count-query-c93c30792606 Dari studi kasus ini, saya menarik beberapa kesimpulan penting:\nJumlah N query tidak selalu menentukan kinerja: Tidak selalu benar bahwa semakin sedikit jumlah permintaan query yang kita jalankan, semakin baik performanya. Dalam beberapa kasus, membagi query kompleks menjadi beberapa query yang lebih kecil justru dapat meningkatkan kinerja secara keseluruhan. Indeks tidak selalu optimal untuk COUNT(*): Meskipun indeks dapat meningkatkan kinerja query secara umum, pada kasus COUNT(*) indeks tidak selalu efektif. Pentingnya benchmarking: Membandingkan kinerja sebelum dan sesudah perubahan query adalah cara yang paling akurat untuk mengukur dampak dari suatu optimasi. Karena beda query dan struktur datanya, bisa jadi memerlukan cara optimasi yang berbeda pula. Cursor ! Sebagai Alternatif dari Limit Offset Penjelasan Cursor-based Pagination Cursor-based pagination menggunakan nilai unik dari suatu kolom (biasanya kolom yang diurutkan) sebagai “cursor” untuk menandai posisi saat ini dalam hasil query. Alih-alih menggunakan offset, kita mengirimkan cursor dari hasil sebelumnya untuk mendapatkan halaman berikutnya. Ini lebih efisien karena database dapat melompati nilai dan hanya perlu mencari rekaman yang memiliki nilai cursor lebih besar dari nilai cursor sebelumnya.\nSELECT * FROM users WHERE sort_column \u003e 'cursor_value' ORDER BY sort_column LIMIT 10; Kelebihan Cursor-based Pagination Performa lebih baik: Tidak perlu memindai seluruh tabel untuk setiap permintaan halaman. Hasil yang konsisten: Hasil query selalu sama, terlepas dari perubahan data yang terjadi di antara permintaan. Misalnya pagination pada LIMIT OFFSET akan tidak konsisten jika data pada halaman sebelumnya ada yang dihapus. UX infinity Loading: Cursor pagination sangat cocok untuk user experience web dan mobile yang biasanya menerapkan infinity loading. Kekurangan Cursor-based Pagination Implementasi lebih kompleks: Membutuhkan perencanaan yang matang dalam memilih kolom cursor yang tepat. Tidak cocok untuk semua jenis query dan UX: Hanya efektif untuk query yang diurutkan berdasarkan satu atau beberapa kolom. Statefull: Karna harus meneruskan cursor Sorting menyatu dengan cursor: Bahwa urutan data yang ditampilkan selalu berbanding lurus dengan cursor yang digunakan. Contoh Implementasi Sebagai contoh, respon API dengan cursor pagination mungkin memiliki struktur sebagai berikut:\nEndpoint : {baseURL}/users?limit=3\u0026cursor= Query Param : limit: jumlah data yang ditampilkan. cursor: inputan cursor, untuk halaman pertama di isi kosong. cursor_type: field apa yang dijadikan cursor, biasanya memiliki default value, dalam contoh ini menggunakan ulid descending. { \"message\": \"successfully fetch data\", \"data\": [ { \"ulid\": \"01J4EXF94RZA4AZG1C0A0C2RKF\", \"name\": \"muchlis\" }, { \"ulid\": \"01J4EXF94RWZVWS9NVEZMQ3R1N\", \"name\": \"monkey d luffy\" }, { \"ulid\": \"01J4EXF94RT7G5CRH047MC0EF1\", \"name\": \"portgas d ace\" } ], \"meta\": { \"current_cursor\": \"\", \"next_cursor\": \"01J4EXF94RT7G5CRH047MC0EF1\", \"next_page\": \"/users?limit=3\u0026cursor=01J4EXF94RT7G5CRH047MC0EF1\", \"prev_cursor\": \"\", \"prev_page\": \"/users?limit=3\u0026cursor=\" }, \"trace_id\": \"5b427ba9ab30002d347ea17cf8000cca\" } Repo Layer :\nSaya menggunakan raw query demi keterbacaan yang lebih mudah. Namun di kenyataan saya bisanya menggunakan sql builder seperti golang squirell atau goqu.\nfunc (r *repo) FetchUserByUlid(ctx context.Context, cursorID string, limit uint64) ([]entity.User, error) { ctx, cancel := context.WithTimeout(ctx, 2*time.Second) defer cancel() var sqlStatement string var args []interface{} if cursorID != \"\" { sqlStatement = ` SELECT id, name FROM users WHERE id \u003c $1 ORDER BY id DESC LIMIT $2; ` args = append(args, cursorID, limit) } else { sqlStatement = ` SELECT id, name FROM users ORDER BY id DESC LIMIT $1; ` args = append(args, limit) } // Execute the query rows, err := r.db.Query(ctx, sqlStatement, args...) if err != nil { return nil, fmt.Errorf(\"failed to execute query: %w\", err) } defer rows.Close() users := make([]entity.User, 0) // [SKIP] Parse the results // [SKIP] Check for errors after iterating over rows return users, nil } Service Layer :\nPada service layer, terdapat logic dimana kita harus mendapatkan data lebih daripada yang akan ditampilkan untuk mengetahui apakah data selanjutnya itu ada atau tidak.\nfunc (s *Service) FetchAllUsersWithCursor(ctx context.Context, cursor string, limit uint64) ([]entity.User, *string /*next cursor*/, error) { // [SKIP] validation, tracer dan sebagainya // Panggil repo layer untuk mengambil data // Menambahkan Limit +1 sehingga kita tau ada data lanjutan atau tidak // Data berlebih ini akan dibuang kemudian results, err := s.repo.FetchUserByUlid(ctx, cursor, limit+1) if err != nil { return nil, nil, fmt.Errorf(\"error FetchUserByUlid: %w\", err) } // Menentukan cursor selanjutnya var nextCursor *string if len(results) \u003e int(limit) { nextCursorID := results[limit-1].ID // Set cursor apabila ditemukan data lebih dari limit nextCursor = \u0026nextCursorID results = results[:limit] // Hapus data yang kelebihan } else { nextCursor = nil // Jika tidak ada kelebihan data, cursor selanjutnya diset nil } // [SKIP] Konversi hasil return results, nextCursor, nil } Dengan asumsi menggunakan Clean Architecture atau Hexagonal Architecture\n+-------------------------------------+ | HTTP Handler | | (Handling HTTP requests and | | responses, routing, etc.) | +----------------+--------------------+ | v +----------------+--------------------+ | Service | | (Business logic, orchestrating the | | application flow, validation, | | calling Repositories) | +----------------+--------------------+ | v +----------------+--------------------+ | Repository | | (Data access layer, interacting with| | the database, etc.) | +-------------------------------------+ Pada contoh code di atas tersisa layer HTTP Handler yang bertugas sebagai View, dimana layer tersebut yang bertanggung jawab membuat value-value lain hasil dari proses layer service seperti menyimpan sementara current_cursor, membuat nilai next_page dari return value FetchAllUsersWithCursor() dan berbagai value lain untuk response yang memerlukan Framework HTTP Handler.\nTadi adalah contoh implementasi cursor pagination yang disederhanakan sehingga kita mendapatkan sedikit gambaran tentang kerumitannya. Pun pada code diatas saya sengaja melewatkan beberapa hal berikut karena bersifat optional.\nPrevious_Page memerlukan implementasi yang berkebalikan pada Query SQL. Alih alih menggunakan cursor dan order default WHERE id \u003c $1 ORDER BY id DESC, menjadi WHERE id \u003e $1 ORDER BY id ASC dengan cursor adalah value pertama dari data yang ditampilkan pada current page. Adanya kemungkinan cursor dan urutan yang memerlukan 2 key bahkan lebih. Validasi value yang lebih ketat untuk tipe Cursor dan OrderBy. Benchmark : Analisis:\nLimit-Offset Pagination memiliki waktu respon yang mulai meningkat signifikan setelah halaman ke-50 (artinya di kedalaman data 50_000), menunjukkan skala yang buruk untuk dataset besar. Limit-Offset + Query Count Pagination (dijalankan bersamaan dengan goroutine) Sedikit lebih lambat dari Limit-Offset biasa, yang menunjukkan adanya overhead tambahan. Overhead tambahan dari count ini akan terasa ketika request dijalankan secara paralel. Sedangkan pengujian diatas dilakukan secara sequensial. Cursor Pagination paling efisien dan stabil, cocok untuk dataset besar dengan jumlah halaman yang banyak. Catatan :\nKomparasi ini membandingkan semua metode menggunakan spesifikasi dan kondisi yang seragam. Latensi jaringan, struktur dan jumlah data dapat mempengaruhi hasil. Jadi, cukup berpatokan pada perbandingannya saja, karena angkanya akan sangat bervariasi tergantung kondisi masing-masing. Data yang digunakan mencakup 100_000 entri data user yang di left-join kan dengan 2 table kecil dengan percobaan pagination ekstrem pada 1_000 entri per halaman. Pengujian dilakukan secara sequensial, page per page. Pengujian ini tidak menyertakan faktor lain yang sebenarnya penting seperti penggunaan memori, CPU, Row yang dikomputasi pada database. Disini saya berusaha membuat effort seminimal mungkin. Secara teori saja sebenarnya kita dapat memperkirakan metode mana yang lebih unggul. Benchmark ini mengonfirmasi hal tersebut. Limit-Offset Pagination memiliki keunggulan berupa kemudahan implementasi, dengan kelemahan yang hanya akan dirasakan ketika aplikasi kita mencapai level dimana jumlah data menjadi sangat besar. Kelemahan ini juga bisa diatasi dengan cara memberikan indexed range data yang sudah ditentukan kepada user (seperti saat menampilkan data transaksi bank yang wajib menentukan bulannya).\nDi sisi lain, walaupun lebih cepat dan stabil, Cursor-Based Pagination sedikit lebih rumit untuk diimplementasikan dan memiliki keterbatasan tertentu yang mungkin membuatnya kurang cocok untuk semua jenis kasus.\nPepatah premature optimization is the root of all evil mengingatkan kita bahwa optimasi yang terlalu dini bisa menjadi masalah, namun disini menurut saya pribadi, menghindari kesalahan sejak awal bukan berarti hal yang buruk juga. Justru, mengambil keputusan arsitektur dan desain yang optimal, seperti memilih Cursor-Based Pagination daripada Limit-Offset, dapat dianggap sebagai pengambilan keputusan yang bijak, bukan sekadar premature optimization. Pada intinya, memahami trade-off dari setiap pilihan dan memilih solusi yang tepat untuk kebutuhan spesifik adalah pendekatan yang lebih tepat dalam pengembangan perangkat lunak.\n","wordCount":"2364","inLanguage":"en","image":"https://blog.muchlis.dev/img/pagination/pagination-performance.webp","datePublished":"2024-08-11T13:57:10+08:00","dateModified":"2024-08-11T13:57:10+08:00","author":{"@type":"Person","name":"Muchlis"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.muchlis.dev/post/pagination/"},"publisher":{"@type":"Organization","name":"Muchlis Dev","logo":{"@type":"ImageObject","url":"https://blog.muchlis.dev/icon/favicon.ico"}}}</script><link rel=stylesheet href=https://blog.muchlis.dev/css/custom-styles.min.846e2c0c38b3403ffecfec3d9c9b227dcfa79e75b178a91e1a26ae745cf5da5a.css><script src=https://blog.muchlis.dev/js/clickable-image.min.64e4ed1fd2302afde6a6750edcf663d18d6bf3b36d95ac130501827d8732c7a3.js defer></script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.muchlis.dev/ accesskey=h title="Home (Alt + H)"><img src=https://blog.muchlis.dev/icon/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.muchlis.dev/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.muchlis.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.muchlis.dev/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://muchlis.dev title="Portfolio (2021)"><span>Portfolio (2021)</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.muchlis.dev/>Home</a>&nbsp;»&nbsp;<a href=https://blog.muchlis.dev/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Optimisasi Pagination: Mengapa Limit-Offset Bisa Menjadi Bom Waktu dan Cursor Pagination Menjadi Solusinya</h1><div class=post-description>Membandingkan metode paling optimal dalam penerapan pagination pada backend golang. Implementasi Cursor Based Pagination.</div><div class=post-meta><span title='2024-08-11 13:57:10 +0800 WITA'>August 11, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2364 words&nbsp;·&nbsp;Muchlis&nbsp;|&nbsp;<a href=https://github.com/muchlist/paper/tree/main/content/post/pagination.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#pentingnya-pagination-dan-tantangannya>Pentingnya Pagination dan Tantangannya</a></li><li><a href=#limit-offset-pagination>LIMIT OFFSET Pagination</a><ul><li><a href=#mengapa-limit-offset-lambat-untuk-dataset-yang-besar>Mengapa LIMIT OFFSET Lambat untuk Dataset yang Besar?</a></li><li><a href=#dampak-query-count-terhadap-performa>Dampak Query COUNT(*) terhadap Performa</a></li><li><a href=#optimasi-database-query-limit-offset>Optimasi Database Query LIMIT OFFSET</a></li></ul></li><li><a href=#cursor--sebagai-alternatif-dari-limit-offset>Cursor ! Sebagai Alternatif dari Limit Offset</a><ul><li><a href=#penjelasan-cursor-based-pagination>Penjelasan Cursor-based Pagination</a></li><li><a href=#contoh-implementasi>Contoh Implementasi</a></li><li><a href=#benchmark->Benchmark :</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>Pagination adalah teknik dalam membagi hasil query database menjadi bagian-bagian yang lebih kecil. Menggunakan Query LIMIT OFFSET adalah metode yang paling umum digunakan. Namun, metode ini ternyata memiliki beberapa kelemahan, terutama dalam hal performa pada dataset yang sangat besar. Artikel ini akan membahas masalah-masalah yang akan muncul saat menggunakan LIMIT OFFSET dan mengeksplorasi alternatif yang lebih efisien, seperti cursor-based pagination dan seek method.</p><h2 id=pentingnya-pagination-dan-tantangannya>Pentingnya Pagination dan Tantangannya<a hidden class=anchor aria-hidden=true href=#pentingnya-pagination-dan-tantangannya>#</a></h2><p>Pagination memiliki beberapa manfaat, seperti:</p><ul><li><p>Menjaga Performance: Mengembalikan data yang besar sekaligus itu lambat dan memakan banyak sumber daya. Dengan membagi data menjadi potongan-potongan yang lebih kecil, API bisa mengembalikan data lebih cepat dan dengan sumber daya yang lebih sedikit. Memproses data yang besar juga memerlukan banyak memori, yang bisa menjadi masalah untuk perangkat dengan sumber daya terbatas seperti ponsel. Dengan menggunakan pagination, API dapat membatasi jumlah data yang perlu disimpan dalam memori pada suatu waktu.</p></li><li><p>User Experience: Untuk aplikasi klien yang menampilkan data kepada user, pagination dapat meningkatkan pengalaman user dengan menyediakan antarmuka yang lebih cepat dan responsif. User dapat melihat hasil awal dengan cepat dan dapat meminta data tambahan sesuai kebutuhan.</p></li></ul><p>Namun, penting untuk diingat bahwa pagination tidak selalu menjadi solusi yang sempurna. Pada dataset yang sangat besar, teknik pagination dapat menghadapi tantangan yang akan menjadi sangat fatal dikemudian hari.</p><h2 id=limit-offset-pagination>LIMIT OFFSET Pagination<a hidden class=anchor aria-hidden=true href=#limit-offset-pagination>#</a></h2><p>Disini kita akan bahas kekurangan dari cara pagination menggunakan LIMIT OFFSET dan bagaimana cara meminimalisir kekurangan tersebut.</p><h3 id=mengapa-limit-offset-lambat-untuk-dataset-yang-besar>Mengapa LIMIT OFFSET Lambat untuk Dataset yang Besar?<a hidden class=anchor aria-hidden=true href=#mengapa-limit-offset-lambat-untuk-dataset-yang-besar>#</a></h3><p>Saat berhadapan dengan dataset yang sangat besar, pagination menggunakan LIMIT OFFSET seringkali mengalami penurunan performa. Ini karena setiap kali kita meminta halaman baru, database harus memindai seluruh tabel dari awal untuk menemukan data yang sesuai, meskipun kita hanya membutuhkan sebagian kecil data.</p><p>Berikut adalah contoh query SQL yang menunjukkan bagaimana LIMIT dan OFFSET diterapkan:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>records</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>LIMIT</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=k>OFFSET</span><span class=w> </span><span class=mi>1000</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>Penjelasan:</p><p><code>LIMIT</code> menentukan jumlah maksimal baris yang dikembalikan.<br><code>OFFSET</code> menentukan berapa banyak baris yang harus skip sebelum mulai mengembalikan hasil.</p><p>Pada contoh di atas, query tersebut sebenarnya akan memindai 1000 baris pertama, membuang data yang tidak diperlukan, dan mengembalikan 10 baris berikutnya. Jika tabel memiliki jutaan baris, melewati sejumlah besar baris dengan offset yang besar akan membuat query berjalan lebih lambat karena database harus mengurutkan dan memindai semua baris tersebut sebelum mengembalikan hasil.</p><p>Artinya jika klien melakukan permintaaan page 2, page 3 dan seterusnya maka akan menyebabkan database harus memproses berkali-kali lipat data dibandingkan dengan jumlah yang sebenarnya dikembalikan kepada klien.</p><p>Sebagai ilustrasi, asumsi jika 1 halaman menampilkan 100 data:</p><ul><li><code>Untuk page 1: OFFSET 0, LIMIT 100</code> -> memindai dan mengembalikan 100 baris.</li><li><code>Untuk page 2: OFFSET 100, LIMIT 100</code> -> memindai dan membuang 100 baris, kemudian memindai dan mengembalikan 100 baris berikutnya.</li><li><code>Untuk page 3: OFFSET 200, LIMIT 100</code> -> memindai dan membuang 200 baris, kemudian memindai dan mengembalikan 100 baris berikutnya.</li><li><code>Untuk page 100: OFFSET 10000, LIMIT 100</code> -> memindai dan membuang 10000 baris, kemudian memindai dan mengembalikan 100 baris berikutnya.</li></ul><p>Semakin besar nilai offset, semakin banyak baris yang perlu dipindai dan dibuang, yang membuat query semakin lambat dan tidak efisien. Ini menjadi sangat buruk untuk tabel dengan jutaan baris karena memproses dan membuang banyak data setiap kali ada permintaan halaman baru.</p><p>Contoh worst case untuk ini : Client ingin mendapatkan semua data dengan cara melakukan scan dari page 1 sampai dengan page terakhir. melihat behaviornya, hal ini biasanya diperlukan oleh service.</p><p>Bayangkan kita ingin membaca sebuah buku yang sangat tebal halaman demi halaman. Jika kita menggunakan metode LIMIT dan OFFSET, kita harus membuka buku dari awal setiap kali ingin membaca halaman berikutnya. Ini tentu sangat tidak efisien, karena kita akan mengulang-ulang membuka halaman yang sama. Dalam konteks database, hal ini sama dengan membuat database bekerja lebih keras dari yang seharusnya. Oleh karena itu, jika tujuannya adalah mendapatkan <code>semua data</code>, lebih baik kita langsung mengambil seluruh buku (data) sekaligus tanpa pagination, lalu membacanya (memprosesnya) di aplikasi.</p><h3 id=dampak-query-count-terhadap-performa>Dampak Query COUNT(*) terhadap Performa<a hidden class=anchor aria-hidden=true href=#dampak-query-count-terhadap-performa>#</a></h3><p>Tidak hanya itu, dalam implementasi pagination menggunakan LIMIT dan OFFSET, query COUNT(*) sering digunakan untuk menghitung jumlah total baris dalam dataset. Informasi ini diperlukan untuk menyusun metadata pagination, seperti jumlah total halaman dan jumlah total item, yang kemudian dikembalikan dalam respon API.</p><p>Sebagai contoh, respon API mungkin memiliki struktur sebagai berikut:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;message&#34;</span><span class=p>:</span> <span class=s2>&#34;successfully fetch data&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;data&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;meta&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;current_page&#34;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;page_size&#34;</span><span class=p>:</span> <span class=mi>100</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;total_count&#34;</span><span class=p>:</span> <span class=mi>3000</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;total_page&#34;</span><span class=p>:</span> <span class=mi>30</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;trace_id&#34;</span><span class=p>:</span> <span class=s2>&#34;5b427ba9ab30002d347ea17cf8000cca&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Untuk menghasilkan metadata ini, backend perlu melakukan dua query:</p><ol><li>Untuk mengambil data dengan LIMIT dan OFFSET</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>users</span><span class=w> </span><span class=k>LIMIT</span><span class=w> </span><span class=mi>100</span><span class=w> </span><span class=k>OFFSET</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><ol start=2><li>Untuk menghitung jumlah total baris dengan COUNT(*)</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>users</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>Kejutannya, Penggunaan COUNT(*) pada dataset yang besar dapat mengakibatkan penurunan performa yang signifikan. Hal ini dikarenakan:</p><ul><li><code>Full table scan</code>: Database perlu memindai seluruh tabel untuk menghitung jumlah baris, terutama jika tidak ada indeks yang sesuai.</li><li><code>Kurangnya optimasi indeks</code>: COUNT(*) seringkali tidak dapat dioptimalkan dengan indeks, sehingga waktu eksekusi query menjadi lebih lama.</li><li><code>Masalah concurency dan locking</code>: Query COUNT(*) dapat menyebabkan lock dengan query lain dan menghambat kinerja sistem.</li><li><code>Beban I/O yang tinggi</code>: Proses penghitungan jumlah baris memerlukan banyak operasi baca-tulis pada disk database.</li></ul><p>Masalah ini mungkin tidak terlihat jelas pada awal pengembangan, tetapi akan semakin terasa ketika volume data terus bertambah. Dalam kasus saya, perubahan ini tidak gampang untuk dilakukan karena API sudah terlanjur dikonsumsi service lainnya, maka dari itu saya sangat merekomendasikan agar dapat menentukannya teknik pagination yang paling sesuai sejak awal pengembangan. Teknik alternatif dan optimasi dapat menjadi solusi yang baik untuk mengatasinya.</p><h3 id=optimasi-database-query-limit-offset>Optimasi Database Query LIMIT OFFSET<a hidden class=anchor aria-hidden=true href=#optimasi-database-query-limit-offset>#</a></h3><p>Ternyata query untuk pagination dengan LIMIT OFFSET masih dapat dioptimalkan. Bagaimana caranya ?
Teknik ini justru saya temukan di library yang digunakan pada bahasa lain, PHP Laravel. yang dapat dicontoh pada library ini : <a href=https://github.com/hammerstonedev/fast-paginate>https://github.com/hammerstonedev/fast-paginate</a>
Apa yang dilakukan untuk membuat peformanya menjadi lebih baik ?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>users</span><span class=w>              </span><span class=c1>-- The full data that you want to show your users.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>where</span><span class=w> </span><span class=n>users</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=p>(</span><span class=w>          </span><span class=c1>-- The &#34;deferred join&#34; or subquery, in our case.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=k>select</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>users</span><span class=w>     </span><span class=c1>-- The pagination, accessing as little data as possible - ID only.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=k>limit</span><span class=w> </span><span class=mi>15</span><span class=w> </span><span class=k>offset</span><span class=w> </span><span class=mi>150000</span><span class=w>      
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><p>Idenya adalah agar melakukan penerapan LIMIT dan OFFSET pada data yang scopenya lebih kecil, baru kemudian hasilnya dicari untuk membuat data yang lengkap.</p><p>Namun query <code>SELECT COUNT(*)</code> belum tentu dapat dioptimalkan. Jadi, teknik optimasi pada query <code>LIMIT OFFSET</code> ini tidak sepenuhnya menyelesaikan masalah yang saya alami, terutama untuk query <code>SELECT COUNT(*)</code> pada dataset besar. Hal ini terlihat pada hasil monitoring yang saya lakukan.</p><figure><img src=/img/pagination/jaeger-trace-query-count.webp alt="jaeger trace query count" class="clickable-image lazyload" data-src=/img/pagination/jaeger-trace-query-count.webp loading=lazy></figure><p>Hasil monitoring menunjukkan perbedaan kinerja yang signifikan antara <code>query untuk mengambil data</code> vs <code>query COUNT(*)</code>, Khususnya ketika banyak request yang masuk secara bersamaan.</p><p>Hal ini juga didukung oleh problem-problem serupa yang dibahas di internet seperti :</p><ul><li><a href=https://stackoverflow.com/questions/55018986/postgresql-select-count-query-takes-long-time>https://stackoverflow.com/questions/55018986/postgresql-select-count-query-takes-long-time</a></li><li><a href=https://www.reddit.com/r/PostgreSQL/comments/140b4xy/select_count_is_slow_in_large_tables/>https://www.reddit.com/r/PostgreSQL/comments/140b4xy/select_count_is_slow_in_large_tables/</a></li><li><a href=https://tunghatbh.medium.com/postgresql-slow-count-query-c93c30792606>https://tunghatbh.medium.com/postgresql-slow-count-query-c93c30792606</a></li></ul><p>Dari studi kasus ini, saya menarik beberapa kesimpulan penting:</p><ul><li><code>Jumlah N query tidak selalu menentukan kinerja</code>: Tidak selalu benar bahwa semakin sedikit jumlah permintaan query yang kita jalankan, semakin baik performanya. Dalam beberapa kasus, membagi query kompleks menjadi beberapa query yang lebih kecil justru dapat meningkatkan kinerja secara keseluruhan.</li><li><code>Indeks tidak selalu optimal untuk COUNT(*)</code>: Meskipun indeks dapat meningkatkan kinerja query secara umum, pada kasus COUNT(*) indeks tidak selalu efektif.</li><li><code>Pentingnya benchmarking</code>: Membandingkan kinerja sebelum dan sesudah perubahan query adalah cara yang paling akurat untuk mengukur dampak dari suatu optimasi. Karena beda query dan struktur datanya, bisa jadi memerlukan cara optimasi yang berbeda pula.</li></ul><h2 id=cursor--sebagai-alternatif-dari-limit-offset>Cursor ! Sebagai Alternatif dari Limit Offset<a hidden class=anchor aria-hidden=true href=#cursor--sebagai-alternatif-dari-limit-offset>#</a></h2><h3 id=penjelasan-cursor-based-pagination>Penjelasan Cursor-based Pagination<a hidden class=anchor aria-hidden=true href=#penjelasan-cursor-based-pagination>#</a></h3><p>Cursor-based pagination menggunakan nilai unik dari suatu kolom (biasanya kolom yang diurutkan) sebagai &ldquo;cursor&rdquo; untuk menandai posisi saat ini dalam hasil query. Alih-alih menggunakan offset, kita mengirimkan cursor dari hasil sebelumnya untuk mendapatkan halaman berikutnya. Ini lebih efisien karena database dapat melompati nilai dan hanya perlu mencari rekaman yang memiliki nilai cursor lebih besar dari nilai cursor sebelumnya.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>users</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>sort_column</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=s1>&#39;cursor_value&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>sort_column</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>LIMIT</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h4 id=kelebihan-cursor-based-pagination>Kelebihan Cursor-based Pagination<a hidden class=anchor aria-hidden=true href=#kelebihan-cursor-based-pagination>#</a></h4><ul><li><code>Performa lebih baik</code>: Tidak perlu memindai seluruh tabel untuk setiap permintaan halaman.</li><li><code>Hasil yang konsisten</code>: Hasil query selalu sama, terlepas dari perubahan data yang terjadi di antara permintaan. Misalnya pagination pada LIMIT OFFSET akan tidak konsisten jika data pada halaman sebelumnya ada yang dihapus.</li><li><code>UX infinity Loading</code>: Cursor pagination sangat cocok untuk user experience web dan mobile yang biasanya menerapkan infinity loading.</li></ul><h4 id=kekurangan-cursor-based-pagination>Kekurangan Cursor-based Pagination<a hidden class=anchor aria-hidden=true href=#kekurangan-cursor-based-pagination>#</a></h4><ul><li><code>Implementasi lebih kompleks</code>: Membutuhkan perencanaan yang matang dalam memilih kolom cursor yang tepat.</li><li><code>Tidak cocok untuk semua jenis query dan UX</code>: Hanya efektif untuk query yang diurutkan berdasarkan satu atau beberapa kolom.</li><li><code>Statefull</code>: Karna harus meneruskan cursor</li><li><code>Sorting menyatu dengan cursor</code>: Bahwa urutan data yang ditampilkan selalu berbanding lurus dengan cursor yang digunakan.</li></ul><h3 id=contoh-implementasi>Contoh Implementasi<a hidden class=anchor aria-hidden=true href=#contoh-implementasi>#</a></h3><p>Sebagai contoh, respon API dengan cursor pagination mungkin memiliki struktur sebagai berikut:</p><ul><li><code>Endpoint</code> : {baseURL}/users?limit=3&amp;cursor=</li><li><code>Query Param</code> :<ul><li><code>limit</code>: jumlah data yang ditampilkan.</li><li><code>cursor</code>: inputan cursor, untuk halaman pertama di isi kosong.</li><li><code>cursor_type</code>: field apa yang dijadikan cursor, biasanya memiliki default value, dalam contoh ini menggunakan <code>ulid</code> descending.</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;message&#34;</span><span class=p>:</span> <span class=s2>&#34;successfully fetch data&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;data&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;ulid&#34;</span><span class=p>:</span> <span class=s2>&#34;01J4EXF94RZA4AZG1C0A0C2RKF&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;muchlis&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;ulid&#34;</span><span class=p>:</span> <span class=s2>&#34;01J4EXF94RWZVWS9NVEZMQ3R1N&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;monkey d luffy&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;ulid&#34;</span><span class=p>:</span> <span class=s2>&#34;01J4EXF94RT7G5CRH047MC0EF1&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;portgas d ace&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;meta&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;current_cursor&#34;</span><span class=p>:</span> <span class=s2>&#34;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;next_cursor&#34;</span><span class=p>:</span> <span class=s2>&#34;01J4EXF94RT7G5CRH047MC0EF1&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;next_page&#34;</span><span class=p>:</span> <span class=s2>&#34;/users?limit=3&amp;cursor=01J4EXF94RT7G5CRH047MC0EF1&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;prev_cursor&#34;</span><span class=p>:</span> <span class=s2>&#34;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;prev_page&#34;</span><span class=p>:</span> <span class=s2>&#34;/users?limit=3&amp;cursor=&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;trace_id&#34;</span><span class=p>:</span> <span class=s2>&#34;5b427ba9ab30002d347ea17cf8000cca&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>Repo Layer :</strong><br>Saya menggunakan raw query demi keterbacaan yang lebih mudah. Namun di kenyataan saya bisanya menggunakan sql builder seperti <code>golang squirell</code> atau <code>goqu</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>repo</span><span class=p>)</span> <span class=nf>FetchUserByUlid</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>cursorID</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>limit</span> <span class=kt>uint64</span><span class=p>)</span> <span class=p>([]</span><span class=nx>entity</span><span class=p>.</span><span class=nx>User</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithTimeout</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=mi>2</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>sqlStatement</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>args</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>cursorID</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>sqlStatement</span> <span class=p>=</span> <span class=s>`
</span></span></span><span class=line><span class=cl><span class=s>            SELECT id, name
</span></span></span><span class=line><span class=cl><span class=s>            FROM users
</span></span></span><span class=line><span class=cl><span class=s>            WHERE id &lt; $1
</span></span></span><span class=line><span class=cl><span class=s>            ORDER BY id DESC
</span></span></span><span class=line><span class=cl><span class=s>            LIMIT $2;
</span></span></span><span class=line><span class=cl><span class=s>        `</span>
</span></span><span class=line><span class=cl>        <span class=nx>args</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>args</span><span class=p>,</span> <span class=nx>cursorID</span><span class=p>,</span> <span class=nx>limit</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>sqlStatement</span> <span class=p>=</span> <span class=s>`
</span></span></span><span class=line><span class=cl><span class=s>            SELECT id, name
</span></span></span><span class=line><span class=cl><span class=s>            FROM users
</span></span></span><span class=line><span class=cl><span class=s>            ORDER BY id DESC
</span></span></span><span class=line><span class=cl><span class=s>            LIMIT $1;
</span></span></span><span class=line><span class=cl><span class=s>        `</span>
</span></span><span class=line><span class=cl>        <span class=nx>args</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>args</span><span class=p>,</span> <span class=nx>limit</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Execute the query
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>rows</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>db</span><span class=p>.</span><span class=nf>Query</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>sqlStatement</span><span class=p>,</span> <span class=nx>args</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;failed to execute query: %w&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>rows</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>users</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=nx>entity</span><span class=p>.</span><span class=nx>User</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// [SKIP] Parse the results
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// [SKIP] Check for errors after iterating over rows
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>users</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>Service Layer :</strong><br>Pada service layer, terdapat logic dimana kita harus mendapatkan data lebih daripada yang akan ditampilkan untuk mengetahui apakah data selanjutnya itu ada atau tidak.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Service</span><span class=p>)</span> <span class=nf>FetchAllUsersWithCursor</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>cursor</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>limit</span> <span class=kt>uint64</span><span class=p>)</span> <span class=p>([]</span><span class=nx>entity</span><span class=p>.</span><span class=nx>User</span><span class=p>,</span> <span class=o>*</span><span class=kt>string</span> <span class=cm>/*next cursor*/</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// [SKIP] validation, tracer dan sebagainya
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Panggil repo layer untuk mengambil data
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Menambahkan Limit +1 sehingga kita tau ada data lanjutan atau tidak
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Data berlebih ini akan dibuang kemudian
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>results</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>repo</span><span class=p>.</span><span class=nf>FetchUserByUlid</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>cursor</span><span class=p>,</span> <span class=nx>limit</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;error FetchUserByUlid: %w&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Menentukan cursor selanjutnya
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>nextCursor</span> <span class=o>*</span><span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>results</span><span class=p>)</span> <span class=p>&gt;</span> <span class=nb>int</span><span class=p>(</span><span class=nx>limit</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>nextCursorID</span> <span class=o>:=</span> <span class=nx>results</span><span class=p>[</span><span class=nx>limit</span><span class=o>-</span><span class=mi>1</span><span class=p>].</span><span class=nx>ID</span> <span class=c1>// Set cursor apabila ditemukan data lebih dari limit
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>nextCursor</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>nextCursorID</span>
</span></span><span class=line><span class=cl>        <span class=nx>results</span> <span class=p>=</span> <span class=nx>results</span><span class=p>[:</span><span class=nx>limit</span><span class=p>]</span> <span class=c1>// Hapus data yang kelebihan
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>nextCursor</span> <span class=p>=</span> <span class=kc>nil</span> <span class=c1>// Jika tidak ada kelebihan data, cursor selanjutnya diset nil
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// [SKIP] Konversi hasil
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>results</span><span class=p>,</span> <span class=nx>nextCursor</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Dengan asumsi menggunakan Clean Architecture atau Hexagonal Architecture</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>+-------------------------------------+
</span></span><span class=line><span class=cl><span class=p>|</span>            HTTP Handler             <span class=p>|</span>
</span></span><span class=line><span class=cl><span class=p>|</span>    <span class=o>(</span>Handling HTTP requests and      <span class=p>|</span>
</span></span><span class=line><span class=cl><span class=p>|</span>     responses, routing, etc.<span class=o>)</span>       <span class=p>|</span>
</span></span><span class=line><span class=cl>+----------------+--------------------+
</span></span><span class=line><span class=cl>                 <span class=p>|</span>
</span></span><span class=line><span class=cl>                 v
</span></span><span class=line><span class=cl>+----------------+--------------------+
</span></span><span class=line><span class=cl><span class=p>|</span>                Service              <span class=p>|</span>
</span></span><span class=line><span class=cl><span class=p>|</span> <span class=o>(</span>Business logic, orchestrating the  <span class=p>|</span>
</span></span><span class=line><span class=cl><span class=p>|</span>    application flow, validation,    <span class=p>|</span>
</span></span><span class=line><span class=cl><span class=p>|</span>          calling Repositories<span class=o>)</span>      <span class=p>|</span>
</span></span><span class=line><span class=cl>+----------------+--------------------+
</span></span><span class=line><span class=cl>                 <span class=p>|</span>
</span></span><span class=line><span class=cl>                 v
</span></span><span class=line><span class=cl>+----------------+--------------------+
</span></span><span class=line><span class=cl><span class=p>|</span>              Repository             <span class=p>|</span>
</span></span><span class=line><span class=cl><span class=p>|</span> <span class=o>(</span>Data access layer, interacting with<span class=p>|</span>
</span></span><span class=line><span class=cl><span class=p>|</span>   the database, etc.<span class=o>)</span>               <span class=p>|</span>
</span></span><span class=line><span class=cl>+-------------------------------------+
</span></span></code></pre></div><p>Pada contoh code di atas tersisa layer HTTP Handler yang bertugas sebagai View, dimana layer tersebut yang bertanggung jawab membuat value-value lain hasil dari proses layer service seperti menyimpan sementara <code>current_cursor</code>, membuat nilai <code>next_page</code> dari return value FetchAllUsersWithCursor() dan berbagai value lain untuk response yang memerlukan Framework HTTP Handler.</p><p>Tadi adalah contoh implementasi cursor pagination yang disederhanakan sehingga kita mendapatkan sedikit gambaran tentang kerumitannya. Pun pada code diatas saya sengaja melewatkan beberapa hal berikut karena bersifat optional.</p><ul><li>Previous_Page memerlukan implementasi yang berkebalikan pada Query SQL. Alih alih menggunakan cursor dan order default <code>WHERE id &lt; $1 ORDER BY id DESC</code>, menjadi <code>WHERE id > $1 ORDER BY id ASC</code> dengan cursor adalah value pertama dari data yang ditampilkan pada current page.</li><li>Adanya kemungkinan cursor dan urutan yang memerlukan 2 key bahkan lebih.</li><li>Validasi value yang lebih ketat untuk tipe Cursor dan OrderBy.</li></ul><h3 id=benchmark->Benchmark :<a hidden class=anchor aria-hidden=true href=#benchmark->#</a></h3><figure><img src=/img/pagination/pagination-performance.webp alt="pagination performance comparison" class="clickable-image lazyload" data-src=/img/pagination/pagination-performance.webp loading=lazy></figure><p><strong>Analisis:</strong></p><ul><li>Limit-Offset Pagination memiliki waktu respon yang mulai meningkat signifikan setelah halaman ke-50 (artinya di kedalaman data 50_000), menunjukkan skala yang buruk untuk dataset besar.</li><li>Limit-Offset + Query Count Pagination (dijalankan bersamaan dengan goroutine) Sedikit lebih lambat dari Limit-Offset biasa, yang menunjukkan adanya overhead tambahan. Overhead tambahan dari count ini akan terasa ketika request dijalankan secara paralel. Sedangkan pengujian diatas dilakukan secara sequensial.</li><li>Cursor Pagination paling efisien dan stabil, cocok untuk dataset besar dengan jumlah halaman yang banyak.</li></ul><p><strong>Catatan :</strong></p><ul><li>Komparasi ini membandingkan semua metode menggunakan spesifikasi dan kondisi yang seragam. Latensi jaringan, struktur dan jumlah data dapat mempengaruhi hasil. Jadi, cukup berpatokan pada perbandingannya saja, karena angkanya akan sangat bervariasi tergantung kondisi masing-masing.</li><li>Data yang digunakan mencakup 100_000 entri data user yang di left-join kan dengan 2 table kecil dengan percobaan pagination ekstrem pada 1_000 entri per halaman.</li><li>Pengujian dilakukan secara sequensial, page per page.</li><li>Pengujian ini tidak menyertakan faktor lain yang sebenarnya penting seperti penggunaan memori, CPU, Row yang dikomputasi pada database.</li><li>Disini saya berusaha membuat effort seminimal mungkin.</li><li>Secara teori saja sebenarnya kita dapat memperkirakan metode mana yang lebih unggul. Benchmark ini mengonfirmasi hal tersebut.</li></ul><hr><p><code>Limit-Offset Pagination</code> memiliki keunggulan berupa kemudahan implementasi, dengan kelemahan yang hanya akan dirasakan ketika aplikasi kita mencapai level dimana jumlah data menjadi sangat besar. Kelemahan ini juga bisa diatasi dengan cara memberikan indexed range data yang sudah ditentukan kepada user (seperti saat menampilkan data transaksi bank yang wajib menentukan bulannya).<br>Di sisi lain, walaupun lebih cepat dan stabil, <code>Cursor-Based Pagination</code> sedikit lebih rumit untuk diimplementasikan dan memiliki keterbatasan tertentu yang mungkin membuatnya kurang cocok untuk semua jenis kasus.</p><p>Pepatah <code>premature optimization is the root of all evil</code> mengingatkan kita bahwa optimasi yang terlalu dini bisa menjadi masalah, namun disini menurut saya pribadi, menghindari kesalahan sejak awal bukan berarti hal yang buruk juga. Justru, mengambil keputusan arsitektur dan desain yang optimal, seperti memilih <code>Cursor-Based Pagination</code> daripada <code>Limit-Offset</code>, dapat dianggap sebagai pengambilan keputusan yang bijak, bukan sekadar premature optimization. Pada intinya, memahami trade-off dari setiap pilihan dan memilih solusi yang tepat untuk kebutuhan spesifik adalah pendekatan yang lebih tepat dalam pengembangan perangkat lunak.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.muchlis.dev/tags/golang/>Golang</a></li><li><a href=https://blog.muchlis.dev/tags/database/>Database</a></li><li><a href=https://blog.muchlis.dev/tags/optimization/>Optimization</a></li><li><a href=https://blog.muchlis.dev/tags/best-practice/>Best Practice</a></li></ul><nav class=paginav><a class=next href=https://blog.muchlis.dev/post/structuring-project-folder/><span class=title>Next »</span><br><span>Struktur Folder dan Aturan Penulisan Kode dalam Project Golang: Preferensi Pribadi</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Optimisasi Pagination: Mengapa Limit-Offset Bisa Menjadi Bom Waktu dan Cursor Pagination Menjadi Solusinya on x" href="https://x.com/intent/tweet/?text=Optimisasi%20Pagination%3a%20Mengapa%20Limit-Offset%20Bisa%20Menjadi%20Bom%20Waktu%20dan%20Cursor%20Pagination%20Menjadi%20Solusinya&amp;url=https%3a%2f%2fblog.muchlis.dev%2fpost%2fpagination%2f&amp;hashtags=Golang%2cDatabase%2cOptimization%2cBestPractice"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Optimisasi Pagination: Mengapa Limit-Offset Bisa Menjadi Bom Waktu dan Cursor Pagination Menjadi Solusinya on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.muchlis.dev%2fpost%2fpagination%2f&amp;title=Optimisasi%20Pagination%3a%20Mengapa%20Limit-Offset%20Bisa%20Menjadi%20Bom%20Waktu%20dan%20Cursor%20Pagination%20Menjadi%20Solusinya&amp;summary=Optimisasi%20Pagination%3a%20Mengapa%20Limit-Offset%20Bisa%20Menjadi%20Bom%20Waktu%20dan%20Cursor%20Pagination%20Menjadi%20Solusinya&amp;source=https%3a%2f%2fblog.muchlis.dev%2fpost%2fpagination%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Optimisasi Pagination: Mengapa Limit-Offset Bisa Menjadi Bom Waktu dan Cursor Pagination Menjadi Solusinya on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.muchlis.dev%2fpost%2fpagination%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Optimisasi Pagination: Mengapa Limit-Offset Bisa Menjadi Bom Waktu dan Cursor Pagination Menjadi Solusinya on whatsapp" href="https://api.whatsapp.com/send?text=Optimisasi%20Pagination%3a%20Mengapa%20Limit-Offset%20Bisa%20Menjadi%20Bom%20Waktu%20dan%20Cursor%20Pagination%20Menjadi%20Solusinya%20-%20https%3a%2f%2fblog.muchlis.dev%2fpost%2fpagination%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Optimisasi Pagination: Mengapa Limit-Offset Bisa Menjadi Bom Waktu dan Cursor Pagination Menjadi Solusinya on telegram" href="https://telegram.me/share/url?text=Optimisasi%20Pagination%3a%20Mengapa%20Limit-Offset%20Bisa%20Menjadi%20Bom%20Waktu%20dan%20Cursor%20Pagination%20Menjadi%20Solusinya&amp;url=https%3a%2f%2fblog.muchlis.dev%2fpost%2fpagination%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=muchlist/paper data-repo-id=R_kgDOMD4syA data-category=General data-category-id=DIC_kwDOMD4syM4ChOKX data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=id data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.muchlis.dev/>Muchlis Dev</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>