<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count | Muchlis Dev</title>
<meta name=keywords content="Golang,Database,Optimization,Best Practice"><meta name=description content="Bagaimana cara paling optimal dalam melakukan pagination di sisi backend"><meta name=author content="Muchlis"><link rel=canonical href=http://localhost:1313/post/pagination/><meta name=google-site-verification content="G-F1ZZCKLSJF"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/icon/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/icon/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/icon/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/post/pagination/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F1ZZCKLSJF"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F1ZZCKLSJF")}</script><meta property="og:title" content="Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count"><meta property="og:description" content="Bagaimana cara paling optimal dalam melakukan pagination di sisi backend"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/post/pagination/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-07-27T17:33:10+08:00"><meta property="article:modified_time" content="2024-07-27T17:33:10+08:00"><meta property="og:site_name" content="Muchlis Dev"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count"><meta name=twitter:description content="Bagaimana cara paling optimal dalam melakukan pagination di sisi backend"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/post/"},{"@type":"ListItem","position":2,"name":"Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count","item":"http://localhost:1313/post/pagination/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count","name":"Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count","description":"Bagaimana cara paling optimal dalam melakukan pagination di sisi backend","keywords":["Golang","Database","Optimization","Best Practice"],"articleBody":"Bagaimana cara paling optimal dalam melakukan pagination di sisi backend\nKarena judulnya sudah sangat niche, Untuk mempersingkat, Saya tidak akan membahas apa itu pagination, Namun saya akan membahas mengenai kebencian tersendiri saya terhadap cara yang biasanya dilakukan untuk memproses data pagination pada sisi backend, terutama yang berkaitan dengan database.\nKenapa Pagination Penting ? Pagination dipandang sangat penting karena beberapa alasan berikut:\nPerformance: Mengembalikan data yang besar sekaligus itu lambat dan memakan banyak sumber daya. Dengan membagi data menjadi potongan-potongan yang lebih kecil, API bisa mengembalikan data lebih cepat dan dengan sumber daya yang lebih sedikit.\nMemory Management: Memproses data yang besar dapat memerlukan banyak memori, yang bisa menjadi masalah untuk perangkat dengan sumber daya terbatas seperti ponsel. Dengan menggunakan pagination, API dapat membatasi jumlah data yang perlu disimpan dalam memori pada suatu waktu.\nUser Experience: Untuk aplikasi klien yang menampilkan data kepada pengguna, pagination dapat meningkatkan pengalaman pengguna dengan menyediakan antarmuka yang lebih cepat dan responsif. Pengguna dapat melihat hasil awal dengan cepat dan dapat meminta data tambahan sesuai kebutuhan.\nKetiga alasan berikut sangat valid. Namun cara kita memproses pagination ini tidak hanya dapat dicapai dengan Query Limit Offset + Count.\nAlternatif Limit Offset ? Cursor-based Pagination Introduction to cursor-based pagination (a.k.a. keyset pagination). Explain how it works by using unique record identifiers. Advantages: Better performance for large datasets, consistent results.\nSeek Method Explanation of the seek method for pagination. Advantages: More efficient for certain types of queries.\nKenapa Cara Alternatif Ini Lebih Bagus ? Disini kita akan bahas kekurangan dari cara pagination menggunakan limit offset.\nPerformance Issues Database Query Performance Saat offset meningkat, database perlu memindai lebih banyak baris, yang menyebabkan query menjadi lebih lambat. Offsets yang besar dapat menurunkan kinerja, terutama pada tabel dengan jutaan rekaman. Berikut adalah contoh query SQL yang menunjukkan bagaimana LIMIT dan OFFSET digunakan:\nSELECT * FROM records ORDER BY id LIMIT 10 OFFSET 1000; Penjelasan:\nLIMIT menentukan jumlah maksimal baris yang dikembalikan.\nOFFSET menentukan berapa banyak baris yang harus dilewati sebelum mulai mengembalikan hasil.\nPada contoh di atas, query ini sebenarnya akan memindai 1000 baris pertama, membuang data yang tidak diperlukan, dan mengembalikan 10 baris berikutnya. Jika tabel memiliki jutaan baris, melewati sejumlah besar baris dengan offset yang besar akan membuat query berjalan lebih lambat karena database harus memindai semua baris tersebut sebelum mengembalikan hasil.\nHal ini berarti jika klien melakukan permintaaan page 2, page 3 dan seterusnya maka akan menyebabkan database harus memproses berkali-kali lipat data dibandingkan dengan jumlah yang sebenarnya dikembalikan kepada klien.\nSebagai ilustrasi:\nUntuk page 1: OFFSET 0, LIMIT 100 -\u003e memindai dan mengembalikan 100 baris. Untuk page 2: OFFSET 100, LIMIT 100 -\u003e memindai dan membuang 100 baris, kemudian mengembalikan 100 baris berikutnya. Untuk page 3: OFFSET 200, LIMIT 100 -\u003e memindai dan membuang 200 baris, kemudian mengembalikan 100 baris berikutnya. Untuk page 100: OFFSET 10000, LIMIT 100 -\u003e memindai dan membuang 10000 baris, kemudian mengembalikan 100 baris berikutnya. Semakin besar nilai offset, semakin banyak baris yang perlu dipindai dan dibuang, yang membuat query semakin lambat dan tidak efisien. Ini menjadi sangat buruk untuk tabel dengan jutaan baris karena memproses dan membuang banyak data setiap kali ada permintaan halaman baru.\nDatabase Query Count Untuk Metadata Tidak hanya itu, dalam implementasi pagination menggunakan LIMIT dan OFFSET, query COUNT(*) sering digunakan untuk menghitung jumlah total baris dalam dataset. Informasi ini diperlukan untuk menyusun metadata pagination, seperti jumlah total halaman dan jumlah total item, yang kemudian dikembalikan dalam respon API.\nSebagai contoh, respon API mungkin memiliki struktur sebagai berikut:\n{ \"message\": \"successfully fetch data\", \"data\": [ {} ], \"meta\": { \"current_page\": 1, \"page_size\": 100, \"total_count\": 3000, \"total_page\": 30 }, \"trace_id\": \"376cd2fb76a2b33afbd1ba648adbe8e3\" } Untuk menghasilkan metadata ini, backend perlu melakukan dua query:\nUntuk mengambil data dengan LIMIT dan OFFSET SELECT * FROM items LIMIT 100 OFFSET 0; Untuk menghitung jumlah total baris dengan COUNT(*) SELECT COUNT(*) FROM items; Query COUNT() memastikan bahwa frontend atau client aplikasi dapat menampilkan informasi pagination yang akurat kepada pengguna, seperti berapa banyak halaman yang tersedia dan jumlah total item yang dapat dilihat. Namun, penggunaan query COUNT() pada dataset yang besar dapat berdampak negatif karena dapat (namun belum tentu) mengakibatkan full table scan, tidak selalu dapat dioptimalkan dengan indeks, berpotensi menyebabkan masalah konkurensi dan locking, memerlukan banyak I/O disk, dan menggunakan sumber daya sistem yang signifikan.\nPada awalnya saat aplikasi mulai dibuat, issue ini tidak akan terasa, namun seiring berjalannya waktu dan dataset menjadi besar maka issue ini akan perlahan lahan muncul. Karena saya mengalaminya sendiri dan pada akhirnya membuat artikel ini.\nMenggunakan teknik alternatif dan optimisasi bisa membantu meningkatkan kinerja dalam kasus ini.\nOptimasi Database Query LIMIT OFFSET Dalam studi kasus ini query untuk pagination dapat dioptimalkan, namun query count tidak. Sehingga pilihan yang paling tepat adalah mengganti strategy ke pagination alternative.\nBagaimana cara mengoptimalkan query LIMIT OFFSET ? Teknik ini bahkan saya temukan di library yang digunakan pada bahasa lain, PHP Laravel. yang dapat dicontoh pada library ini : https://github.com/hammerstonedev/fast-paginate Apa yang dilakukan untuk membuat peformanya menjadi lebih baik ?\nselect * from items -- The full data that you want to show your users. where items.id in ( -- The \"deferred join\" or subquery, in our case. select id from items -- The pagination, accessing as little data as possible - ID only. limit 15 offset 150000 ) Idenya adalah agar melakukan penerapan LIMIT dan OFFSET pada data yang lebih kecil, baru kemudian hasilnya dicari untuk membuat data yang lebih lengkap.\nNamun jujurly ini tidak terlalu menolong karena pada kenyataannya query count masih sangat lambat pada jumlah data yang sangat besar. Buktinya ?\npada artikel ini saya belum bisa memberikan visualisasi data yang lengkap. Namun melalui sample ini saya menemukan perbedaan yang sangat signifikan antara mendapatkan datanya dan mendapatkan jumlah datanya secara keseluruhan.\nPada studi kasus tersebut saya mendapatkan pelajaran bahwa :\ntidak selamanya jumlah N query yg sedikit menjadi lebih peforma dibandingkan jumlah N query pada kondisi tertentu query yang dipisah pisah justru menjadikan peformanya naik signifikan query count tidak tertolong oleh index dalam kasus saya ini didukung oleh problem2 serupa yang dialami beberapa contoh artikel berikut. peforma ini dapat diukur dengan benar benar membandingkan peforma before dan after perubahan query. benchmark ","wordCount":"1018","inLanguage":"en","datePublished":"2024-07-27T17:33:10+08:00","dateModified":"2024-07-27T17:33:10+08:00","author":{"@type":"Person","name":"Muchlis"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/post/pagination/"},"publisher":{"@type":"Organization","name":"Muchlis Dev","logo":{"@type":"ImageObject","url":"http://localhost:1313/icon/favicon.ico"}}}</script><link rel=stylesheet href=http://localhost:1313/css/custom-styles.min.846e2c0c38b3403ffecfec3d9c9b227dcfa79e75b178a91e1a26ae745cf5da5a.css><script src=http://localhost:1313/js/clickable-image.min.64e4ed1fd2302afde6a6750edcf663d18d6bf3b36d95ac130501827d8732c7a3.js defer></script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/icon/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://muchlis.dev title="Portfolio (2021)"><span>Portfolio (2021)</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count</h1><div class=post-description>Bagaimana cara paling optimal dalam melakukan pagination di sisi backend</div><div class=post-meta><span title='2024-07-27 17:33:10 +0800 WITA'>July 27, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1018 words&nbsp;·&nbsp;Muchlis&nbsp;|&nbsp;<a href=https://github.com/muchlist/paper/tree/main/content/post/pagination.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#kenapa-pagination-penting->Kenapa Pagination Penting ?</a></li><li><a href=#alternatif-limit-offset->Alternatif Limit Offset ?</a><ul><li><a href=#cursor-based-pagination>Cursor-based Pagination</a></li><li><a href=#seek-method>Seek Method</a></li></ul></li><li><a href=#kenapa-cara-alternatif-ini-lebih-bagus->Kenapa Cara Alternatif Ini Lebih Bagus ?</a><ul><li><a href=#performance-issues>Performance Issues</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>Bagaimana cara paling optimal dalam melakukan pagination di sisi backend</p><p>Karena judulnya sudah sangat niche, Untuk mempersingkat, Saya tidak akan membahas apa itu pagination, Namun saya akan membahas mengenai kebencian tersendiri saya terhadap cara yang biasanya dilakukan untuk memproses data pagination pada sisi backend, terutama yang berkaitan dengan database.</p><h2 id=kenapa-pagination-penting->Kenapa Pagination Penting ?<a hidden class=anchor aria-hidden=true href=#kenapa-pagination-penting->#</a></h2><p>Pagination dipandang sangat penting karena beberapa alasan berikut:</p><ul><li><p>Performance: Mengembalikan data yang besar sekaligus itu lambat dan memakan banyak sumber daya. Dengan membagi data menjadi potongan-potongan yang lebih kecil, API bisa mengembalikan data lebih cepat dan dengan sumber daya yang lebih sedikit.</p></li><li><p>Memory Management: Memproses data yang besar dapat memerlukan banyak memori, yang bisa menjadi masalah untuk perangkat dengan sumber daya terbatas seperti ponsel. Dengan menggunakan pagination, API dapat membatasi jumlah data yang perlu disimpan dalam memori pada suatu waktu.</p></li><li><p>User Experience: Untuk aplikasi klien yang menampilkan data kepada pengguna, pagination dapat meningkatkan pengalaman pengguna dengan menyediakan antarmuka yang lebih cepat dan responsif. Pengguna dapat melihat hasil awal dengan cepat dan dapat meminta data tambahan sesuai kebutuhan.</p></li></ul><p>Ketiga alasan berikut sangat valid. Namun cara kita memproses pagination ini tidak hanya dapat dicapai dengan Query Limit Offset + Count.</p><h2 id=alternatif-limit-offset->Alternatif Limit Offset ?<a hidden class=anchor aria-hidden=true href=#alternatif-limit-offset->#</a></h2><h3 id=cursor-based-pagination>Cursor-based Pagination<a hidden class=anchor aria-hidden=true href=#cursor-based-pagination>#</a></h3><p>Introduction to cursor-based pagination (a.k.a. keyset pagination).
Explain how it works by using unique record identifiers.
Advantages: Better performance for large datasets, consistent results.</p><h3 id=seek-method>Seek Method<a hidden class=anchor aria-hidden=true href=#seek-method>#</a></h3><p>Explanation of the seek method for pagination.
Advantages: More efficient for certain types of queries.</p><h2 id=kenapa-cara-alternatif-ini-lebih-bagus->Kenapa Cara Alternatif Ini Lebih Bagus ?<a hidden class=anchor aria-hidden=true href=#kenapa-cara-alternatif-ini-lebih-bagus->#</a></h2><p>Disini kita akan bahas kekurangan dari cara pagination menggunakan limit offset.</p><h3 id=performance-issues>Performance Issues<a hidden class=anchor aria-hidden=true href=#performance-issues>#</a></h3><h4 id=database-query-performance>Database Query Performance<a hidden class=anchor aria-hidden=true href=#database-query-performance>#</a></h4><p>Saat offset meningkat, database perlu memindai lebih banyak baris, yang menyebabkan query menjadi lebih lambat. Offsets yang besar dapat menurunkan kinerja, terutama pada tabel dengan jutaan rekaman. Berikut adalah contoh query SQL yang menunjukkan bagaimana LIMIT dan OFFSET digunakan:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>records</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>LIMIT</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=k>OFFSET</span><span class=w> </span><span class=mi>1000</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>Penjelasan:</p><p><code>LIMIT</code> menentukan jumlah maksimal baris yang dikembalikan.<br><code>OFFSET</code> menentukan berapa banyak baris yang harus dilewati sebelum mulai mengembalikan hasil.</p><p>Pada contoh di atas, query ini sebenarnya akan memindai 1000 baris pertama, membuang data yang tidak diperlukan, dan mengembalikan 10 baris berikutnya. Jika tabel memiliki jutaan baris, melewati sejumlah besar baris dengan offset yang besar akan membuat query berjalan lebih lambat karena database harus memindai semua baris tersebut sebelum mengembalikan hasil.</p><p>Hal ini berarti jika klien melakukan permintaaan page 2, page 3 dan seterusnya maka akan menyebabkan database harus memproses berkali-kali lipat data dibandingkan dengan jumlah yang sebenarnya dikembalikan kepada klien.</p><p>Sebagai ilustrasi:</p><ul><li>Untuk page 1: OFFSET 0, LIMIT 100 -> memindai dan mengembalikan 100 baris.</li><li>Untuk page 2: OFFSET 100, LIMIT 100 -> memindai dan membuang 100 baris, kemudian mengembalikan 100 baris berikutnya.</li><li>Untuk page 3: OFFSET 200, LIMIT 100 -> memindai dan membuang 200 baris, kemudian mengembalikan 100 baris berikutnya.</li><li>Untuk page 100: OFFSET 10000, LIMIT 100 -> memindai dan membuang 10000 baris, kemudian mengembalikan 100 baris berikutnya.</li></ul><p>Semakin besar nilai offset, semakin banyak baris yang perlu dipindai dan dibuang, yang membuat query semakin lambat dan tidak efisien. Ini menjadi sangat buruk untuk tabel dengan jutaan baris karena memproses dan membuang banyak data setiap kali ada permintaan halaman baru.</p><h4 id=database-query-count-untuk-metadata>Database Query Count Untuk Metadata<a hidden class=anchor aria-hidden=true href=#database-query-count-untuk-metadata>#</a></h4><p>Tidak hanya itu, dalam implementasi pagination menggunakan LIMIT dan OFFSET, query COUNT(*) sering digunakan untuk menghitung jumlah total baris dalam dataset. Informasi ini diperlukan untuk menyusun metadata pagination, seperti jumlah total halaman dan jumlah total item, yang kemudian dikembalikan dalam respon API.</p><p>Sebagai contoh, respon API mungkin memiliki struktur sebagai berikut:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;message&#34;</span><span class=p>:</span> <span class=s2>&#34;successfully fetch data&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;data&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;meta&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;current_page&#34;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;page_size&#34;</span><span class=p>:</span> <span class=mi>100</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;total_count&#34;</span><span class=p>:</span> <span class=mi>3000</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;total_page&#34;</span><span class=p>:</span> <span class=mi>30</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;trace_id&#34;</span><span class=p>:</span> <span class=s2>&#34;376cd2fb76a2b33afbd1ba648adbe8e3&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Untuk menghasilkan metadata ini, backend perlu melakukan dua query:</p><ol><li>Untuk mengambil data dengan LIMIT dan OFFSET</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>items</span><span class=w> </span><span class=k>LIMIT</span><span class=w> </span><span class=mi>100</span><span class=w> </span><span class=k>OFFSET</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><ol start=2><li>Untuk menghitung jumlah total baris dengan COUNT(*)</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>items</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>Query COUNT(<em>) memastikan bahwa frontend atau client aplikasi dapat menampilkan informasi pagination yang akurat kepada pengguna, seperti berapa banyak halaman yang tersedia dan jumlah total item yang dapat dilihat. Namun, penggunaan query COUNT(</em>) pada dataset yang besar dapat berdampak negatif karena dapat (namun belum tentu) mengakibatkan full table scan, tidak selalu dapat dioptimalkan dengan indeks, berpotensi menyebabkan masalah konkurensi dan locking, memerlukan banyak I/O disk, dan menggunakan sumber daya sistem yang signifikan.</p><p>Pada awalnya saat aplikasi mulai dibuat, issue ini tidak akan terasa, namun seiring berjalannya waktu dan dataset menjadi besar maka issue ini akan perlahan lahan muncul. Karena saya mengalaminya sendiri dan pada akhirnya membuat artikel ini.</p><p>Menggunakan teknik alternatif dan optimisasi bisa membantu meningkatkan kinerja dalam kasus ini.</p><h4 id=optimasi-database-query-limit-offset>Optimasi Database Query LIMIT OFFSET<a hidden class=anchor aria-hidden=true href=#optimasi-database-query-limit-offset>#</a></h4><p>Dalam studi kasus ini query untuk pagination dapat dioptimalkan, namun query count tidak. Sehingga pilihan yang paling tepat adalah mengganti strategy ke pagination alternative.</p><p>Bagaimana cara mengoptimalkan query LIMIT OFFSET ?
Teknik ini bahkan saya temukan di library yang digunakan pada bahasa lain, PHP Laravel. yang dapat dicontoh pada library ini : <a href=https://github.com/hammerstonedev/fast-paginate>https://github.com/hammerstonedev/fast-paginate</a>
Apa yang dilakukan untuk membuat peformanya menjadi lebih baik ?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>items</span><span class=w>              </span><span class=c1>-- The full data that you want to show your users.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>where</span><span class=w> </span><span class=n>items</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=p>(</span><span class=w>          </span><span class=c1>-- The &#34;deferred join&#34; or subquery, in our case.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=k>select</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>items</span><span class=w>     </span><span class=c1>-- The pagination, accessing as little data as possible - ID only.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=k>limit</span><span class=w> </span><span class=mi>15</span><span class=w> </span><span class=k>offset</span><span class=w> </span><span class=mi>150000</span><span class=w>      
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><p>Idenya adalah agar melakukan penerapan LIMIT dan OFFSET pada data yang lebih kecil, baru kemudian hasilnya dicari untuk membuat data yang lebih lengkap.</p><p>Namun jujurly ini tidak terlalu menolong karena pada kenyataannya query count masih sangat lambat pada jumlah data yang sangat besar. Buktinya ?</p><figure><img src=/img/pagination/jaeger-trace-query-count.webp alt="jaeger trace query count" class="clickable-image lazyload" data-src=/img/pagination/jaeger-trace-query-count.webp loading=lazy></figure><p>pada artikel ini saya belum bisa memberikan visualisasi data yang lengkap. Namun melalui sample ini saya menemukan perbedaan yang sangat signifikan antara mendapatkan datanya dan mendapatkan jumlah datanya secara keseluruhan.</p><p>Pada studi kasus tersebut saya mendapatkan pelajaran bahwa :</p><ul><li>tidak selamanya jumlah N query yg sedikit menjadi lebih peforma dibandingkan jumlah N query</li><li>pada kondisi tertentu query yang dipisah pisah justru menjadikan peformanya naik signifikan</li><li>query count tidak tertolong oleh index dalam kasus saya
ini didukung oleh problem2 serupa yang dialami beberapa contoh artikel berikut.</li><li>peforma ini dapat diukur dengan benar benar membandingkan peforma before dan after perubahan query. benchmark</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/golang/>Golang</a></li><li><a href=http://localhost:1313/tags/database/>Database</a></li><li><a href=http://localhost:1313/tags/optimization/>Optimization</a></li><li><a href=http://localhost:1313/tags/best-practice/>Best Practice</a></li></ul><nav class=paginav><a class=next href=http://localhost:1313/post/structuring-project-folder/><span class=title>Next »</span><br><span>Struktur Folder dan Aturan Penulisan Kode dalam Project Golang: Preferensi Pribadi</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count on x" href="https://x.com/intent/tweet/?text=Kekurangan%20Backend%20Pagination%20Menggunakan%20Limit%2c%20Offset%2c%20dan%20Total%20Count&amp;url=http%3a%2f%2flocalhost%3a1313%2fpost%2fpagination%2f&amp;hashtags=Golang%2cDatabase%2cOptimization%2cBestPractice"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fpost%2fpagination%2f&amp;title=Kekurangan%20Backend%20Pagination%20Menggunakan%20Limit%2c%20Offset%2c%20dan%20Total%20Count&amp;summary=Kekurangan%20Backend%20Pagination%20Menggunakan%20Limit%2c%20Offset%2c%20dan%20Total%20Count&amp;source=http%3a%2f%2flocalhost%3a1313%2fpost%2fpagination%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fpost%2fpagination%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count on whatsapp" href="https://api.whatsapp.com/send?text=Kekurangan%20Backend%20Pagination%20Menggunakan%20Limit%2c%20Offset%2c%20dan%20Total%20Count%20-%20http%3a%2f%2flocalhost%3a1313%2fpost%2fpagination%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count on telegram" href="https://telegram.me/share/url?text=Kekurangan%20Backend%20Pagination%20Menggunakan%20Limit%2c%20Offset%2c%20dan%20Total%20Count&amp;url=http%3a%2f%2flocalhost%3a1313%2fpost%2fpagination%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=muchlist/paper data-repo-id=R_kgDOMD4syA data-category=General data-category-id=DIC_kwDOMD4syM4ChOKX data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=id data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Muchlis Dev</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>