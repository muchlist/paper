<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count | Muchlis Dev</title>
<meta name=keywords content="Golang,Database,Optimization,Best Practice"><meta name=description content="Bagaimana cara paling optimal dalam melakukan pagination di sisi backend"><meta name=author content="Muchlis"><link rel=canonical href=http://localhost:1313/post/pagination/><meta name=google-site-verification content="G-F1ZZCKLSJF"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/icon/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/icon/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/icon/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/post/pagination/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F1ZZCKLSJF"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F1ZZCKLSJF")}</script><meta property="og:title" content="Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count"><meta property="og:description" content="Bagaimana cara paling optimal dalam melakukan pagination di sisi backend"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/post/pagination/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-07-27T17:33:10+08:00"><meta property="article:modified_time" content="2024-07-27T17:33:10+08:00"><meta property="og:site_name" content="Muchlis Dev"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count"><meta name=twitter:description content="Bagaimana cara paling optimal dalam melakukan pagination di sisi backend"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/post/"},{"@type":"ListItem","position":2,"name":"Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count","item":"http://localhost:1313/post/pagination/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count","name":"Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count","description":"Bagaimana cara paling optimal dalam melakukan pagination di sisi backend","keywords":["Golang","Database","Optimization","Best Practice"],"articleBody":"Pagination adalah teknik umum untuk membagi hasil query database menjadi bagian-bagian yang lebih kecil. Meskipun LIMIT OFFSET adalah metode yang sederhana, metode ini memiliki beberapa kelemahan, terutama dalam hal performa pada dataset yang sangat besar. Artikel ini akan membahas masalah-masalah yang sering muncul saat menggunakan LIMIT OFFSET dan mengeksplorasi alternatif yang lebih efisien, seperti cursor-based pagination dan seek method.\nPentingnya Pagination dan Tantangannya Pagination memiliki beberapa manfaat signifikan:\nPerformance: Mengembalikan data yang besar sekaligus itu lambat dan memakan banyak sumber daya. Dengan membagi data menjadi potongan-potongan yang lebih kecil, API bisa mengembalikan data lebih cepat dan dengan sumber daya yang lebih sedikit.\nMemory Management: Memproses data yang besar dapat memerlukan banyak memori, yang bisa menjadi masalah untuk perangkat dengan sumber daya terbatas seperti ponsel. Dengan menggunakan pagination, API dapat membatasi jumlah data yang perlu disimpan dalam memori pada suatu waktu.\nUser Experience: Untuk aplikasi klien yang menampilkan data kepada pengguna, pagination dapat meningkatkan pengalaman pengguna dengan menyediakan antarmuka yang lebih cepat dan responsif. Pengguna dapat melihat hasil awal dengan cepat dan dapat meminta data tambahan sesuai kebutuhan.\nNamun, penting untuk diingat bahwa pagination tidak selalu menjadi solusi yang sempurna. Pada dataset yang sangat besar, bahkan pagination pun dapat menghadapi tantangan.\nMasalah LIMIT OFFSET Disini kita akan bahas kekurangan dari cara pagination menggunakan LIMIT OFFSET.\nIsu Performa Mengapa LIMIT OFFSET Lambat untuk Dataset Besar? Saat berhadapan dengan dataset yang sangat besar, pagination menggunakan LIMIT OFFSET seringkali mengalami penurunan performa. Ini karena setiap kali kita meminta halaman baru, database harus memindai seluruh tabel dari awal untuk menemukan data yang sesuai, meskipun kita hanya membutuhkan sebagian kecil data.\nBerikut adalah contoh query SQL yang menunjukkan bagaimana LIMIT dan OFFSET diterapkan:\nSELECT * FROM records ORDER BY id LIMIT 10 OFFSET 1000; Penjelasan:\nLIMIT menentukan jumlah maksimal baris yang dikembalikan.\nOFFSET menentukan berapa banyak baris yang harus dilewati sebelum mulai mengembalikan hasil.\nPada contoh di atas, query tersebut sebenarnya akan memindai 1000 baris pertama, membuang data yang tidak diperlukan, dan mengembalikan 10 baris berikutnya. Jika tabel memiliki jutaan baris, melewati sejumlah besar baris dengan offset yang besar akan membuat query berjalan lebih lambat karena database harus memindai semua baris tersebut sebelum mengembalikan hasil.\nArtinya jika klien melakukan permintaaan page 2, page 3 dan seterusnya maka akan menyebabkan database harus memproses berkali-kali lipat data dibandingkan dengan jumlah yang sebenarnya dikembalikan kepada klien.\nSebagai ilustrasi, asumsi jika 1 halaman menampilkan 100 data:\nUntuk page 1: OFFSET 0, LIMIT 100 -\u003e memindai dan mengembalikan 100 baris. Untuk page 2: OFFSET 100, LIMIT 100 -\u003e memindai dan membuang 100 baris, kemudian memindai dan mengembalikan 100 baris berikutnya. Untuk page 3: OFFSET 200, LIMIT 100 -\u003e memindai dan membuang 200 baris, kemudian memindai dan mengembalikan 100 baris berikutnya. Untuk page 100: OFFSET 10000, LIMIT 100 -\u003e memindai dan membuang 10000 baris, kemudian memindai dan mengembalikan 100 baris berikutnya. Semakin besar nilai offset, semakin banyak baris yang perlu dipindai dan dibuang, yang membuat query semakin lambat dan tidak efisien. Ini menjadi sangat buruk untuk tabel dengan jutaan baris karena memproses dan membuang banyak data setiap kali ada permintaan halaman baru.\nWorst Case : Client ingin mendapatkan semua data dengan cara melakukan scan dari page 1 sampai dengan page terakhir.\nBayangkan kita ingin membaca sebuah buku yang sangat tebal halaman demi halaman. Jika kita menggunakan metode LIMIT dan OFFSET, kita harus membuka buku dari awal setiap kali ingin membaca halaman berikutnya. Ini tentu sangat tidak efisien, karena kita akan mengulang-ulang membuka halaman yang sama. Dalam konteks database, hal ini sama dengan membuat database bekerja lebih keras dari yang seharusnya. Oleh karena itu, jika tujuan kita adalah mendapatkan semua data, lebih baik kita langsung mengambil seluruh buku (data) sekaligus, lalu membacanya (memprosesnya) di aplikasi.\nDampak Query COUNT(*) terhadap Performa Tidak hanya itu, dalam implementasi pagination menggunakan LIMIT dan OFFSET, query COUNT(*) sering digunakan untuk menghitung jumlah total baris dalam dataset. Informasi ini diperlukan untuk menyusun metadata pagination, seperti jumlah total halaman dan jumlah total item, yang kemudian dikembalikan dalam respon API.\nSebagai contoh, respon API mungkin memiliki struktur sebagai berikut:\n{ \"message\": \"successfully fetch data\", \"data\": [ {} ], \"meta\": { \"current_page\": 1, \"page_size\": 100, \"total_count\": 3000, \"total_page\": 30 } } Untuk menghasilkan metadata ini, backend perlu melakukan dua query:\nUntuk mengambil data dengan LIMIT dan OFFSET SELECT * FROM members LIMIT 100 OFFSET 0; Untuk menghitung jumlah total baris dengan COUNT(*) SELECT COUNT(*) FROM members; Penggunaan COUNT(*) pada dataset besar seringkali mengakibatkan penurunan performa yang signifikan. Hal ini dikarenakan:\nFull table scan: Database perlu memindai seluruh tabel untuk menghitung jumlah baris, terutama jika tidak ada indeks yang sesuai. Kurangnya optimasi indeks: COUNT(*) seringkali tidak dapat dioptimalkan dengan indeks, sehingga waktu eksekusi query menjadi lebih lama. Masalah konkurensi dan locking: Query COUNT(*) dapat menyebabkan konflik dengan query lain dan menghambat kinerja sistem. Beban I/O yang tinggi: Proses penghitungan jumlah baris memerlukan banyak operasi baca-tulis disk. Masalah ini mungkin tidak terlihat jelas pada awal pengembangan, tetapi akan semakin terasa ketika volume data terus bertambah. Pengalaman saya mendorong saya untuk menulis artikel ini. Teknik alternatif dan optimasi dapat menjadi solusi yang baik untuk mengatasinya.\nOptimasi Database Query LIMIT OFFSET Dalam studi kasus ini ternyata query untuk pagination dapat dioptimalkan, namun query count belum tentu. Sehingga pilihan yang paling tepat adalah mengganti strategy ke pagination alternative.\nBagaimana cara mengoptimalkan query LIMIT OFFSET ? Teknik ini justru saya temukan di library yang digunakan pada bahasa lain, PHP Laravel. yang dapat dicontoh pada library ini : https://github.com/hammerstonedev/fast-paginate Apa yang dilakukan untuk membuat peformanya menjadi lebih baik ?\nselect * from members -- The full data that you want to show your users. where members.id in ( -- The \"deferred join\" or subquery, in our case. select id from members -- The pagination, accessing as little data as possible - ID only. limit 15 offset 150000 ) Idenya adalah agar melakukan penerapan LIMIT dan OFFSET pada data yang scopenya lebih kecil, baru kemudian hasilnya dicari untuk membuat data yang lengkap.\nSayangnya, teknik optimasi pada query LIMIT OFFSET tidak sepenuhnya menyelesaikan masalah, terutama untuk query COUNT(*) pada dataset besar. Hal ini terlihat pada hasil benchmark yang saya lakukan.\nMeskipun visualisasi data yang lengkap belum dapat saya sajikan pada artikel ini, hasil benchmark menunjukkan perbedaan kinerja yang signifikan antara query untuk mengambil data dan query COUNT(*).\nDari studi kasus ini, saya menarik beberapa kesimpulan penting:\nJumlah query tidak selalu menentukan kinerja: Tidak selalu benar bahwa semakin sedikit permintaan query yang kita jalankan, semakin baik performanya. Dalam beberapa kasus, membagi query kompleks menjadi beberapa query yang lebih kecil justru dapat meningkatkan kinerja secara keseluruhan. Indeks tidak selalu optimal untuk COUNT(*): Meskipun indeks dapat meningkatkan kinerja query secara umum, pada kasus COUNT(*) indeks tidak selalu efektif. Pentingnya benchmark: Membandingkan kinerja sebelum dan sesudah perubahan query adalah cara yang paling akurat untuk mengukur dampak dari suatu optimasi. Alternatif Limit Offset ? Cursor-based Pagination Cursor-based pagination menggunakan nilai unik dari suatu kolom (biasanya kolom yang diurutkan) sebagai “cursor” untuk menandai posisi saat ini dalam hasil query. Alih-alih menggunakan offset, kita mengirimkan cursor dari hasil sebelumnya untuk mendapatkan halaman berikutnya. Ini lebih efisien karena database hanya perlu mencari rekaman yang memiliki nilai cursor lebih besar dari nilai cursor sebelumnya.\nSELECT * FROM members WHERE sort_column \u003e 'cursor_value' ORDER BY sort_column LIMIT 10; Kelebihan:\nPerforma lebih baik: Tidak perlu memindai seluruh tabel untuk setiap permintaan halaman. Hasil yang konsisten: Hasil query selalu sama, terlepas dari perubahan data yang terjadi di antara permintaan.\nKekurangan:\nImplementasi lebih kompleks: Membutuhkan perencanaan yang matang dalam memilih kolom cursor yang tepat. Tidak cocok untuk semua jenis query: Hanya efektif untuk query yang diurutkan berdasarkan satu atau beberapa kolom.\nSeek Method Explanation of the seek method for pagination. Advantages: More efficient for certain types of queries.\n","wordCount":"1274","inLanguage":"en","datePublished":"2024-07-27T17:33:10+08:00","dateModified":"2024-07-27T17:33:10+08:00","author":{"@type":"Person","name":"Muchlis"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/post/pagination/"},"publisher":{"@type":"Organization","name":"Muchlis Dev","logo":{"@type":"ImageObject","url":"http://localhost:1313/icon/favicon.ico"}}}</script><link rel=stylesheet href=http://localhost:1313/css/custom-styles.min.846e2c0c38b3403ffecfec3d9c9b227dcfa79e75b178a91e1a26ae745cf5da5a.css><script src=http://localhost:1313/js/clickable-image.min.64e4ed1fd2302afde6a6750edcf663d18d6bf3b36d95ac130501827d8732c7a3.js defer></script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/icon/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://muchlis.dev title="Portfolio (2021)"><span>Portfolio (2021)</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count</h1><div class=post-description>Bagaimana cara paling optimal dalam melakukan pagination di sisi backend</div><div class=post-meta><span title='2024-07-27 17:33:10 +0800 WITA'>July 27, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1274 words&nbsp;·&nbsp;Muchlis&nbsp;|&nbsp;<a href=https://github.com/muchlist/paper/tree/main/content/post/pagination.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#pentingnya-pagination-dan-tantangannya>Pentingnya Pagination dan Tantangannya</a></li><li><a href=#masalah-limit-offset>Masalah LIMIT OFFSET</a><ul><li><a href=#isu-performa>Isu Performa</a></li></ul></li><li><a href=#alternatif-limit-offset->Alternatif Limit Offset ?</a><ul><li><a href=#cursor-based-pagination>Cursor-based Pagination</a></li><li><a href=#seek-method>Seek Method</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>Pagination adalah teknik umum untuk membagi hasil query database menjadi bagian-bagian yang lebih kecil. Meskipun LIMIT OFFSET adalah metode yang sederhana, metode ini memiliki beberapa kelemahan, terutama dalam hal performa pada dataset yang sangat besar. Artikel ini akan membahas masalah-masalah yang sering muncul saat menggunakan LIMIT OFFSET dan mengeksplorasi alternatif yang lebih efisien, seperti cursor-based pagination dan seek method.</p><h2 id=pentingnya-pagination-dan-tantangannya>Pentingnya Pagination dan Tantangannya<a hidden class=anchor aria-hidden=true href=#pentingnya-pagination-dan-tantangannya>#</a></h2><p>Pagination memiliki beberapa manfaat signifikan:</p><ul><li><p>Performance: Mengembalikan data yang besar sekaligus itu lambat dan memakan banyak sumber daya. Dengan membagi data menjadi potongan-potongan yang lebih kecil, API bisa mengembalikan data lebih cepat dan dengan sumber daya yang lebih sedikit.</p></li><li><p>Memory Management: Memproses data yang besar dapat memerlukan banyak memori, yang bisa menjadi masalah untuk perangkat dengan sumber daya terbatas seperti ponsel. Dengan menggunakan pagination, API dapat membatasi jumlah data yang perlu disimpan dalam memori pada suatu waktu.</p></li><li><p>User Experience: Untuk aplikasi klien yang menampilkan data kepada pengguna, pagination dapat meningkatkan pengalaman pengguna dengan menyediakan antarmuka yang lebih cepat dan responsif. Pengguna dapat melihat hasil awal dengan cepat dan dapat meminta data tambahan sesuai kebutuhan.</p></li></ul><p>Namun, penting untuk diingat bahwa pagination tidak selalu menjadi solusi yang sempurna. Pada dataset yang sangat besar, bahkan pagination pun dapat menghadapi tantangan.</p><h2 id=masalah-limit-offset>Masalah LIMIT OFFSET<a hidden class=anchor aria-hidden=true href=#masalah-limit-offset>#</a></h2><p>Disini kita akan bahas kekurangan dari cara pagination menggunakan LIMIT OFFSET.</p><h3 id=isu-performa>Isu Performa<a hidden class=anchor aria-hidden=true href=#isu-performa>#</a></h3><h4 id=mengapa-limit-offset-lambat-untuk-dataset-besar>Mengapa LIMIT OFFSET Lambat untuk Dataset Besar?<a hidden class=anchor aria-hidden=true href=#mengapa-limit-offset-lambat-untuk-dataset-besar>#</a></h4><p>Saat berhadapan dengan dataset yang sangat besar, pagination menggunakan LIMIT OFFSET seringkali mengalami penurunan performa. Ini karena setiap kali kita meminta halaman baru, database harus memindai seluruh tabel dari awal untuk menemukan data yang sesuai, meskipun kita hanya membutuhkan sebagian kecil data.</p><p>Berikut adalah contoh query SQL yang menunjukkan bagaimana LIMIT dan OFFSET diterapkan:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>records</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>LIMIT</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=k>OFFSET</span><span class=w> </span><span class=mi>1000</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>Penjelasan:</p><p><code>LIMIT</code> menentukan jumlah maksimal baris yang dikembalikan.<br><code>OFFSET</code> menentukan berapa banyak baris yang harus dilewati sebelum mulai mengembalikan hasil.</p><p>Pada contoh di atas, query tersebut sebenarnya akan memindai 1000 baris pertama, membuang data yang tidak diperlukan, dan mengembalikan 10 baris berikutnya. Jika tabel memiliki jutaan baris, melewati sejumlah besar baris dengan offset yang besar akan membuat query berjalan lebih lambat karena database harus memindai semua baris tersebut sebelum mengembalikan hasil.</p><p>Artinya jika klien melakukan permintaaan page 2, page 3 dan seterusnya maka akan menyebabkan database harus memproses berkali-kali lipat data dibandingkan dengan jumlah yang sebenarnya dikembalikan kepada klien.</p><p>Sebagai ilustrasi, asumsi jika 1 halaman menampilkan 100 data:</p><ul><li><code>Untuk page 1: OFFSET 0, LIMIT 100</code> -> memindai dan mengembalikan 100 baris.</li><li><code>Untuk page 2: OFFSET 100, LIMIT 100</code> -> memindai dan membuang 100 baris, kemudian memindai dan mengembalikan 100 baris berikutnya.</li><li><code>Untuk page 3: OFFSET 200, LIMIT 100</code> -> memindai dan membuang 200 baris, kemudian memindai dan mengembalikan 100 baris berikutnya.</li><li><code>Untuk page 100: OFFSET 10000, LIMIT 100</code> -> memindai dan membuang 10000 baris, kemudian memindai dan mengembalikan 100 baris berikutnya.</li></ul><p>Semakin besar nilai offset, semakin banyak baris yang perlu dipindai dan dibuang, yang membuat query semakin lambat dan tidak efisien. Ini menjadi sangat buruk untuk tabel dengan jutaan baris karena memproses dan membuang banyak data setiap kali ada permintaan halaman baru.</p><p>Worst Case : Client ingin mendapatkan semua data dengan cara melakukan scan dari page 1 sampai dengan page terakhir.</p><p>Bayangkan kita ingin membaca sebuah buku yang sangat tebal halaman demi halaman. Jika kita menggunakan metode LIMIT dan OFFSET, kita harus membuka buku dari awal setiap kali ingin membaca halaman berikutnya. Ini tentu sangat tidak efisien, karena kita akan mengulang-ulang membuka halaman yang sama. Dalam konteks database, hal ini sama dengan membuat database bekerja lebih keras dari yang seharusnya. Oleh karena itu, jika tujuan kita adalah mendapatkan semua data, lebih baik kita langsung mengambil seluruh buku (data) sekaligus, lalu membacanya (memprosesnya) di aplikasi.</p><h4 id=dampak-query-count-terhadap-performa>Dampak Query COUNT(*) terhadap Performa<a hidden class=anchor aria-hidden=true href=#dampak-query-count-terhadap-performa>#</a></h4><p>Tidak hanya itu, dalam implementasi pagination menggunakan LIMIT dan OFFSET, query COUNT(*) sering digunakan untuk menghitung jumlah total baris dalam dataset. Informasi ini diperlukan untuk menyusun metadata pagination, seperti jumlah total halaman dan jumlah total item, yang kemudian dikembalikan dalam respon API.</p><p>Sebagai contoh, respon API mungkin memiliki struktur sebagai berikut:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;message&#34;</span><span class=p>:</span> <span class=s2>&#34;successfully fetch data&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;data&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;meta&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;current_page&#34;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;page_size&#34;</span><span class=p>:</span> <span class=mi>100</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;total_count&#34;</span><span class=p>:</span> <span class=mi>3000</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;total_page&#34;</span><span class=p>:</span> <span class=mi>30</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Untuk menghasilkan metadata ini, backend perlu melakukan dua query:</p><ol><li>Untuk mengambil data dengan LIMIT dan OFFSET</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>members</span><span class=w> </span><span class=k>LIMIT</span><span class=w> </span><span class=mi>100</span><span class=w> </span><span class=k>OFFSET</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><ol start=2><li>Untuk menghitung jumlah total baris dengan COUNT(*)</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>members</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>Penggunaan COUNT(*) pada dataset besar seringkali mengakibatkan penurunan performa yang signifikan. Hal ini dikarenakan:</p><ul><li>Full table scan: Database perlu memindai seluruh tabel untuk menghitung jumlah baris, terutama jika tidak ada indeks yang sesuai.</li><li>Kurangnya optimasi indeks: COUNT(*) seringkali tidak dapat dioptimalkan dengan indeks, sehingga waktu eksekusi query menjadi lebih lama.</li><li>Masalah konkurensi dan locking: Query COUNT(*) dapat menyebabkan konflik dengan query lain dan menghambat kinerja sistem.</li><li>Beban I/O yang tinggi: Proses penghitungan jumlah baris memerlukan banyak operasi baca-tulis disk.</li></ul><p>Masalah ini mungkin tidak terlihat jelas pada awal pengembangan, tetapi akan semakin terasa ketika volume data terus bertambah. Pengalaman saya mendorong saya untuk menulis artikel ini. Teknik alternatif dan optimasi dapat menjadi solusi yang baik untuk mengatasinya.</p><h4 id=optimasi-database-query-limit-offset>Optimasi Database Query LIMIT OFFSET<a hidden class=anchor aria-hidden=true href=#optimasi-database-query-limit-offset>#</a></h4><p>Dalam studi kasus ini ternyata query untuk pagination dapat dioptimalkan, namun query count belum tentu. Sehingga pilihan yang paling tepat adalah mengganti strategy ke pagination alternative.</p><p>Bagaimana cara mengoptimalkan query LIMIT OFFSET ?
Teknik ini justru saya temukan di library yang digunakan pada bahasa lain, PHP Laravel. yang dapat dicontoh pada library ini : <a href=https://github.com/hammerstonedev/fast-paginate>https://github.com/hammerstonedev/fast-paginate</a>
Apa yang dilakukan untuk membuat peformanya menjadi lebih baik ?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>members</span><span class=w>              </span><span class=c1>-- The full data that you want to show your users.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>where</span><span class=w> </span><span class=n>members</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=p>(</span><span class=w>          </span><span class=c1>-- The &#34;deferred join&#34; or subquery, in our case.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=k>select</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>members</span><span class=w>     </span><span class=c1>-- The pagination, accessing as little data as possible - ID only.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=k>limit</span><span class=w> </span><span class=mi>15</span><span class=w> </span><span class=k>offset</span><span class=w> </span><span class=mi>150000</span><span class=w>      
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><p>Idenya adalah agar melakukan penerapan LIMIT dan OFFSET pada data yang scopenya lebih kecil, baru kemudian hasilnya dicari untuk membuat data yang lengkap.</p><p>Sayangnya, teknik optimasi pada query LIMIT OFFSET tidak sepenuhnya menyelesaikan masalah, terutama untuk query COUNT(*) pada dataset besar. Hal ini terlihat pada hasil benchmark yang saya lakukan.</p><figure><img src=/img/pagination/jaeger-trace-query-count.webp alt="jaeger trace query count" class="clickable-image lazyload" data-src=/img/pagination/jaeger-trace-query-count.webp loading=lazy></figure><p>Meskipun visualisasi data yang lengkap belum dapat saya sajikan pada artikel ini, hasil benchmark menunjukkan perbedaan kinerja yang signifikan antara query untuk mengambil data dan query COUNT(*).</p><p>Dari studi kasus ini, saya menarik beberapa kesimpulan penting:</p><ul><li><code>Jumlah query tidak selalu menentukan kinerja</code>: Tidak selalu benar bahwa semakin sedikit permintaan query yang kita jalankan, semakin baik performanya. Dalam beberapa kasus, membagi query kompleks menjadi beberapa query yang lebih kecil justru dapat meningkatkan kinerja secara keseluruhan.</li><li><code>Indeks tidak selalu optimal untuk COUNT(*)</code>: Meskipun indeks dapat meningkatkan kinerja query secara umum, pada kasus COUNT(*) indeks tidak selalu efektif.</li><li><code>Pentingnya benchmark</code>: Membandingkan kinerja sebelum dan sesudah perubahan query adalah cara yang paling akurat untuk mengukur dampak dari suatu optimasi.</li></ul><h2 id=alternatif-limit-offset->Alternatif Limit Offset ?<a hidden class=anchor aria-hidden=true href=#alternatif-limit-offset->#</a></h2><h3 id=cursor-based-pagination>Cursor-based Pagination<a hidden class=anchor aria-hidden=true href=#cursor-based-pagination>#</a></h3><p>Cursor-based pagination menggunakan nilai unik dari suatu kolom (biasanya kolom yang diurutkan) sebagai &ldquo;cursor&rdquo; untuk menandai posisi saat ini dalam hasil query. Alih-alih menggunakan offset, kita mengirimkan cursor dari hasil sebelumnya untuk mendapatkan halaman berikutnya. Ini lebih efisien karena database hanya perlu mencari rekaman yang memiliki nilai cursor lebih besar dari nilai cursor sebelumnya.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>members</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>sort_column</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=s1>&#39;cursor_value&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>sort_column</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>LIMIT</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>Kelebihan:</p><p>Performa lebih baik: Tidak perlu memindai seluruh tabel untuk setiap permintaan halaman.
Hasil yang konsisten: Hasil query selalu sama, terlepas dari perubahan data yang terjadi di antara permintaan.</p><p>Kekurangan:</p><p>Implementasi lebih kompleks: Membutuhkan perencanaan yang matang dalam memilih kolom cursor yang tepat.
Tidak cocok untuk semua jenis query: Hanya efektif untuk query yang diurutkan berdasarkan satu atau beberapa kolom.</p><h3 id=seek-method>Seek Method<a hidden class=anchor aria-hidden=true href=#seek-method>#</a></h3><p>Explanation of the seek method for pagination.
Advantages: More efficient for certain types of queries.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/golang/>Golang</a></li><li><a href=http://localhost:1313/tags/database/>Database</a></li><li><a href=http://localhost:1313/tags/optimization/>Optimization</a></li><li><a href=http://localhost:1313/tags/best-practice/>Best Practice</a></li></ul><nav class=paginav><a class=next href=http://localhost:1313/post/structuring-project-folder/><span class=title>Next »</span><br><span>Struktur Folder dan Aturan Penulisan Kode dalam Project Golang: Preferensi Pribadi</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count on x" href="https://x.com/intent/tweet/?text=Kekurangan%20Backend%20Pagination%20Menggunakan%20Limit%2c%20Offset%2c%20dan%20Total%20Count&amp;url=http%3a%2f%2flocalhost%3a1313%2fpost%2fpagination%2f&amp;hashtags=Golang%2cDatabase%2cOptimization%2cBestPractice"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fpost%2fpagination%2f&amp;title=Kekurangan%20Backend%20Pagination%20Menggunakan%20Limit%2c%20Offset%2c%20dan%20Total%20Count&amp;summary=Kekurangan%20Backend%20Pagination%20Menggunakan%20Limit%2c%20Offset%2c%20dan%20Total%20Count&amp;source=http%3a%2f%2flocalhost%3a1313%2fpost%2fpagination%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fpost%2fpagination%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count on whatsapp" href="https://api.whatsapp.com/send?text=Kekurangan%20Backend%20Pagination%20Menggunakan%20Limit%2c%20Offset%2c%20dan%20Total%20Count%20-%20http%3a%2f%2flocalhost%3a1313%2fpost%2fpagination%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kekurangan Backend Pagination Menggunakan Limit, Offset, dan Total Count on telegram" href="https://telegram.me/share/url?text=Kekurangan%20Backend%20Pagination%20Menggunakan%20Limit%2c%20Offset%2c%20dan%20Total%20Count&amp;url=http%3a%2f%2flocalhost%3a1313%2fpost%2fpagination%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=muchlist/paper data-repo-id=R_kgDOMD4syA data-category=General data-category-id=DIC_kwDOMD4syM4ChOKX data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=id data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Muchlis Dev</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>