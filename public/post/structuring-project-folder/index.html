<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Struktur Folder dan Aturan Penulisan Kode dalam Project Golang: Preferensi Pribadi | Muchlis Dev</title>
<meta name=keywords content="Golang,Best Practices"><meta name=description content="Golang Struktur Folder dengan Arsitektur Hexagonal"><meta name=author content="Muchlis"><link rel=canonical href=https://blog.muchlis.dev/post/structuring-project-folder/><meta name=google-site-verification content="G-F1ZZCKLSJF"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.muchlis.dev/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.muchlis.dev/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.muchlis.dev/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.muchlis.dev/icon/apple-touch-icon.png><link rel=mask-icon href=https://blog.muchlis.dev/icon/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.muchlis.dev/post/structuring-project-folder/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F1ZZCKLSJF"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F1ZZCKLSJF")}</script><meta property="og:title" content="Struktur Folder dan Aturan Penulisan Kode dalam Project Golang: Preferensi Pribadi"><meta property="og:description" content="Golang Struktur Folder dengan Arsitektur Hexagonal"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.muchlis.dev/post/structuring-project-folder/"><meta property="og:image" content="https://blog.muchlis.dev/img/project/hexagonal-architecture.webp"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-07-20T16:06:50+08:00"><meta property="article:modified_time" content="2024-07-20T16:06:50+08:00"><meta property="og:site_name" content="Muchlis Dev"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.muchlis.dev/img/project/hexagonal-architecture.webp"><meta name=twitter:title content="Struktur Folder dan Aturan Penulisan Kode dalam Project Golang: Preferensi Pribadi"><meta name=twitter:description content="Golang Struktur Folder dengan Arsitektur Hexagonal"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.muchlis.dev/post/"},{"@type":"ListItem","position":2,"name":"Struktur Folder dan Aturan Penulisan Kode dalam Project Golang: Preferensi Pribadi","item":"https://blog.muchlis.dev/post/structuring-project-folder/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Struktur Folder dan Aturan Penulisan Kode dalam Project Golang: Preferensi Pribadi","name":"Struktur Folder dan Aturan Penulisan Kode dalam Project Golang: Preferensi Pribadi","description":"Golang Struktur Folder dengan Arsitektur Hexagonal","keywords":["Golang","Best Practices"],"articleBody":"Seringkali, program yang kita buat tidak hanya berupa server HTTP, tetapi juga mencakup komponen seperti event consumer, CLI, migrasi database dengan logika, atau kombinasi dari semuanya. Struktur ini saya gunakan untuk memungkinkan semua itu. Selain itu, fokus lainnya adalah pada pemisahan logika inti dari ketergantungan eksternal, sehingga memungkinkan penggunaan ulang kode dalam berbagai mode aplikasi.\nLink Repository : https://github.com/muchlist/templaterepo\nPrinsip-prinsip yang mendasari desain ini : Arsitektur Hexagonal: Memisahkan logika inti dari ketergantungan eksternal untuk menjaga kebersihan kode dan memudahkan pengujian. Pengelolaan Dependensi: Menghindari error siklus dependensi dengan menerapkan prinsip dependency injection dan dependency inversion, sehingga modul-modul dapat saling berinteraksi tanpa saling bergantung secara langsung. Kejelasan Struktur Kode: Menggunakan folder pkg/ untuk kode yang dapat digunakan ulang di berbagai bagian aplikasi dan folder business/ untuk menyimpan logika bisnis dan domain khusus. Aturan Pengembangan Aplikasi: Menetapkan aturan untuk pengelolaan konfigurasi, penanganan kesalahan, dan penamaan untuk memastikan konsistensi dan kualitas kode. Alat Bantu: Memanfaatkan Makefile untuk mempercepat proses pengembangan dan pre-commit hooks untuk menjaga kualitas kode dan mencegah kesalahan sebelum kode di-commit. Tujuan : Konsistensi Pengembangan: Menyediakan metode yang seragam dalam membangun aplikasi untuk meningkatkan pemahaman dan kolaborasi tim. Modularitas: Memastikan kode terpisah antar modul dan tidak tightly coupled, sehingga memudahkan pemeliharaan dan pengembangan lebih lanjut. Arsitektur yang Bersih: Mengikuti prinsip arsitektur hexagonal untuk memisahkan logika inti dari ketergantungan eksternal, meningkatkan fleksibilitas dan kemudahan pengujian. Manajemen Dependensi yang Efektif: Menghindari error siklus dependensi meskipun ada banyak modul yang saling terhubung, melalui penerapan prinsip dependency inversion. Kode yang Testable: Memastikan bahwa kode di lapisan logika dapat diuji dengan baik, meningkatkan kualitas dan keandalan aplikasi. Konseptual Hexagonal Architecture Arsitektur hexagonal (biasa disebut juga port and adapter) berfokus pada pemisahan core logika dari ketergantungan eksternal. Core harus bersih, hanya terdiri dari pustaka standar dan kode pembungkus yang dibangun dalam repositori ini.\nCore : Berisi logika bisnis aplikasi. Ports : Antarmuka yang mendefinisikan bagaimana bagian luar sistem dapat berinteraksi dengan core. Ports bisa berupa antarmuka (interface) yang digunakan oleh core untuk berinteraksi dengan komponen eksternal seperti database, provider notifikasi, dll. Adapters : Implementasi dari ports. Adapters menerapkan antarmuka yang didefinisikan oleh ports untuk menghubungkan core dengan komponen eksternal. Project structure ├── app │ ├── api-user │ │ ├── handler │ │ │ ├── health_check.go │ │ │ └── user.go │ │ ├── main.go │ │ └── url_map.go │ ├── consumer-user │ │ └── main.go │ └── tool-logfmt │ └── main.go ├── business │ ├── complex │ │ ├── helper │ │ │ └── formula.go │ │ ├── ports │ │ │ └── storer.go │ │ ├── repo │ │ │ └── repo.go │ │ └── service │ │ └── service.go │ ├── notifserv │ │ └── service.go │ └── user │ ├── repo.go │ ├── service.go │ └── storer.go ├── conf │ ├── conf.go │ └── confs.go ├── go.mod ├── go.sum ├── migrations │ ├── 000001_create_user.down.sql │ └── 000001_create_user.up.sql ├── models │ ├── notif │ │ └── notif.go │ └── user │ ├── user_dto.go │ └── user_entity.go └── pkg ├── db-pg │ └── db.go ├── errr │ └── custom_err.go ├── mid │ └── middleware.go ├── mlog │ ├── log.go │ └── logger.go └── validate └── validate.go Folder: app/ Menyimpan kode yang tidak dapat digunakan ulang. Titik awal program ketika dijalankan :\nMemulai dan menghentikan aplikasi. Spesifik untuk operasi input/output. Pada kebanyakan projek lainnya, folder ini akan dinamakan dengan cmd. Dinamakan app karena posisi folder akan berada diatas (yang mana dirasa cukup bagus) dan cukup mewakili fungsi folder.\nAlih-alih menggunakan kerangka kerja seperti Cobra untuk memilih aplikasi yang dijalankan, kita menggunakan metode paling sederhana seperti menjalankan program dengan go run ./app/api-user untuk aplikasi API-USER dan go run ./app/consumer-user untuk aplikasi KAFKA-USER-CONSUMER.\nFolder: pkg/ Berisi paket-paket yang dapat digunakan ulang di mana saja, biasanya elemen dasar yang tidak terkait dengan modul bisnis, seperti logger, web framework, dan helper umum. Tempat untuk meletakkan library yang sudah di wrap agar mudah di mock. Lapisan aplikasi dan lapisan bisnis dapat mengimpor pkg.\nMenggunakan pkg/ sebagai penampung kode yang awalnya tidak jelas tempatnya terbukti mempercepat penulisan kode. Pertanyaan seperti \"Taruh di mana?\" akan mendapatkan jawaban \"Taruh di pkg.\" secara default.\nFolder: business/ atau internal/ Berisi code yang terkait dengan logika bisnis, problem bisnis, data bisnis.\nFolder: business/{nama-domain}/* Dalam setiap domain bisnis, ada layer service (atau core dalam istilah hexagonal) yang harus tetap bersih dari pustaka eksternal. Ini mencakup lapisan untuk mengakses data persisten (repo) dan interface-interface yang berfungsi sebagai port.\nFolder: business/{nama-domain}/{subfolder} Terkadang, sebuah domain dapat menjadi sangat kompleks, sehingga perlu memisahkan service, repo, dan elemen lainnya ke dalam beberapa bagian. Dalam kasus seperti ini, kita lebih memilih untuk mengatur dan memisahkan komponen-komponen tersebut ke dalam folder yang berbeda, yang juga akan memerlukan penggunaan package yang berbeda. Misalnya, business/complex.\nFolder: models Model-model (termasuk DTO, Payload, Entitas) dapat diletakkan di dalam package bisnis masing-masing. Namun, dalam kasus yang kompleks, di mana aplikasi A membutuhkan model B dan C, kita bisa mempertimbangkan untuk menempatkan model-model tersebut di level yang lebih tinggi agar dapat diakses oleh semuanya.\nRules Sangat penting untuk membuat dan memperbarui aturan yang telah disepakati agar semua pihak mengikuti pendekatan yang konsisten. Misalnya, template repositori ini didasarkan pada kemampuannya untuk menghindari kode yang terlalu terikat (tightly-coupled), maka aturan Cara Penulisan Dependensi Kode menjadi sangat penting untuk dipatuhi.\nAturan ini akan bertambah seiring berjalannya waktu. Misalnya, yang seringkali terjadi perbedaan pendapat :\nBagaimana cara melakukan database transaction di logic layer ? Seberapa dalam kondisi if else boleh dilakukan. dsb. Cara Penulisan Dependensi Kode Menggunakan Dependency Injection : Dependency Injection (DI) adalah pola desain di mana dependensi disediakan dari luar objek tersebut. Ini membantu mengelola ketergantungan antar komponen, membuat kode lebih modular, dan memudahkan pengujian. Jadi, modul yang saling ketergantungan, harus bergantung pada abstraksi.\nContoh konstruktor untuk membuat logic service user business/user/service.go\ntype UserService struct { storer UserStorer notifier NotifSender } // NewUserService memerlukan UserStorer dan NotifSender. // UserStorer dan NotifSender adalah abstraksi yang diperlukan oleh UserService // Objek yang akan memenuhi UserStorer dan NotifSender ini akan ditentukan oleh // pengaturan dependensi di folder /app. // UserStorer dan NotifSender juga dapat dibuat tiruannya untuk memudahkan pengujian func NewUserService(store UserStorer, notifier NotifSender) *UserService { return \u0026UserService{storer: store, notifier: notifier} } Menerapkan Prinsip Dependency Inversion: Di lapisan business, terutama untuk bagian logic (biasanya dinamakan service.go atau usecase.go atau core), komunikasi antar layer mengandalkan abstraksi dan penerapan prinsip dependency inversion yang kuat. Dalam golang, dependensi inversi yang sesungguhnya bisa dicapai seperti penjelasan pada gambar berikut.\nMengenai posisi interface, sebaiknya diletakkan pada modul yang membutuhkannya. Hal ini pernah dibahas dalam buku 100 Go Mistake and how to avoid them dan beberapa buku lainnya.\nMisalnya, domain business/user memerlukan fungsi untuk mengirimkan notifikasi yang bisa dipenuhi oleh business/notifserv, namun tidak secara gamblang business/user mengatakan perlu business/notifserv, melainkan lebih kepada mengatakan \"Saya perlu unit yang bisa menjalankan SendNotification()\" – titik.\nImplementasi dependensinya dapat dilihat di app/api-user/routing.go. Metode ini mencegah error siklus dependensi impor dan memastikan kode tetap tidak terlalu terikat (tightly-coupled) antar domain.\nContoh dependensi yang dibutuhkan untuk membuat core logic user business/user/storer.go:\npackage user import ( \"context\" modelUser \"templaterepo/models/user\" ) // UserStorer adalah interface yang mendefinisikan operasi yang dapat dilakukan terhadap database user. // Interface ini Merupakan milik dari layer service dan dimaksudkan ditulis pada bagian layer service // Meskipun kita tau persis implementasinya ada di business/user/repo.go, tetap layer service (core) hanya bergantung pada interface ini. // Implementasi konkret dari antarmuka ini akan ditentukan oleh pengaturan dependensi di folder /app. type UserStorer interface { Get(ctx context.Context, uid string) (modelUser.UserDTO, error) CreateOne(ctx context.Context, user *modelUser.UserEntity) error } // NotifSender adalah interface yang mendefinisikan operasi untuk mengirim notifikasi. // Interface ini Merupakan milik dari layer service dan dimaksudkan ditulis pada bagian layer service // Objek yang digunakan untuk mengirim notifikasi akan ditentukan oleh pengaturan dependensi di folder /app. type NotifSender interface { SendNotification(message string) error } Contoh konstruktor untuk membuat notif business/notifserv/service.go\npackage notifserv type NotifService struct{} // return konkrit struct, bukan interfacenya // karena NotifService tidak dikekang hanya untuk menjadi NotifSender func NewNotifServ() *NotifService { return \u0026NotifService{} } // SendNotification diperlukan untuk memenuhi interface NotifSender pada service user func (n *NotifService) SendNotification(message string) error { // TODO : send notif to other server return nil } // SendWhatsapp tidak diperlukan oleh service user namun bisa jadi diperlukan oleh service lain func (n *NotifService) SendWhatsapp(message string, phone string) error { // TODO : send whatsapp return nil } Aturan Lainnya yang Disepakati Ikuti panduan gaya Uber sebagai dasar (https://github.com/uber-go/guide/blob/master/style.md). Aturan ini akan ditimpa apabila ada aturan yang tertulis disini. File konfigurasi hanya boleh diakses di main.go. Lapisan lain yang ingin mengakses konfigurasi harus menerimanya melalui parameter fungsi. Konfigurasi harus memiliki nilai default yang berfungsi di environment lokal, yang dapat ditimpa oleh file .env dan argumen pada command line. Error harus dihandle hanya sekali dan tidak boleh di abaikan. Maksudnya adalah antara di konsumsi atau di return, tetapi tidak keduanya sekaligus. contoh konsumsi : menulis error pada log, contoh return : mereturn error apabila error tidak nil. Jangan mengekspose variable dalam package, Gunakan kombinasi variabel private dan fungsi publik sebagai gantinya. Ketika kode banyak digunakan, buatlah helper.go. Namun jika digunakan di beberapa paket, buatlah paket baru (misalnya untuk mengekstrak error yang cuma ada di user, /business/user/ipkg/error_parser.go). Jika penggunaannya sangat luas, masukkan di /pkg (misalnya, pkg/slicer/slicer.go, pkg/datastructure/ds.go, pkg/errr/custom_error.go). Patuhi idiom golang. Namakan interface dengan akhiran -er atau -tor untuk menunjukkan bahwa mereka adalah interface, misalnya Writer, Reader, Assumer, Saver, Reader, Generator. (https://go.dev/doc/effective_go#interface-names). Contoh: Dalam proyek dengan tiga lapisan: UserServiceAssumer, UserStorer, UserSaver, UserLoader. Tools Makefile Makefile berisi command untuk membantu proses menjalankan aplikasi dengan cepat karena tidak harus mengingat semua command yang panjang. Berfungsi seperti alias. Caranya adalah dengan menuliskan cmd di file Makefile seperti contoh berikut.\nBaris teratas adalah comment yang akan muncul ketika memanggil helper.\n.PHONY adalah penanda agar terminal tidak menganggap command makefile sebagai akses ke file.\nrun/tidy: adalah alias untuk cmd yang ada didalam nya.\n## run/tidy: run golang formater and tidying code .PHONY: run/tidy run/tidy: @echo 'Tidying and verifying module dependencies...' go mod tidy go mod verify @echo 'Formatting code...' go fmt ./... Sebagai contoh, untuk menjalankan aplikasi-aplikasi yang ada di repositori ini kita bisa menggunakan command seperti dibawah ini :\n# 1. pastikan ketersediaan dependency seperti database dll. # 2. menjalankan aplikasi dengan makefile (lihat file Makefile) $ make run/api/user # command tersebut akan mengeksekusi $ go run ./app/api-user # sehingga mode http server dari aplikasi akan dijalankan pre-commit Disarankan menggunakan pre-commit (https://pre-commit.com/).\n// init pre-commit install // precommit akan di trigger setiap commit // manual pre-commit run --all-files ","wordCount":"1729","inLanguage":"en","image":"https://blog.muchlis.dev/img/project/hexagonal-architecture.webp","datePublished":"2024-07-20T16:06:50+08:00","dateModified":"2024-07-20T16:06:50+08:00","author":{"@type":"Person","name":"Muchlis"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.muchlis.dev/post/structuring-project-folder/"},"publisher":{"@type":"Organization","name":"Muchlis Dev","logo":{"@type":"ImageObject","url":"https://blog.muchlis.dev/icon/favicon.ico"}}}</script><link rel=stylesheet href=https://blog.muchlis.dev/css/custom-styles.min.846e2c0c38b3403ffecfec3d9c9b227dcfa79e75b178a91e1a26ae745cf5da5a.css><script src=https://blog.muchlis.dev/js/clickable-image.min.64e4ed1fd2302afde6a6750edcf663d18d6bf3b36d95ac130501827d8732c7a3.js defer></script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.muchlis.dev/ accesskey=h title="Home (Alt + H)"><img src=https://blog.muchlis.dev/icon/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.muchlis.dev/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.muchlis.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.muchlis.dev/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://muchlis.dev title="Portfolio (2021)"><span>Portfolio (2021)</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.muchlis.dev/>Home</a>&nbsp;»&nbsp;<a href=https://blog.muchlis.dev/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Struktur Folder dan Aturan Penulisan Kode dalam Project Golang: Preferensi Pribadi</h1><div class=post-description>Golang Struktur Folder dengan Arsitektur Hexagonal</div><div class=post-meta><span title='2024-07-20 16:06:50 +0800 WITA'>July 20, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1729 words&nbsp;·&nbsp;Muchlis&nbsp;|&nbsp;<a href=https://github.com/muchlist/paper/tree/main/content/post/structuring-project-folder.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#prinsip-prinsip-yang-mendasari-desain-ini->Prinsip-prinsip yang mendasari desain ini :</a></li><li><a href=#tujuan->Tujuan :</a><ul><li><a href=#konseptual-hexagonal-architecture>Konseptual Hexagonal Architecture</a></li></ul></li><li><a href=#project-structure>Project structure</a><ul><li><a href=#folder-app>Folder: app/</a></li><li><a href=#folder-pkg>Folder: pkg/</a></li><li><a href=#folder-business-atau-internal>Folder: business/ atau internal/</a></li><li><a href=#folder-models>Folder: models</a></li></ul></li><li><a href=#rules>Rules</a><ul><li><a href=#cara-penulisan-dependensi-kode>Cara Penulisan Dependensi Kode</a></li><li><a href=#aturan-lainnya-yang-disepakati>Aturan Lainnya yang Disepakati</a></li></ul></li><li><a href=#tools>Tools</a><ul><li><a href=#makefile>Makefile</a></li><li><a href=#pre-commit>pre-commit</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>Seringkali, program yang kita buat tidak hanya berupa server HTTP, tetapi juga mencakup komponen seperti event consumer, CLI, migrasi database dengan logika, atau kombinasi dari semuanya. Struktur ini saya gunakan untuk memungkinkan semua itu. Selain itu, fokus lainnya adalah pada pemisahan logika inti dari ketergantungan eksternal, sehingga memungkinkan penggunaan ulang kode dalam berbagai mode aplikasi.</p><p>Link Repository : <a href=https://github.com/muchlist/templaterepo>https://github.com/muchlist/templaterepo</a></p><h2 id=prinsip-prinsip-yang-mendasari-desain-ini->Prinsip-prinsip yang mendasari desain ini :<a hidden class=anchor aria-hidden=true href=#prinsip-prinsip-yang-mendasari-desain-ini->#</a></h2><ol><li>Arsitektur Hexagonal: Memisahkan logika inti dari ketergantungan eksternal untuk menjaga kebersihan kode dan memudahkan pengujian.</li><li>Pengelolaan Dependensi: Menghindari error siklus dependensi dengan menerapkan prinsip dependency injection dan dependency inversion, sehingga modul-modul dapat saling berinteraksi tanpa saling bergantung secara langsung.</li><li>Kejelasan Struktur Kode: Menggunakan folder <code>pkg/</code> untuk kode yang dapat digunakan ulang di berbagai bagian aplikasi dan folder <code>business/</code> untuk menyimpan logika bisnis dan domain khusus.</li><li>Aturan Pengembangan Aplikasi: Menetapkan aturan untuk pengelolaan konfigurasi, penanganan kesalahan, dan penamaan untuk memastikan konsistensi dan kualitas kode.</li><li>Alat Bantu: Memanfaatkan Makefile untuk mempercepat proses pengembangan dan pre-commit hooks untuk menjaga kualitas kode dan mencegah kesalahan sebelum kode di-commit.</li></ol><h2 id=tujuan->Tujuan :<a hidden class=anchor aria-hidden=true href=#tujuan->#</a></h2><ul><li>Konsistensi Pengembangan: Menyediakan metode yang seragam dalam membangun aplikasi untuk meningkatkan pemahaman dan kolaborasi tim.</li><li>Modularitas: Memastikan kode terpisah antar modul dan tidak tightly coupled, sehingga memudahkan pemeliharaan dan pengembangan lebih lanjut.</li><li>Arsitektur yang Bersih: Mengikuti prinsip arsitektur hexagonal untuk memisahkan logika inti dari ketergantungan eksternal, meningkatkan fleksibilitas dan kemudahan pengujian.</li><li>Manajemen Dependensi yang Efektif: Menghindari error siklus dependensi meskipun ada banyak modul yang saling terhubung, melalui penerapan prinsip dependency inversion.</li><li>Kode yang Testable: Memastikan bahwa kode di lapisan logika dapat diuji dengan baik, meningkatkan kualitas dan keandalan aplikasi.</li></ul><h3 id=konseptual-hexagonal-architecture>Konseptual Hexagonal Architecture<a hidden class=anchor aria-hidden=true href=#konseptual-hexagonal-architecture>#</a></h3><figure><img src=/img/project/hexagonal-architecture.webp alt="hexagonal architecture golang" class="clickable-image lazyload" data-src=/img/project/hexagonal-architecture.webp loading=lazy></figure><p>Arsitektur hexagonal (biasa disebut juga port and adapter) berfokus pada pemisahan core logika dari ketergantungan eksternal. Core harus bersih, hanya terdiri dari pustaka standar dan kode pembungkus yang dibangun dalam repositori ini.</p><ul><li><code>Core</code> : Berisi logika bisnis aplikasi.</li><li><code>Ports</code> : Antarmuka yang mendefinisikan bagaimana bagian luar sistem dapat berinteraksi dengan core. Ports bisa berupa antarmuka (interface) yang digunakan oleh core untuk berinteraksi dengan komponen eksternal seperti database, provider notifikasi, dll.</li><li><code>Adapters</code> : Implementasi dari ports. Adapters menerapkan antarmuka yang didefinisikan oleh ports untuk menghubungkan core dengan komponen eksternal.</li></ul><h2 id=project-structure>Project structure<a hidden class=anchor aria-hidden=true href=#project-structure>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>├── app
</span></span><span class=line><span class=cl>│   ├── api-user
</span></span><span class=line><span class=cl>│   │   ├── handler
</span></span><span class=line><span class=cl>│   │   │   ├── health_check.go
</span></span><span class=line><span class=cl>│   │   │   └── user.go
</span></span><span class=line><span class=cl>│   │   ├── main.go
</span></span><span class=line><span class=cl>│   │   └── url_map.go
</span></span><span class=line><span class=cl>│   ├── consumer-user
</span></span><span class=line><span class=cl>│   │   └── main.go
</span></span><span class=line><span class=cl>│   └── tool-logfmt
</span></span><span class=line><span class=cl>│       └── main.go
</span></span><span class=line><span class=cl>├── business
</span></span><span class=line><span class=cl>│   ├── complex
</span></span><span class=line><span class=cl>│   │   ├── helper
</span></span><span class=line><span class=cl>│   │   │   └── formula.go
</span></span><span class=line><span class=cl>│   │   ├── ports
</span></span><span class=line><span class=cl>│   │   │   └── storer.go
</span></span><span class=line><span class=cl>│   │   ├── repo
</span></span><span class=line><span class=cl>│   │   │   └── repo.go
</span></span><span class=line><span class=cl>│   │   └── service
</span></span><span class=line><span class=cl>│   │       └── service.go
</span></span><span class=line><span class=cl>│   ├── notifserv
</span></span><span class=line><span class=cl>│   │   └── service.go
</span></span><span class=line><span class=cl>│   └── user
</span></span><span class=line><span class=cl>│       ├── repo.go
</span></span><span class=line><span class=cl>│       ├── service.go
</span></span><span class=line><span class=cl>│       └── storer.go
</span></span><span class=line><span class=cl>├── conf
</span></span><span class=line><span class=cl>│   ├── conf.go
</span></span><span class=line><span class=cl>│   └── confs.go
</span></span><span class=line><span class=cl>├── go.mod
</span></span><span class=line><span class=cl>├── go.sum
</span></span><span class=line><span class=cl>├── migrations
</span></span><span class=line><span class=cl>│   ├── 000001_create_user.down.sql
</span></span><span class=line><span class=cl>│   └── 000001_create_user.up.sql
</span></span><span class=line><span class=cl>├── models
</span></span><span class=line><span class=cl>│   ├── notif
</span></span><span class=line><span class=cl>│   │   └── notif.go
</span></span><span class=line><span class=cl>│   └── user
</span></span><span class=line><span class=cl>│       ├── user_dto.go
</span></span><span class=line><span class=cl>│       └── user_entity.go
</span></span><span class=line><span class=cl>└── pkg
</span></span><span class=line><span class=cl>    ├── db-pg
</span></span><span class=line><span class=cl>    │   └── db.go
</span></span><span class=line><span class=cl>    ├── errr
</span></span><span class=line><span class=cl>    │   └── custom_err.go
</span></span><span class=line><span class=cl>    ├── mid
</span></span><span class=line><span class=cl>    │   └── middleware.go
</span></span><span class=line><span class=cl>    ├── mlog
</span></span><span class=line><span class=cl>    │   ├── log.go
</span></span><span class=line><span class=cl>    │   └── logger.go
</span></span><span class=line><span class=cl>    └── validate
</span></span><span class=line><span class=cl>        └── validate.go
</span></span></code></pre></div><h3 id=folder-app>Folder: app/<a hidden class=anchor aria-hidden=true href=#folder-app>#</a></h3><p>Menyimpan kode yang tidak dapat digunakan ulang. Titik awal program ketika dijalankan :</p><ul><li>Memulai dan menghentikan aplikasi.</li><li>Spesifik untuk operasi input/output.</li></ul><p>Pada kebanyakan projek lainnya, folder ini akan dinamakan dengan <code>cmd</code>. Dinamakan app karena posisi folder akan berada diatas (yang mana dirasa cukup bagus) dan cukup mewakili fungsi folder.</p><p>Alih-alih menggunakan kerangka kerja seperti Cobra untuk memilih aplikasi yang dijalankan, kita menggunakan metode paling sederhana seperti menjalankan program dengan <code>go run ./app/api-user</code> untuk aplikasi API-USER dan <code>go run ./app/consumer-user</code> untuk aplikasi KAFKA-USER-CONSUMER.</p><h3 id=folder-pkg>Folder: pkg/<a hidden class=anchor aria-hidden=true href=#folder-pkg>#</a></h3><p>Berisi paket-paket yang dapat digunakan ulang di mana saja, biasanya elemen dasar yang tidak terkait dengan modul bisnis, seperti logger, web framework, dan helper umum. Tempat untuk meletakkan library yang sudah di wrap agar mudah di mock.
Lapisan aplikasi dan lapisan bisnis dapat mengimpor <code>pkg</code>.</p><p>Menggunakan <code>pkg/</code> sebagai penampung kode yang awalnya tidak jelas tempatnya terbukti mempercepat penulisan kode. Pertanyaan seperti <code>"Taruh di mana?"</code> akan mendapatkan jawaban <code>"Taruh di pkg."</code> secara default.</p><h3 id=folder-business-atau-internal>Folder: business/ atau internal/<a hidden class=anchor aria-hidden=true href=#folder-business-atau-internal>#</a></h3><p>Berisi code yang terkait dengan logika bisnis, problem bisnis, data bisnis.</p><h4 id=folder-businessnama-domain>Folder: business/{nama-domain}/*<a hidden class=anchor aria-hidden=true href=#folder-businessnama-domain>#</a></h4><p>Dalam setiap domain bisnis, ada layer service (atau core dalam istilah hexagonal) yang harus tetap bersih dari pustaka eksternal. Ini mencakup lapisan untuk mengakses data persisten (repo) dan interface-interface yang berfungsi sebagai port.</p><h4 id=folder-businessnama-domainsubfolder>Folder: business/{nama-domain}/{subfolder}<a hidden class=anchor aria-hidden=true href=#folder-businessnama-domainsubfolder>#</a></h4><p>Terkadang, sebuah domain dapat menjadi sangat kompleks, sehingga perlu memisahkan service, repo, dan elemen lainnya ke dalam beberapa bagian. Dalam kasus seperti ini, kita lebih memilih untuk mengatur dan memisahkan komponen-komponen tersebut ke dalam folder yang berbeda, yang juga akan memerlukan penggunaan package yang berbeda. Misalnya, business/complex.</p><h3 id=folder-models>Folder: models<a hidden class=anchor aria-hidden=true href=#folder-models>#</a></h3><p>Model-model (termasuk DTO, Payload, Entitas) dapat diletakkan di dalam package bisnis masing-masing. Namun, dalam kasus yang kompleks, di mana aplikasi A membutuhkan model B dan C, kita bisa mempertimbangkan untuk menempatkan model-model tersebut di level yang lebih tinggi agar dapat diakses oleh semuanya.</p><h2 id=rules>Rules<a hidden class=anchor aria-hidden=true href=#rules>#</a></h2><p>Sangat penting untuk membuat dan memperbarui aturan yang telah disepakati agar semua pihak mengikuti pendekatan yang konsisten. Misalnya, template repositori ini didasarkan pada kemampuannya untuk menghindari kode yang terlalu terikat (tightly-coupled), maka aturan <code>Cara Penulisan Dependensi Kode</code> menjadi sangat penting untuk dipatuhi.</p><p>Aturan ini akan bertambah seiring berjalannya waktu. Misalnya, yang seringkali terjadi perbedaan pendapat :</p><ul><li><code>Bagaimana cara melakukan database transaction di logic layer ?</code></li><li><code>Seberapa dalam kondisi if else boleh dilakukan</code>. dsb.</li></ul><h3 id=cara-penulisan-dependensi-kode>Cara Penulisan Dependensi Kode<a hidden class=anchor aria-hidden=true href=#cara-penulisan-dependensi-kode>#</a></h3><h4 id=menggunakan-dependency-injection->Menggunakan Dependency Injection :<a hidden class=anchor aria-hidden=true href=#menggunakan-dependency-injection->#</a></h4><p>Dependency Injection (DI) adalah pola desain di mana dependensi disediakan dari luar objek tersebut. Ini membantu mengelola ketergantungan antar komponen, membuat kode lebih modular, dan memudahkan pengujian. Jadi, modul yang saling ketergantungan, harus bergantung pada abstraksi.</p><p>Contoh konstruktor untuk membuat logic service user <code>business/user/service.go</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>UserService</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>storer</span>   <span class=nx>UserStorer</span>
</span></span><span class=line><span class=cl>	<span class=nx>notifier</span> <span class=nx>NotifSender</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// NewUserService memerlukan UserStorer dan NotifSender.
</span></span></span><span class=line><span class=cl><span class=c1>// UserStorer dan NotifSender adalah abstraksi yang diperlukan oleh UserService
</span></span></span><span class=line><span class=cl><span class=c1>// Objek yang akan memenuhi UserStorer dan NotifSender ini akan ditentukan oleh 
</span></span></span><span class=line><span class=cl><span class=c1>// pengaturan dependensi di folder /app.
</span></span></span><span class=line><span class=cl><span class=c1>// UserStorer dan NotifSender juga dapat dibuat tiruannya untuk memudahkan pengujian
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>NewUserService</span><span class=p>(</span><span class=nx>store</span> <span class=nx>UserStorer</span><span class=p>,</span> <span class=nx>notifier</span> <span class=nx>NotifSender</span><span class=p>)</span> <span class=o>*</span><span class=nx>UserService</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>UserService</span><span class=p>{</span><span class=nx>storer</span><span class=p>:</span> <span class=nx>store</span><span class=p>,</span> <span class=nx>notifier</span><span class=p>:</span> <span class=nx>notifier</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=menerapkan-prinsip-dependency-inversion>Menerapkan Prinsip Dependency Inversion:<a hidden class=anchor aria-hidden=true href=#menerapkan-prinsip-dependency-inversion>#</a></h4><p>Di lapisan business, terutama untuk bagian logic (biasanya dinamakan <code>service.go</code> atau <code>usecase.go</code> atau <code>core</code>), komunikasi antar layer mengandalkan abstraksi dan penerapan prinsip <code>dependency inversion</code> yang kuat. Dalam golang, dependensi inversi yang sesungguhnya bisa dicapai seperti penjelasan pada gambar berikut.</p><figure><img src=/img/project/invers-interface.webp alt="dependency inversion interface golang" class="clickable-image lazyload" data-src=/img/project/invers-interface.webp loading=lazy></figure><p>Mengenai posisi interface, sebaiknya diletakkan pada modul yang membutuhkannya. Hal ini pernah dibahas dalam buku <a href=https://www.manning.com/books/100-go-mistakes-and-how-to-avoid-them>100 Go Mistake and how to avoid them</a> dan beberapa buku lainnya.</p><p>Misalnya, domain <code>business/user</code> memerlukan fungsi untuk mengirimkan notifikasi yang bisa dipenuhi oleh <code>business/notifserv</code>, namun tidak secara gamblang <code>business/user</code> mengatakan perlu <code>business/notifserv</code>, melainkan lebih kepada mengatakan <code>"Saya perlu unit yang bisa menjalankan SendNotification()"</code> &ndash; titik.<br>Implementasi dependensinya dapat dilihat di <code>app/api-user/routing.go</code>. Metode ini mencegah error siklus dependensi impor dan memastikan kode tetap tidak terlalu terikat (tightly-coupled) antar domain.</p><p>Contoh dependensi yang dibutuhkan untuk membuat core logic user <code>business/user/storer.go</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>user</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;context&#34;</span>
</span></span><span class=line><span class=cl>	<span class=nx>modelUser</span> <span class=s>&#34;templaterepo/models/user&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// UserStorer adalah interface yang mendefinisikan operasi yang dapat dilakukan terhadap database user.
</span></span></span><span class=line><span class=cl><span class=c1>// Interface ini Merupakan milik dari layer service dan dimaksudkan ditulis pada bagian layer service
</span></span></span><span class=line><span class=cl><span class=c1>// Meskipun kita tau persis implementasinya ada di business/user/repo.go, tetap layer service (core) hanya bergantung pada interface ini.
</span></span></span><span class=line><span class=cl><span class=c1>// Implementasi konkret dari antarmuka ini akan ditentukan oleh pengaturan dependensi di folder /app.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>UserStorer</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>uid</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>modelUser</span><span class=p>.</span><span class=nx>UserDTO</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>CreateOne</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>user</span> <span class=o>*</span><span class=nx>modelUser</span><span class=p>.</span><span class=nx>UserEntity</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// NotifSender adalah interface yang mendefinisikan operasi untuk mengirim notifikasi.
</span></span></span><span class=line><span class=cl><span class=c1>// Interface ini Merupakan milik dari layer service dan dimaksudkan ditulis pada bagian layer service
</span></span></span><span class=line><span class=cl><span class=c1>// Objek yang digunakan untuk mengirim notifikasi akan ditentukan oleh pengaturan dependensi di folder /app.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>NotifSender</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>SendNotification</span><span class=p>(</span><span class=nx>message</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Contoh konstruktor untuk membuat notif <code>business/notifserv/service.go</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>notifserv</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>NotifService</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// return konkrit struct, bukan interfacenya
</span></span></span><span class=line><span class=cl><span class=c1>// karena NotifService tidak dikekang hanya untuk menjadi NotifSender
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>NewNotifServ</span><span class=p>()</span> <span class=o>*</span><span class=nx>NotifService</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>NotifService</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// SendNotification diperlukan untuk memenuhi interface NotifSender pada service user
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>n</span> <span class=o>*</span><span class=nx>NotifService</span><span class=p>)</span> <span class=nf>SendNotification</span><span class=p>(</span><span class=nx>message</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// TODO : send notif to other server
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// SendWhatsapp tidak diperlukan oleh service user namun bisa jadi diperlukan oleh service lain
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>n</span> <span class=o>*</span><span class=nx>NotifService</span><span class=p>)</span> <span class=nf>SendWhatsapp</span><span class=p>(</span><span class=nx>message</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>phone</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// TODO : send whatsapp 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=aturan-lainnya-yang-disepakati>Aturan Lainnya yang Disepakati<a hidden class=anchor aria-hidden=true href=#aturan-lainnya-yang-disepakati>#</a></h3><ul><li>Ikuti panduan gaya Uber sebagai dasar (<a href=https://github.com/uber-go/guide/blob/master/style.md>https://github.com/uber-go/guide/blob/master/style.md</a>). Aturan ini akan ditimpa apabila ada aturan yang tertulis disini.</li><li>File konfigurasi hanya boleh diakses di main.go. Lapisan lain yang ingin mengakses konfigurasi harus menerimanya melalui parameter fungsi.</li><li>Konfigurasi harus memiliki nilai default yang berfungsi di environment lokal, yang dapat ditimpa oleh file <code>.env</code> dan argumen pada command line.</li><li>Error harus dihandle hanya sekali dan tidak boleh di abaikan. Maksudnya adalah antara di konsumsi atau di return, tetapi tidak keduanya sekaligus. contoh konsumsi : menulis error pada log, contoh return : mereturn error apabila error tidak nil.</li><li>Jangan mengekspose variable dalam package, Gunakan kombinasi variabel private dan fungsi publik sebagai gantinya.</li><li>Ketika kode banyak digunakan, buatlah helper.go. Namun jika digunakan di beberapa paket, buatlah paket baru (misalnya untuk mengekstrak error yang cuma ada di user, <code>/business/user/ipkg/error_parser.go</code>). Jika penggunaannya sangat luas, masukkan di <code>/pkg</code> (misalnya, <code>pkg/slicer/slicer.go</code>, <code>pkg/datastructure/ds.go</code>, <code>pkg/errr/custom_error.go</code>).</li><li>Patuhi idiom golang. Namakan interface dengan akhiran -er atau -tor untuk menunjukkan bahwa mereka adalah interface, misalnya Writer, Reader, Assumer, Saver, Reader, Generator. (<a href=https://go.dev/doc/effective_go#interface-names>https://go.dev/doc/effective_go#interface-names</a>). Contoh: Dalam proyek dengan tiga lapisan: UserServiceAssumer, UserStorer, UserSaver, UserLoader.</li></ul><h2 id=tools>Tools<a hidden class=anchor aria-hidden=true href=#tools>#</a></h2><h3 id=makefile>Makefile<a hidden class=anchor aria-hidden=true href=#makefile>#</a></h3><p>Makefile berisi command untuk membantu proses menjalankan aplikasi dengan cepat karena tidak harus mengingat semua command yang panjang. Berfungsi seperti alias. Caranya adalah dengan menuliskan cmd di file Makefile seperti contoh berikut.</p><p>Baris teratas adalah comment yang akan muncul ketika memanggil helper.<br><code>.PHONY</code> adalah penanda agar terminal tidak menganggap command makefile sebagai akses ke file.<br><code>run/tidy:</code> adalah alias untuk cmd yang ada didalam nya.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1>## run/tidy: run golang formater and tidying code</span>
</span></span><span class=line><span class=cl>.PHONY: run/tidy
</span></span><span class=line><span class=cl>run/tidy:
</span></span><span class=line><span class=cl>  @echo <span class=s1>&#39;Tidying and verifying module dependencies...&#39;</span>
</span></span><span class=line><span class=cl>  go mod tidy
</span></span><span class=line><span class=cl>  go mod verify
</span></span><span class=line><span class=cl>  @echo <span class=s1>&#39;Formatting code...&#39;</span>
</span></span><span class=line><span class=cl>  go fmt ./...
</span></span></code></pre></div><p>Sebagai contoh, untuk menjalankan aplikasi-aplikasi yang ada di repositori ini kita bisa menggunakan command seperti dibawah ini :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 1. pastikan ketersediaan dependency seperti database dll.</span>
</span></span><span class=line><span class=cl><span class=c1># 2. menjalankan aplikasi dengan makefile (lihat file Makefile)</span>
</span></span><span class=line><span class=cl>$ make run/api/user
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># command tersebut akan mengeksekusi</span>
</span></span><span class=line><span class=cl>$ go run ./app/api-user
</span></span><span class=line><span class=cl><span class=c1># sehingga mode http server dari aplikasi akan dijalankan</span>
</span></span></code></pre></div><h3 id=pre-commit>pre-commit<a hidden class=anchor aria-hidden=true href=#pre-commit>#</a></h3><p>Disarankan menggunakan pre-commit (<a href=%22https://pre-commit.com/%22>https://pre-commit.com/</a>).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>// init
</span></span><span class=line><span class=cl>pre-commit install
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// precommit akan di trigger setiap commit
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// manual
</span></span><span class=line><span class=cl>pre-commit run --all-files
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.muchlis.dev/tags/golang/>Golang</a></li><li><a href=https://blog.muchlis.dev/tags/best-practices/>Best Practices</a></li></ul><nav class=paginav><a class=next href=https://blog.muchlis.dev/post/safe-goroutine/><span class=title>Next »</span><br><span>Kesalahan Umum dalam Penggunaan Golang Goroutine</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Struktur Folder dan Aturan Penulisan Kode dalam Project Golang: Preferensi Pribadi on x" href="https://x.com/intent/tweet/?text=Struktur%20Folder%20dan%20Aturan%20Penulisan%20Kode%20dalam%20Project%20Golang%3a%20Preferensi%20Pribadi&amp;url=https%3a%2f%2fblog.muchlis.dev%2fpost%2fstructuring-project-folder%2f&amp;hashtags=Golang%2cBestPractices"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Struktur Folder dan Aturan Penulisan Kode dalam Project Golang: Preferensi Pribadi on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.muchlis.dev%2fpost%2fstructuring-project-folder%2f&amp;title=Struktur%20Folder%20dan%20Aturan%20Penulisan%20Kode%20dalam%20Project%20Golang%3a%20Preferensi%20Pribadi&amp;summary=Struktur%20Folder%20dan%20Aturan%20Penulisan%20Kode%20dalam%20Project%20Golang%3a%20Preferensi%20Pribadi&amp;source=https%3a%2f%2fblog.muchlis.dev%2fpost%2fstructuring-project-folder%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Struktur Folder dan Aturan Penulisan Kode dalam Project Golang: Preferensi Pribadi on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.muchlis.dev%2fpost%2fstructuring-project-folder%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Struktur Folder dan Aturan Penulisan Kode dalam Project Golang: Preferensi Pribadi on whatsapp" href="https://api.whatsapp.com/send?text=Struktur%20Folder%20dan%20Aturan%20Penulisan%20Kode%20dalam%20Project%20Golang%3a%20Preferensi%20Pribadi%20-%20https%3a%2f%2fblog.muchlis.dev%2fpost%2fstructuring-project-folder%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Struktur Folder dan Aturan Penulisan Kode dalam Project Golang: Preferensi Pribadi on telegram" href="https://telegram.me/share/url?text=Struktur%20Folder%20dan%20Aturan%20Penulisan%20Kode%20dalam%20Project%20Golang%3a%20Preferensi%20Pribadi&amp;url=https%3a%2f%2fblog.muchlis.dev%2fpost%2fstructuring-project-folder%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=muchlist/paper data-repo-id=R_kgDOMD4syA data-category=General data-category-id=DIC_kwDOMD4syM4ChOKX data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=id data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.muchlis.dev/>Muchlis Dev</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>