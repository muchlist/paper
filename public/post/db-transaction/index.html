<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Teknik Implementasi Database Transaction pada Logic Layer di Backend Golang | Muchlis Dev</title>
<meta name=keywords content="Golang,Best Practices,Database"><meta name=description content="Teknik tingkat mahir untuk menerapkan database transaction pada arsitektur yang modular"><meta name=author content="Muchlis"><link rel=canonical href=http://localhost:1313/post/db-transaction/><meta name=google-site-verification content="G-F1ZZCKLSJF"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/icon/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/icon/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/icon/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/post/db-transaction/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F1ZZCKLSJF"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F1ZZCKLSJF")}</script><meta property="og:title" content="Teknik Implementasi Database Transaction pada Logic Layer di Backend Golang"><meta property="og:description" content="Teknik tingkat mahir untuk menerapkan database transaction pada arsitektur yang modular"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/post/db-transaction/"><meta property="og:image" content="http://localhost:1313/img/db-transaction/db-trsansaction-ddd.webp"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-10-12T15:19:36+08:00"><meta property="article:modified_time" content="2024-10-12T15:19:36+08:00"><meta property="og:site_name" content="Muchlis Dev"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/img/db-transaction/db-trsansaction-ddd.webp"><meta name=twitter:title content="Teknik Implementasi Database Transaction pada Logic Layer di Backend Golang"><meta name=twitter:description content="Teknik tingkat mahir untuk menerapkan database transaction pada arsitektur yang modular"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/post/"},{"@type":"ListItem","position":2,"name":"Teknik Implementasi Database Transaction pada Logic Layer di Backend Golang","item":"http://localhost:1313/post/db-transaction/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Teknik Implementasi Database Transaction pada Logic Layer di Backend Golang","name":"Teknik Implementasi Database Transaction pada Logic Layer di Backend Golang","description":"Teknik tingkat mahir untuk menerapkan database transaction pada arsitektur yang modular","keywords":["Golang","Best Practices","Database"],"articleBody":"Database transaction adalah aspek krusial dalam pengembangan aplikasi, terutama pada proyek yang menuntut konsistensi data yang tinggi. Artikel ini akan membahas bagaimana cara melakukan transaksi-database pada service layer (logic), dengan tetap mempertahankan prinsip-prinsip clean architecture dan separation of concerns.\nArsitektur terhadap Database Transaction Dalam arsitektur populer seperti Clean Architecture, Hexagonal Architecture, maupun pendekatan Domain-Driven Design (DDD), pemisahan tanggung jawab menjadi kunci utama. Kita umumnya membagi kode menjadi beberapa lapisan, misalnya Handler -\u003e Service -\u003e Repository. Lapisan service idealnya berisi logika bisnis murni tanpa bergantung pada library eksternal, sementara repository bertanggung jawab atas interaksi dengan database.\nNamun, ketika mengimplementasikan operasi database yang memenuhi prinsip ACID (Atomicity, Consistency, Isolation, Durability), muncul pertanyaan: di mana sebaiknya logika database-transaction ditempatkan? Di lapisan logika atau di lapisan repository? Hal ini seringkali menjadi dilema para programmer, terutama karena tantangan yang muncul dari prinsip arsitektur yang mendesak pemecahan akses ke datastore melalui berbagai repository yang kecil-kecil dan termodularisasi.\nnote : Atomicity artinya Menjamin bahwa serangkaian operasi dalam satu transaksi harus sepenuhnya berhasil atau sepenuhnya gagal.\nSebagai ilustrasi, mari kita tinjau kasus transfer uang antar rekening: “Transfer uang dari rekening A ke rekening B, perbarui semua data terkait, dan jika gagal, batalkan seluruh proses.” Terdapat dua pendekatan umum:\nPendekatan A : Logika Transaksi di Repository Pendekatan ini sederhana karena transaksi dimulai dan dikelola langsung di lapisan repository. Namun, pendekatan ini memiliki kelemahan: logika bisnis (transfer uang) tercampur dengan logika akses data. Bayangkan jika ada kebutuhan tambahan, seperti mengirim event saldo ke pihak ketiga sebagai bagian dari atomicity transaksi. Apakah repository harus memiliki dependensi ke layanan eksternal juga? Hal ini jelas melanggar prinsip separation of concerns. Selain itu, service layer menjadi sangat tipis, sehingga menghilangkan manfaat unit test pada layer tersebut.\nPendekatan B : Logika Transaksi di Service Pendekatan ini menempatkan logika transaksi di service layer, sesuai dengan prinsip separation of concerns. Namun, implementasinya lebih menantang. Bagaimana caranya agar service layer tetap independen dari library database, seperti GORM, sambil tetap bisa mengelola transaksi?\nJadi, Di mana sebaiknya logika transaksi ditempatkan? Di lapisan logika atau di lapisan repository? Jawabannya adalah di lapisan logika. Hal ini berlaku baik ketika proses mutasi yang melibatkan interaksi dengan beberapa sumber data, maupun ketika melakukan pengumpulan data (agregasi). Alasannya adalah karena logika bisnislah yang menentukan keadaan valid dari suatu kumpulan data pada waktu tertentu. Dengan kata lain, jika sebuah agregat tidak disimpan dalam keadaan yang utuh dan valid, maka operasi bisnis yang dilakukan akan dianggap tidak sesuai dengan aturan bisnis yang berlaku.\nHal diatas juga sejalan dengan penuturan pada buku DDD yang pernah saya baca. Domain Driven Design\nTantangan dan Solusi Menjaga agar lapisan service tetap murni dari ketergantungan pihak ketiga sambil mengelola transaksi database yang kompleks memang sulit. Namun, beberapa teknik dapat diterapkan untuk mengatasi masalah ini, seperti menggunakan abstraksi transaksi di service tanpa harus berurusan langsung dengan implementasi transaksi dari library database.\nUntuk menjaga kemurnian service layer dan tetap mengelola transaksi database dengan efektif, kita akan menggunakan pendekatan berlapis dengan beberapa komponen kunci:\n1. DBTX interface Mendefinisikan interface yang mengabstraksi operasi database, baik operasi biasa maupun operasi dalam transaksi. Ini memungkinkan service layer untuk berinteraksi dengan database tanpa bergantung pada implementasi spesifik. Interface ini akan mencakup method-method seperti Exec, Query, QueryRow, Begin, Commit, Rollback, dan lainnya yang dibutuhkan. Kabar baiknya, jika kamu menggunakan gorm, hal ini tidak perlu dilakukan karena gorm sudah melakukannya (menggabungkan kedua method tersebut menjadi 1). Disini saya membuat contoh dengan menggunakan pgx.\npackage dbtx import ( \"github.com/jackc/pgx/v5\" \"github.com/jackc/pgx/v5/pgconn\" \"github.com/jackc/pgx/v5/pgxpool\" ) type DBTX interface { // method ini digunakan pgx untuk operasi biasa Prepare(ctx context.Context, name, sql string) (*pgconn.StatementDescription, error) Exec(ctx context.Context, sql string, arguments ...interface{}) (commandTag pgconn.CommandTag, err error) Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error) QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row // method ini digunakan pgx untuk operasi transaction Begin(ctx context.Context) (pgx.Tx, error) Commit(ctx context.Context) error Rollback(ctx context.Context) error // DBTX menggabungkan keduanya... } 2. PGStore Menyediakan implementasi konkret dari interface DBTX untuk library pgx. Struktur ini akan menangani pemilihan antara koneksi database biasa atau koneksi transaksi. PGStore akan memeriksa apakah context berisi transaksi yang aktif (pgx.Tx). Jika ada, operasi database akan dilakukan menggunakan transaksi tersebut. Jika tidak, operasi akan dilakukan menggunakan koneksi pool pgxpool.\nNewPGStore berfungsi untuk membuat instance PGStore. Fungsi ini menerima koneksi pool pgxpool dan (opsional) objek transaksi pgx.Tx. Hal ini akan memudahkan pembuatan instance PGStore dengan cara yang konsisten dan terkontrol.\ntype PGStore struct { NonTX *pgxpool.Pool Tx pgx.Tx } // NewPGStore return interface can execute TX and pgx.Pool func NewPGStore(pool *pgxpool.Pool, tx pgx.Tx) DBTX { var pgstore PGStore if tx != nil { pgstore.Tx = tx return \u0026pgstore } pgstore.NonTX = pool return \u0026pgstore } // Begin implements DBTX func (p *PGStore) Begin(ctx context.Context) (pgx.Tx, error) { if p.Tx != nil { return nil, errors.New(\"cannot begin inside running transaction\") } return p.NonTX.Begin(ctx) } // Commit implements DBTX func (p *PGStore) Commit(ctx context.Context) error { if p.Tx != nil { return p.Tx.Commit(ctx) } return errors.New(\"cannot commit: nil tx value\") } // Rollback implements DBTX func (p *PGStore) Rollback(ctx context.Context) error { if p.Tx != nil { return p.Tx.Rollback(ctx) } return errors.New(\"cannot roleback: nil tx value\") } // Exec implements DBTX func (p *PGStore) Exec(ctx context.Context, sql string, arguments ...interface{}) (commandTag pgconn.CommandTag, err error) { if p.Tx != nil { return p.Tx.Exec(ctx, sql, arguments...) } return p.NonTX.Exec(ctx, sql, arguments...) } // Prepare implements DBTX func (p *PGStore) Prepare(ctx context.Context, name string, sql string) (*pgconn.StatementDescription, error) { if p.Tx != nil { return p.Tx.Prepare(ctx, name, sql) } return nil, errors.New(\"cannot prefare: pool does not have prefare method\") } // Query implements DBTX func (p *PGStore) Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error) { if p.Tx != nil { return p.Tx.Query(ctx, sql, args...) } return p.NonTX.Query(ctx, sql, args...) } // QueryRow implements DBTX func (p *PGStore) QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row { if p.Tx != nil { return p.Tx.QueryRow(ctx, sql, args...) } return p.NonTX.QueryRow(ctx, sql, args...) } 3. Fungsi ExtractTx dan injectTx Selanjutnya kita buat helper yang mengotomasi penggunaan NewPGStore ini. ExtractTx digunakan untuk mengekstraksi koneksi database transaction yang disimpan pada context injectTx digunakan untuk hal yang sebaliknya, yaitu menginjeksi database transaction ke context.\npackage dbtx import ( \"github.com/jackc/pgx/v5\" \"github.com/jackc/pgx/v5/pgxpool\" ) type KeyTransaction string const TXKey KeyTransaction = \"unique-key-transaction\" // ExtractTx extract transaction from context and transform database into dbtx.DBTX func ExtractTx(ctx context.Context, defaultPool *pgxpool.Pool) DBTX { tx, ok := ctx.Value(TXKey).(pgx.Tx) if !ok || tx == nil { return NewPGStore(defaultPool, nil) } return NewPGStore(nil, tx) } // injectTx injects transaction to context func injectTx(ctx context.Context, tx pgx.Tx) context.Context { return context.WithValue(ctx, TXKey, tx) } 4. TxManager dan fungsi WithAtomic WithAtomic mengotomasi penggunaan ExtractTx dan injectTx ini. Merupakan wrapper function yang apabila gagal akan melakukan ROLEBACK, dan apabila berhasil akan melakukan COMMIT database transaction.\nSingkatnya, ketika WithAtomic dipanggil, context akan terisi dengan database transaction, selanjutnya context berisi database transaction itu yang akan dipakai untuk menjalankan operasi-operasi database berikutnya, repository otomatis akan menggunakannya transaction ini karena melakukan ExtractTx setiap kali perintah database dieksekusi.\npada layer logika kita hanya berurusan dengan WithAtomic ini.\npackage dbtx import ( \"log/slog\" \"github.com/jackc/pgx/v5/pgxpool\" ) type TxManager interface { WithAtomic(ctx context.Context, tFunc func(ctx context.Context) error) error } type txManager struct { db *pgxpool.Pool log *slog.Logger } func NewTxManager(sqlDB *pgxpool.Pool, log *slog.Logger) TxManager { return \u0026txManager{ db: sqlDB, log: log, } } // ========================================================================= // TRANSACTION // WithAtomic runs function within transaction // The transaction commits when function were finished without error func (r *txManager) WithAtomic(ctx context.Context, tFunc func(ctx context.Context) error) error { // begin transaction tx, err := r.db.Begin(ctx) if err != nil { return fmt.Errorf(\"begin transaction: %w\", err) } // run callback err = tFunc(injectTx(ctx, tx)) if err != nil { // if error, rollback if errRollback := tx.Rollback(ctx); errRollback != nil { r.log.Error(\"rollback transaction\", slog.String(\"error\", errRollback.Error())) } return err } // if no error, commit if errCommit := tx.Commit(ctx); errCommit != nil { return fmt.Errorf(\"failed to commit transaction: %w\", errCommit) } return nil } 5. Implementasi WithAtomic dan ExtractTx Service Layer: Service layer menggunakan TxManager.WithAtomic untuk membungkus logika bisnis dalam transaksi. Ini memastikan bahwa semua operasi database dalam logika bisnis tersebut dilakukan secara atomik.\nRepository Layer: Repository layer menggunakan ExtractTx untuk mendapatkan objek DBTX yang tepat (berbasis transaksi atau koneksi biasa) dari context. Semua operasi database di repository dilakukan melalui objek DBTX ini.\nSehingga codenya akan kurang lebih menjadi seperti berikut.\ntype service struct { Repo AccountStorer TxManager TxManager // helper untuk transaction menjadi dependecy tambahan atau bisa digabung ke repo } func (s *service) TransferMoney(ctx context.Context, input model.TransferDTO) error { // shared variable untuk menampung hasil didalam WithAtomic jika ada // result := ... // Membungkus prosesnya dengan database transaction txErr := s.TxManager.WithAtomic(ctx, func(ctx context.Context) error { // Mengambil account A accountA, err := s.Repo.GetAccountByID(ctx, input.AccountA) if err != nil { return err // Gagal mengambil account A } // Mengambil account B accountB, err := s.Repo.GetAccountByID(ctx, input.AccountB) if err != nil { return err // Gagal mengambil account B } // Memeriksa apakah saldo account A cukup if accountA.Balance \u003c input.Amount { return errors.New(\"saldo tidak cukup\") // Gagal karena saldo tidak cukup } // Mengurangi saldo account A accountA.Balance -= input.Amount if err := s.Repo.UpdateAccount(ctx, accountA); err != nil { return err // Gagal update saldo account A } // Menambahkan jumlah ke saldo account B accountB.Balance += input.Amount if err := s.Repo.UpdateAccount(ctx, accountB); err != nil { return err // Gagal update saldo account B } return nil }) if txErr != nil { return txErr } return nil } // Mengambil account berdasarkan ID func (r *repo) GetAccountByID(ctx context.Context, id uint) (model.AccountEntity, error) { dbtx := ExtractTx(ctx, r.db) // mengekstraksi context dan menjadikan db biasa menjadi DBTX interface var account model.AccountModel err := dbtx.QueryRow(ctx, \"SELECT * FROM accounts WHERE id = $1\", id).Scan( /* ...scan fields of account... */ ) return account, err } // Mengupdate account func (r *repo) UpdateAccount(ctx context.Context, account model.AccountEntity) error { dbtx := ExtractTx(ctx, r.db) // mengekstraksi context dan menjadikan db biasa menjadi DBTX interface _, err := dbtx.Exec(ctx, ` UPDATE accounts SET balance = $1 WHERE id = $2`, account.Balance, account.ID) return err } Dengan mengimplementasikan cara diatas, kita berhasil memisahkan lapisan logika dari ketergantungan pada library pihak ketiga. Pada contoh repository yang saya sertakan, dapat dilihat bahwa untuk mengganti ORM pun, service layer tidak memerlukan perubahan apapun. YEYY.\nMari kita jabarkan lagi, apa saja keuntungannya :\nLogic layer tetap murni, tidak tercemar oleh package gorm atau driver lainnya. Transaksi database dapat dikendalikan dengan efektif, memungkinkan untuk mengatur scope transaksi dijaga sekecil mungkin jika diperlukan. Pendekatan ini berbeda dengan penerapan transaksi dalam middleware, yang dapat menyebabkan seluruh proses logika berada dalam satu transaksi database. Readability kode tetap terjaga. Unit testing tetap berfokus pada logika bisnis saja. Sample Github Repository Saya menyertakan contoh kode dalam dua versi, satu untuk GORM dan satu lagi untuk implementasi lainnya (pgx). Di sini, GORM lebih simple karena secara dasar GORM telah menggabungkan operasi database biasa dengan operasi database transaction.\nBerikut ini repositorynya : REPOSITORY\nDalam menerapkan transaksi database, penting juga untuk mempertimbangkan kemungkinan terjadinya deadlock. Dalam contoh kode yang saya berikan di atas, saya telah menyederhanakan kode dengan mengesampingkan aspek-aspek tersebut. Saya akan membahas tentang deadlock lebih lanjut dalam kesempatan berikutnya.\n","wordCount":"1848","inLanguage":"en","image":"http://localhost:1313/img/db-transaction/db-trsansaction-ddd.webp","datePublished":"2024-10-12T15:19:36+08:00","dateModified":"2024-10-12T15:19:36+08:00","author":{"@type":"Person","name":"Muchlis"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/post/db-transaction/"},"publisher":{"@type":"Organization","name":"Muchlis Dev","logo":{"@type":"ImageObject","url":"http://localhost:1313/icon/favicon.ico"}}}</script><link rel=stylesheet href=http://localhost:1313/css/custom-styles.min.846e2c0c38b3403ffecfec3d9c9b227dcfa79e75b178a91e1a26ae745cf5da5a.css><script src=http://localhost:1313/js/clickable-image.min.64e4ed1fd2302afde6a6750edcf663d18d6bf3b36d95ac130501827d8732c7a3.js defer></script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/icon/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://muchlis.dev title="Portfolio (2021)"><span>Portfolio (2021)</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Teknik Implementasi Database Transaction pada Logic Layer di Backend Golang</h1><div class=post-description>Teknik tingkat mahir untuk menerapkan database transaction pada arsitektur yang modular</div><div class=post-meta><span title='2024-10-12 15:19:36 +0800 WITA'>October 12, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1848 words&nbsp;·&nbsp;Muchlis&nbsp;|&nbsp;<a href=https://github.com/muchlist/paper/tree/main/content/post/db-transaction.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#arsitektur-terhadap-database-transaction>Arsitektur terhadap Database Transaction</a><ul><li><a href=#pendekatan-a--logika-transaksi-di-repository>Pendekatan A : Logika Transaksi di Repository</a></li><li><a href=#pendekatan-b--logika-transaksi-di-service>Pendekatan B : Logika Transaksi di Service</a></li></ul></li><li><a href=#jadi-di-mana-sebaiknya-logika-transaksi-ditempatkan-di-lapisan-logika-atau-di-lapisan-repository>Jadi, Di mana sebaiknya logika transaksi ditempatkan? Di lapisan logika atau di lapisan repository?</a></li><li><a href=#tantangan-dan-solusi>Tantangan dan Solusi</a><ul><li><a href=#1-dbtx-interface>1. DBTX interface</a></li><li><a href=#2-pgstore>2. PGStore</a></li><li><a href=#3-fungsi-extracttx-dan-injecttx>3. Fungsi ExtractTx dan injectTx</a></li><li><a href=#4-txmanager-dan-fungsi-withatomic>4. TxManager dan fungsi WithAtomic</a></li><li><a href=#5-implementasi-withatomic-dan-extracttx>5. Implementasi WithAtomic dan ExtractTx</a></li></ul></li><li><a href=#sample-github-repository>Sample Github Repository</a></li></ul></nav></div></details></div><div class=post-content><p>Database transaction adalah aspek krusial dalam pengembangan aplikasi, terutama pada proyek yang menuntut konsistensi data yang tinggi. Artikel ini akan membahas bagaimana cara melakukan transaksi-database pada service layer (logic), dengan tetap mempertahankan prinsip-prinsip clean architecture dan separation of concerns.</p><h2 id=arsitektur-terhadap-database-transaction>Arsitektur terhadap Database Transaction<a hidden class=anchor aria-hidden=true href=#arsitektur-terhadap-database-transaction>#</a></h2><p>Dalam arsitektur populer seperti Clean Architecture, Hexagonal Architecture, maupun pendekatan Domain-Driven Design (DDD), pemisahan tanggung jawab menjadi kunci utama. Kita umumnya membagi kode menjadi beberapa lapisan, misalnya Handler -> Service -> Repository. Lapisan service idealnya berisi logika bisnis murni tanpa bergantung pada library eksternal, sementara repository bertanggung jawab atas interaksi dengan database.</p><p>Namun, ketika mengimplementasikan operasi database yang memenuhi prinsip ACID (Atomicity, Consistency, Isolation, Durability), muncul pertanyaan: <strong><code>di mana sebaiknya logika database-transaction ditempatkan?</code></strong> Di lapisan logika atau di lapisan repository? Hal ini seringkali menjadi dilema para programmer, terutama karena tantangan yang muncul dari prinsip arsitektur yang mendesak pemecahan akses ke datastore melalui berbagai repository yang kecil-kecil dan termodularisasi.</p><blockquote><p>note : Atomicity artinya Menjamin bahwa serangkaian operasi dalam satu transaksi harus sepenuhnya berhasil atau sepenuhnya gagal.</p></blockquote><p>Sebagai ilustrasi, mari kita tinjau kasus transfer uang antar rekening: &ldquo;Transfer uang dari rekening A ke rekening B, perbarui semua data terkait, dan jika gagal, batalkan seluruh proses.&rdquo; Terdapat dua pendekatan umum:</p><h3 id=pendekatan-a--logika-transaksi-di-repository>Pendekatan A : Logika Transaksi di Repository<a hidden class=anchor aria-hidden=true href=#pendekatan-a--logika-transaksi-di-repository>#</a></h3><figure><img src=/img/db-transaction/transaction-logic-in-repo.webp alt="database transaction logic in repo" class="clickable-image lazyload" data-src=/img/db-transaction/transaction-logic-in-repo.webp loading=lazy></figure><p>Pendekatan ini sederhana karena transaksi dimulai dan dikelola langsung di lapisan repository. Namun, pendekatan ini memiliki kelemahan: logika bisnis (transfer uang) tercampur dengan logika akses data. Bayangkan jika ada kebutuhan tambahan, seperti mengirim event saldo ke pihak ketiga sebagai bagian dari atomicity transaksi. Apakah repository harus memiliki dependensi ke layanan eksternal juga? Hal ini jelas melanggar prinsip separation of concerns. Selain itu, service layer menjadi sangat tipis, sehingga menghilangkan manfaat unit test pada layer tersebut.</p><h3 id=pendekatan-b--logika-transaksi-di-service>Pendekatan B : Logika Transaksi di Service<a hidden class=anchor aria-hidden=true href=#pendekatan-b--logika-transaksi-di-service>#</a></h3><figure><img src=/img/db-transaction/transaction-logic-in-service.webp alt="database transaction logic in service" class="clickable-image lazyload" data-src=/img/db-transaction/transaction-logic-in-service.webp loading=lazy></figure><p>Pendekatan ini menempatkan logika transaksi di service layer, sesuai dengan prinsip separation of concerns. Namun, implementasinya lebih menantang. Bagaimana caranya agar service layer tetap independen dari library database, seperti GORM, sambil tetap bisa mengelola transaksi?</p><h2 id=jadi-di-mana-sebaiknya-logika-transaksi-ditempatkan-di-lapisan-logika-atau-di-lapisan-repository>Jadi, Di mana sebaiknya logika transaksi ditempatkan? Di lapisan logika atau di lapisan repository?<a hidden class=anchor aria-hidden=true href=#jadi-di-mana-sebaiknya-logika-transaksi-ditempatkan-di-lapisan-logika-atau-di-lapisan-repository>#</a></h2><p>Jawabannya adalah di lapisan logika. Hal ini berlaku baik ketika proses mutasi yang melibatkan interaksi dengan beberapa sumber data, maupun ketika melakukan pengumpulan data (agregasi). Alasannya adalah karena logika bisnislah yang menentukan keadaan valid dari suatu kumpulan data pada waktu tertentu. Dengan kata lain, jika sebuah agregat tidak disimpan dalam keadaan yang utuh dan valid, maka operasi bisnis yang dilakukan akan dianggap tidak sesuai dengan aturan bisnis yang berlaku.<br>Hal diatas juga sejalan dengan penuturan pada buku DDD yang pernah saya baca. <a href=https://www.oreilly.com/library/view/domain-driven-design-tackling/0321125215/>Domain Driven Design</a></p><figure><img src=/img/db-transaction/db-trsansaction-ddd.webp alt="database transaction position on ddd" class="clickable-image lazyload" data-src=/img/db-transaction/db-trsansaction-ddd.webp loading=lazy></figure><h2 id=tantangan-dan-solusi>Tantangan dan Solusi<a hidden class=anchor aria-hidden=true href=#tantangan-dan-solusi>#</a></h2><p>Menjaga agar lapisan service tetap murni dari ketergantungan pihak ketiga sambil mengelola transaksi database yang kompleks memang sulit. Namun, beberapa teknik dapat diterapkan untuk mengatasi masalah ini, seperti menggunakan abstraksi transaksi di service tanpa harus berurusan langsung dengan implementasi transaksi dari library database.</p><p>Untuk menjaga kemurnian service layer dan tetap mengelola transaksi database dengan efektif, kita akan menggunakan pendekatan berlapis dengan beberapa komponen kunci:</p><h3 id=1-dbtx-interface>1. DBTX interface<a hidden class=anchor aria-hidden=true href=#1-dbtx-interface>#</a></h3><p>Mendefinisikan interface yang mengabstraksi operasi database, baik operasi biasa maupun operasi dalam transaksi. Ini memungkinkan service layer untuk berinteraksi dengan database tanpa bergantung pada implementasi spesifik. Interface ini akan mencakup method-method seperti Exec, Query, QueryRow, Begin, Commit, Rollback, dan lainnya yang dibutuhkan. Kabar baiknya, jika kamu menggunakan gorm, hal ini tidak perlu dilakukan karena gorm sudah melakukannya (menggabungkan kedua method tersebut menjadi 1). Disini saya membuat contoh dengan menggunakan pgx.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>dbtx</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/jackc/pgx/v5&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/jackc/pgx/v5/pgconn&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/jackc/pgx/v5/pgxpool&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>DBTX</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// method ini digunakan pgx untuk operasi biasa
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>Prepare</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>name</span><span class=p>,</span> <span class=nx>sql</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>pgconn</span><span class=p>.</span><span class=nx>StatementDescription</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>Exec</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>sql</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>arguments</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>commandTag</span> <span class=nx>pgconn</span><span class=p>.</span><span class=nx>CommandTag</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>Query</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>sql</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>args</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>pgx</span><span class=p>.</span><span class=nx>Rows</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>QueryRow</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>sql</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>args</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=nx>pgx</span><span class=p>.</span><span class=nx>Row</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// method ini digunakan pgx untuk operasi transaction
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>Begin</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>pgx</span><span class=p>.</span><span class=nx>Tx</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>Commit</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>	<span class=nf>Rollback</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// DBTX menggabungkan keduanya...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=2-pgstore>2. PGStore<a hidden class=anchor aria-hidden=true href=#2-pgstore>#</a></h3><p>Menyediakan implementasi konkret dari interface DBTX untuk library pgx. Struktur ini akan menangani pemilihan antara koneksi database biasa atau koneksi transaksi. PGStore akan memeriksa apakah context berisi transaksi yang aktif (pgx.Tx). Jika ada, operasi database akan dilakukan menggunakan transaksi tersebut. Jika tidak, operasi akan dilakukan menggunakan koneksi pool pgxpool.</p><p>NewPGStore berfungsi untuk membuat instance PGStore. Fungsi ini menerima koneksi pool pgxpool dan (opsional) objek transaksi pgx.Tx. Hal ini akan memudahkan pembuatan instance PGStore dengan cara yang konsisten dan terkontrol.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>PGStore</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>NonTX</span> <span class=o>*</span><span class=nx>pgxpool</span><span class=p>.</span><span class=nx>Pool</span>
</span></span><span class=line><span class=cl>	<span class=nx>Tx</span>    <span class=nx>pgx</span><span class=p>.</span><span class=nx>Tx</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// NewPGStore return interface can execute TX and pgx.Pool
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>NewPGStore</span><span class=p>(</span><span class=nx>pool</span> <span class=o>*</span><span class=nx>pgxpool</span><span class=p>.</span><span class=nx>Pool</span><span class=p>,</span> <span class=nx>tx</span> <span class=nx>pgx</span><span class=p>.</span><span class=nx>Tx</span><span class=p>)</span> <span class=nx>DBTX</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>pgstore</span> <span class=nx>PGStore</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>tx</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>pgstore</span><span class=p>.</span><span class=nx>Tx</span> <span class=p>=</span> <span class=nx>tx</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>&amp;</span><span class=nx>pgstore</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>pgstore</span><span class=p>.</span><span class=nx>NonTX</span> <span class=p>=</span> <span class=nx>pool</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>pgstore</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Begin implements DBTX
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>PGStore</span><span class=p>)</span> <span class=nf>Begin</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>pgx</span><span class=p>.</span><span class=nx>Tx</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;cannot begin inside running transaction&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>NonTX</span><span class=p>.</span><span class=nf>Begin</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Commit implements DBTX
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>PGStore</span><span class=p>)</span> <span class=nf>Commit</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span><span class=p>.</span><span class=nf>Commit</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;cannot commit: nil tx value&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Rollback implements DBTX
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>PGStore</span><span class=p>)</span> <span class=nf>Rollback</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span><span class=p>.</span><span class=nf>Rollback</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;cannot roleback: nil tx value&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Exec implements DBTX
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>PGStore</span><span class=p>)</span> <span class=nf>Exec</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>sql</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>arguments</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>commandTag</span> <span class=nx>pgconn</span><span class=p>.</span><span class=nx>CommandTag</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span><span class=p>.</span><span class=nf>Exec</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>sql</span><span class=p>,</span> <span class=nx>arguments</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>NonTX</span><span class=p>.</span><span class=nf>Exec</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>sql</span><span class=p>,</span> <span class=nx>arguments</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Prepare implements DBTX
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>PGStore</span><span class=p>)</span> <span class=nf>Prepare</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>name</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>sql</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>pgconn</span><span class=p>.</span><span class=nx>StatementDescription</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span><span class=p>.</span><span class=nf>Prepare</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>name</span><span class=p>,</span> <span class=nx>sql</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;cannot prefare: pool does not have prefare method&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Query implements DBTX
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>PGStore</span><span class=p>)</span> <span class=nf>Query</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>sql</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>args</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>pgx</span><span class=p>.</span><span class=nx>Rows</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span><span class=p>.</span><span class=nf>Query</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>sql</span><span class=p>,</span> <span class=nx>args</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>NonTX</span><span class=p>.</span><span class=nf>Query</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>sql</span><span class=p>,</span> <span class=nx>args</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// QueryRow implements DBTX
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>PGStore</span><span class=p>)</span> <span class=nf>QueryRow</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>sql</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>args</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=nx>pgx</span><span class=p>.</span><span class=nx>Row</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Tx</span><span class=p>.</span><span class=nf>QueryRow</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>sql</span><span class=p>,</span> <span class=nx>args</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>NonTX</span><span class=p>.</span><span class=nf>QueryRow</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>sql</span><span class=p>,</span> <span class=nx>args</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=3-fungsi-extracttx-dan-injecttx>3. Fungsi ExtractTx dan injectTx<a hidden class=anchor aria-hidden=true href=#3-fungsi-extracttx-dan-injecttx>#</a></h3><p>Selanjutnya kita buat helper yang mengotomasi penggunaan <code>NewPGStore</code> ini.
<code>ExtractTx</code> digunakan untuk mengekstraksi <code>koneksi database transaction</code> yang disimpan pada context
<code>injectTx</code> digunakan untuk hal yang sebaliknya, yaitu menginjeksi <code>database transaction</code> ke context.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>dbtx</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/jackc/pgx/v5&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/jackc/pgx/v5/pgxpool&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>KeyTransaction</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=nx>TXKey</span> <span class=nx>KeyTransaction</span> <span class=p>=</span> <span class=s>&#34;unique-key-transaction&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ExtractTx extract transaction from context and transform database into dbtx.DBTX
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>ExtractTx</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>defaultPool</span> <span class=o>*</span><span class=nx>pgxpool</span><span class=p>.</span><span class=nx>Pool</span><span class=p>)</span> <span class=nx>DBTX</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>tx</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Value</span><span class=p>(</span><span class=nx>TXKey</span><span class=p>).(</span><span class=nx>pgx</span><span class=p>.</span><span class=nx>Tx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=o>||</span> <span class=nx>tx</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nf>NewPGStore</span><span class=p>(</span><span class=nx>defaultPool</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>NewPGStore</span><span class=p>(</span><span class=kc>nil</span><span class=p>,</span> <span class=nx>tx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// injectTx injects transaction to context
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>injectTx</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>tx</span> <span class=nx>pgx</span><span class=p>.</span><span class=nx>Tx</span><span class=p>)</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>TXKey</span><span class=p>,</span> <span class=nx>tx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=4-txmanager-dan-fungsi-withatomic>4. TxManager dan fungsi WithAtomic<a hidden class=anchor aria-hidden=true href=#4-txmanager-dan-fungsi-withatomic>#</a></h3><p>WithAtomic mengotomasi penggunaan ExtractTx dan injectTx ini. Merupakan wrapper function yang apabila gagal akan melakukan ROLEBACK, dan apabila berhasil akan melakukan COMMIT database transaction.</p><p>Singkatnya, ketika WithAtomic dipanggil, context akan terisi dengan database transaction, selanjutnya context berisi database transaction itu yang akan dipakai untuk menjalankan operasi-operasi database berikutnya, repository otomatis akan menggunakannya transaction ini karena melakukan ExtractTx setiap kali perintah database dieksekusi.</p><p>pada layer logika kita hanya berurusan dengan WithAtomic ini.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>dbtx</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;log/slog&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/jackc/pgx/v5/pgxpool&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>TxManager</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>WithAtomic</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>tFunc</span> <span class=kd>func</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>txManager</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>db</span>  <span class=o>*</span><span class=nx>pgxpool</span><span class=p>.</span><span class=nx>Pool</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span> <span class=o>*</span><span class=nx>slog</span><span class=p>.</span><span class=nx>Logger</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewTxManager</span><span class=p>(</span><span class=nx>sqlDB</span> <span class=o>*</span><span class=nx>pgxpool</span><span class=p>.</span><span class=nx>Pool</span><span class=p>,</span> <span class=nx>log</span> <span class=o>*</span><span class=nx>slog</span><span class=p>.</span><span class=nx>Logger</span><span class=p>)</span> <span class=nx>TxManager</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>txManager</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>db</span><span class=p>:</span>  <span class=nx>sqlDB</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>:</span> <span class=nx>log</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// =========================================================================
</span></span></span><span class=line><span class=cl><span class=c1>// TRANSACTION
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// WithAtomic runs function within transaction
</span></span></span><span class=line><span class=cl><span class=c1>// The transaction commits when function were finished without error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>txManager</span><span class=p>)</span> <span class=nf>WithAtomic</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>tFunc</span> <span class=kd>func</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// begin transaction
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>tx</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>db</span><span class=p>.</span><span class=nf>Begin</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;begin transaction: %w&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// run callback
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>err</span> <span class=p>=</span> <span class=nf>tFunc</span><span class=p>(</span><span class=nf>injectTx</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>tx</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// if error, rollback
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>errRollback</span> <span class=o>:=</span> <span class=nx>tx</span><span class=p>.</span><span class=nf>Rollback</span><span class=p>(</span><span class=nx>ctx</span><span class=p>);</span> <span class=nx>errRollback</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>r</span><span class=p>.</span><span class=nx>log</span><span class=p>.</span><span class=nf>Error</span><span class=p>(</span><span class=s>&#34;rollback transaction&#34;</span><span class=p>,</span> <span class=nx>slog</span><span class=p>.</span><span class=nf>String</span><span class=p>(</span><span class=s>&#34;error&#34;</span><span class=p>,</span> <span class=nx>errRollback</span><span class=p>.</span><span class=nf>Error</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// if no error, commit
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>errCommit</span> <span class=o>:=</span> <span class=nx>tx</span><span class=p>.</span><span class=nf>Commit</span><span class=p>(</span><span class=nx>ctx</span><span class=p>);</span> <span class=nx>errCommit</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;failed to commit transaction: %w&#34;</span><span class=p>,</span> <span class=nx>errCommit</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=5-implementasi-withatomic-dan-extracttx>5. Implementasi WithAtomic dan ExtractTx<a hidden class=anchor aria-hidden=true href=#5-implementasi-withatomic-dan-extracttx>#</a></h3><h4 id=service-layer>Service Layer:<a hidden class=anchor aria-hidden=true href=#service-layer>#</a></h4><p>Service layer menggunakan TxManager.WithAtomic untuk membungkus logika bisnis dalam transaksi. Ini memastikan bahwa semua operasi database dalam logika bisnis tersebut dilakukan secara atomik.</p><h4 id=repository-layer>Repository Layer:<a hidden class=anchor aria-hidden=true href=#repository-layer>#</a></h4><p>Repository layer menggunakan ExtractTx untuk mendapatkan objek DBTX yang tepat (berbasis transaksi atau koneksi biasa) dari context. Semua operasi database di repository dilakukan melalui objek DBTX ini.</p><p>Sehingga codenya akan kurang lebih menjadi seperti berikut.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>service</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Repo</span>      <span class=nx>AccountStorer</span>
</span></span><span class=line><span class=cl>	<span class=nx>TxManager</span> <span class=nx>TxManager</span> <span class=c1>// helper untuk transaction menjadi dependecy tambahan atau bisa digabung ke repo
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>service</span><span class=p>)</span> <span class=nf>TransferMoney</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>input</span> <span class=nx>model</span><span class=p>.</span><span class=nx>TransferDTO</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// shared variable untuk menampung hasil didalam WithAtomic jika ada
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// result := ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// Membungkus prosesnya dengan database transaction
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>txErr</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>TxManager</span><span class=p>.</span><span class=nf>WithAtomic</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Mengambil account A
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>accountA</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>Repo</span><span class=p>.</span><span class=nf>GetAccountByID</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>input</span><span class=p>.</span><span class=nx>AccountA</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>err</span> <span class=c1>// Gagal mengambil account A
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Mengambil account B
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>accountB</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>Repo</span><span class=p>.</span><span class=nf>GetAccountByID</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>input</span><span class=p>.</span><span class=nx>AccountB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>err</span> <span class=c1>// Gagal mengambil account B
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Memeriksa apakah saldo account A cukup
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>accountA</span><span class=p>.</span><span class=nx>Balance</span> <span class=p>&lt;</span> <span class=nx>input</span><span class=p>.</span><span class=nx>Amount</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;saldo tidak cukup&#34;</span><span class=p>)</span> <span class=c1>// Gagal karena saldo tidak cukup
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Mengurangi saldo account A
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>accountA</span><span class=p>.</span><span class=nx>Balance</span> <span class=o>-=</span> <span class=nx>input</span><span class=p>.</span><span class=nx>Amount</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>Repo</span><span class=p>.</span><span class=nf>UpdateAccount</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>accountA</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>err</span> <span class=c1>// Gagal update saldo account A
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Menambahkan jumlah ke saldo account B
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>accountB</span><span class=p>.</span><span class=nx>Balance</span> <span class=o>+=</span> <span class=nx>input</span><span class=p>.</span><span class=nx>Amount</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>Repo</span><span class=p>.</span><span class=nf>UpdateAccount</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>accountB</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>err</span> <span class=c1>// Gagal update saldo account B
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>txErr</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>txErr</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Mengambil account berdasarkan ID
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>repo</span><span class=p>)</span> <span class=nf>GetAccountByID</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>id</span> <span class=kt>uint</span><span class=p>)</span> <span class=p>(</span><span class=nx>model</span><span class=p>.</span><span class=nx>AccountEntity</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>dbtx</span> <span class=o>:=</span> <span class=nf>ExtractTx</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>db</span><span class=p>)</span> <span class=c1>// mengekstraksi context dan menjadikan db biasa menjadi DBTX interface
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>account</span> <span class=nx>model</span><span class=p>.</span><span class=nx>AccountModel</span>
</span></span><span class=line><span class=cl>    <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dbtx</span><span class=p>.</span><span class=nf>QueryRow</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;SELECT * FROM accounts WHERE id = $1&#34;</span><span class=p>,</span> <span class=nx>id</span><span class=p>).</span><span class=nf>Scan</span><span class=p>(</span> 
</span></span><span class=line><span class=cl>        <span class=cm>/* ...scan fields of account... */</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>account</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Mengupdate account
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>repo</span><span class=p>)</span> <span class=nf>UpdateAccount</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>account</span> <span class=nx>model</span><span class=p>.</span><span class=nx>AccountEntity</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>dbtx</span> <span class=o>:=</span> <span class=nf>ExtractTx</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>db</span><span class=p>)</span> <span class=c1>// mengekstraksi context dan menjadikan db biasa menjadi DBTX interface
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dbtx</span><span class=p>.</span><span class=nf>Exec</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>`
</span></span></span><span class=line><span class=cl><span class=s>        UPDATE accounts 
</span></span></span><span class=line><span class=cl><span class=s>        SET balance = $1
</span></span></span><span class=line><span class=cl><span class=s>        WHERE id = $2`</span><span class=p>,</span> <span class=nx>account</span><span class=p>.</span><span class=nx>Balance</span><span class=p>,</span> <span class=nx>account</span><span class=p>.</span><span class=nx>ID</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Dengan mengimplementasikan cara diatas, kita berhasil memisahkan lapisan logika dari ketergantungan pada library pihak ketiga. Pada contoh repository yang saya sertakan, dapat dilihat bahwa untuk mengganti ORM pun, service layer tidak memerlukan perubahan apapun. YEYY.</p><p>Mari kita jabarkan lagi, apa saja keuntungannya :</p><ol><li>Logic layer tetap murni, tidak tercemar oleh package gorm atau driver lainnya.</li><li>Transaksi database dapat dikendalikan dengan efektif, memungkinkan untuk mengatur scope transaksi dijaga sekecil mungkin jika diperlukan. Pendekatan ini berbeda dengan penerapan transaksi dalam middleware, yang dapat menyebabkan seluruh proses logika berada dalam satu transaksi database.</li><li>Readability kode tetap terjaga.</li><li>Unit testing tetap berfokus pada logika bisnis saja.</li></ol><h2 id=sample-github-repository>Sample Github Repository<a hidden class=anchor aria-hidden=true href=#sample-github-repository>#</a></h2><p>Saya menyertakan contoh kode dalam dua versi, satu untuk GORM dan satu lagi untuk implementasi lainnya (pgx). Di sini, GORM lebih simple karena secara dasar GORM telah menggabungkan operasi database biasa dengan operasi database transaction.</p><p>Berikut ini repositorynya : <a href=https://github.com/muchlist/example-dbtx-in-logic/blob/main/main.go>REPOSITORY</a></p><p>Dalam menerapkan transaksi database, penting juga untuk mempertimbangkan kemungkinan terjadinya deadlock. Dalam contoh kode yang saya berikan di atas, saya telah menyederhanakan kode dengan mengesampingkan aspek-aspek tersebut. Saya akan membahas tentang deadlock lebih lanjut dalam kesempatan berikutnya.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/golang/>Golang</a></li><li><a href=http://localhost:1313/tags/best-practices/>Best Practices</a></li><li><a href=http://localhost:1313/tags/database/>Database</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/post/struct-separation/><span class=title>« Prev</span><br><span>Mengapa Penting Memisahkan Entity dan Model dalam Pengembangan Aplikasi</span>
</a><a class=next href=http://localhost:1313/post/pagination/><span class=title>Next »</span><br><span>Optimasi Pagination: Mengapa Limit-Offset Bisa Menjadi Bom Waktu dan Cursor Pagination Menjadi Solusinya</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Teknik Implementasi Database Transaction pada Logic Layer di Backend Golang on x" href="https://x.com/intent/tweet/?text=Teknik%20Implementasi%20Database%20Transaction%20pada%20Logic%20Layer%20di%20Backend%20Golang&amp;url=http%3a%2f%2flocalhost%3a1313%2fpost%2fdb-transaction%2f&amp;hashtags=Golang%2cBestPractices%2cDatabase"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Teknik Implementasi Database Transaction pada Logic Layer di Backend Golang on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fpost%2fdb-transaction%2f&amp;title=Teknik%20Implementasi%20Database%20Transaction%20pada%20Logic%20Layer%20di%20Backend%20Golang&amp;summary=Teknik%20Implementasi%20Database%20Transaction%20pada%20Logic%20Layer%20di%20Backend%20Golang&amp;source=http%3a%2f%2flocalhost%3a1313%2fpost%2fdb-transaction%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Teknik Implementasi Database Transaction pada Logic Layer di Backend Golang on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fpost%2fdb-transaction%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Teknik Implementasi Database Transaction pada Logic Layer di Backend Golang on whatsapp" href="https://api.whatsapp.com/send?text=Teknik%20Implementasi%20Database%20Transaction%20pada%20Logic%20Layer%20di%20Backend%20Golang%20-%20http%3a%2f%2flocalhost%3a1313%2fpost%2fdb-transaction%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Teknik Implementasi Database Transaction pada Logic Layer di Backend Golang on telegram" href="https://telegram.me/share/url?text=Teknik%20Implementasi%20Database%20Transaction%20pada%20Logic%20Layer%20di%20Backend%20Golang&amp;url=http%3a%2f%2flocalhost%3a1313%2fpost%2fdb-transaction%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=muchlist/paper data-repo-id=R_kgDOMD4syA data-category=General data-category-id=DIC_kwDOMD4syM4ChOKX data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=id data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Muchlis Dev</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>